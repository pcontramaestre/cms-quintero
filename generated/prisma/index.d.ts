
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * Modelo Account: Representa una cuenta en el sistema (empresa o persona natural)
 * Ahora sirve como entidad principal que se relaciona con las diferentes secciones de información
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model AccountGeneralInfo
 * Modelo AccountGeneralInfo: Almacena la información general de una cuenta
 * Incluye tipo de cuenta, estado, información fiscal y financiera básica
 */
export type AccountGeneralInfo = $Result.DefaultSelection<Prisma.$AccountGeneralInfoPayload>
/**
 * Model AccountContactInfo
 * Modelo AccountContactInfo: Almacena la información de contacto de una cuenta
 * Incluye direcciones, información de contacto principal y datos de comunicación
 */
export type AccountContactInfo = $Result.DefaultSelection<Prisma.$AccountContactInfoPayload>
/**
 * Model AccountCompliance
 * Modelo AccountCompliance: Almacena la información de cumplimiento de una cuenta
 * Incluye licencias, seguros y configuración específica para facturación
 */
export type AccountCompliance = $Result.DefaultSelection<Prisma.$AccountCompliancePayload>
/**
 * Model UserAccount
 * Modelo UserAccount: Tabla de relación muchos a muchos entre usuarios y cuentas
 * Permite que un usuario pertenezca a múltiples cuentas con diferentes roles
 */
export type UserAccount = $Result.DefaultSelection<Prisma.$UserAccountPayload>
/**
 * Model AccountAuth
 * Modelo AccountAuth: Almacena información de autenticación de proveedores externos (OAuth)
 * Utilizado por NextAuth para manejar inicios de sesión con Google, Facebook, etc.
 */
export type AccountAuth = $Result.DefaultSelection<Prisma.$AccountAuthPayload>
/**
 * Model Session
 * Modelo Session: Almacena las sesiones activas de los usuarios
 * Utilizado por NextAuth para mantener el estado de autenticación
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * Modelo VerificationToken: Almacena tokens para verificación de email y restablecimiento de contraseña
 * Utilizado por NextAuth para procesos de verificación
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Profile
 * Modelo Profile: Almacena información detallada del perfil de usuario
 * Contiene datos personales, profesionales, de contacto y redes sociales
 * Se relaciona con ProfileEmail y ProfilePhone para manejar múltiples contactos
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model ProfileEmail
 * Modelo ProfileEmail: Almacena múltiples direcciones de correo electrónico para un perfil
 * Permite clasificarlas por tipo y marcar una como principal
 */
export type ProfileEmail = $Result.DefaultSelection<Prisma.$ProfileEmailPayload>
/**
 * Model ProfilePhone
 * Modelo ProfilePhone: Almacena múltiples números de teléfono para un perfil
 * Permite clasificarlos por tipo y marcar uno como principal
 */
export type ProfilePhone = $Result.DefaultSelection<Prisma.$ProfilePhonePayload>
/**
 * Model Client
 * Modelo Client: Almacena información de los clientes asociados a una cuenta
 * Contiene datos de contacto y se relaciona con las facturas generadas para el cliente
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model ClientPhone
 * Modelo ClientPhone: Almacena múltiples números de teléfono para un cliente
 * Permite clasificarlos por tipo y marcar uno como principal
 */
export type ClientPhone = $Result.DefaultSelection<Prisma.$ClientPhonePayload>
/**
 * Model ClientEmail
 * Modelo ClientEmail: Almacena múltiples direcciones de correo electrónico para un cliente
 * Permite clasificarlas por tipo y marcar una como principal
 */
export type ClientEmail = $Result.DefaultSelection<Prisma.$ClientEmailPayload>
/**
 * Model ClientAddress
 * Modelo ClientAddress: Almacena múltiples direcciones para un cliente
 * Permite clasificarlas por tipo y marcar una como principal
 */
export type ClientAddress = $Result.DefaultSelection<Prisma.$ClientAddressPayload>
/**
 * Model ClientCompany
 * Modelo ClientCompany: Almacena información de las empresas asociadas a un cliente
 * Contiene datos de contacto y se relaciona con las facturas generadas para la empresa
 */
export type ClientCompany = $Result.DefaultSelection<Prisma.$ClientCompanyPayload>
/**
 * Model ClientCompanyPhone
 * Modelo ClientCompanyPhone: Almacena múltiples números de teléfono para una empresa
 * Permite clasificarlos por tipo y marcar uno como principal
 */
export type ClientCompanyPhone = $Result.DefaultSelection<Prisma.$ClientCompanyPhonePayload>
/**
 * Model ClientCompanyEmail
 * Modelo ClientCompanyEmail: Almacena múltiples direcciones de correo electrónico para una empresa
 * Permite clasificarlas por tipo y marcar una como principal
 */
export type ClientCompanyEmail = $Result.DefaultSelection<Prisma.$ClientCompanyEmailPayload>
/**
 * Model ClientCompanyAddress
 * Modelo ClientCompanyAddress: Almacena múltiples direcciones para una empresa
 * Permite clasificarlas por tipo y marcar una como principal
 */
export type ClientCompanyAddress = $Result.DefaultSelection<Prisma.$ClientCompanyAddressPayload>
/**
 * Model UnitOfMeasure
 * Modelo UnitOfMeasure: Almacena las unidades de medida disponibles para los servicios
 * Cada empresa puede tener sus propias unidades de medida personalizadas
 */
export type UnitOfMeasure = $Result.DefaultSelection<Prisma.$UnitOfMeasurePayload>
/**
 * Model Service
 * Modelo Service: Almacena los servicios ofrecidos por una cuenta
 * Incluye nombre, descripción, precio y unidad de medida, y se relaciona con los ítems de facturación
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model Billing
 * Modelo Billing: Almacena las facturas generadas para los clientes
 * Contiene información de fechas, montos y estado, y se relaciona con los ítems de facturación
 */
export type Billing = $Result.DefaultSelection<Prisma.$BillingPayload>
/**
 * Model BillingItem
 * Modelo BillingItem: Almacena los ítems o líneas de detalle de cada factura
 * Contiene información de servicios, cantidades, precios y totales por línea
 */
export type BillingItem = $Result.DefaultSelection<Prisma.$BillingItemPayload>
/**
 * Model BankAccount
 * Modelo BankAccount: Almacena las cuentas bancarias asociadas a una cuenta/empresa
 * Permite que una empresa tenga múltiples cuentas bancarias con diferentes propósitos
 */
export type BankAccount = $Result.DefaultSelection<Prisma.$BankAccountPayload>
/**
 * Model PDFTemplate
 * Modelo PDFTemplate: Almacena las plantillas de PDF para facturas y otros documentos
 * Permite personalizar el aspecto de los documentos generados por cada cuenta
 */
export type PDFTemplate = $Result.DefaultSelection<Prisma.$PDFTemplatePayload>
/**
 * Model User
 * Modelo User: Almacena la información básica de los usuarios del sistema
 * Contiene credenciales de acceso y se relaciona con perfiles, cuentas y sesiones
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AccountType: {
  company: 'company',
  natural_person: 'natural_person',
  non_profit: 'non_profit',
  government: 'government',
  educational: 'educational'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]


export const EntityType: {
  sole_proprietorship: 'sole_proprietorship',
  partnership: 'partnership',
  llc: 'llc',
  c_corporation: 'c_corporation',
  s_corporation: 's_corporation',
  non_profit: 'non_profit',
  other: 'other'
};

export type EntityType = (typeof EntityType)[keyof typeof EntityType]


export const AccountStatus: {
  active: 'active',
  inactive: 'inactive',
  suspended: 'suspended',
  closed: 'closed'
};

export type AccountStatus = (typeof AccountStatus)[keyof typeof AccountStatus]


export const BillingStatus: {
  draft: 'draft',
  sent: 'sent',
  paid: 'paid',
  cancelled: 'cancelled'
};

export type BillingStatus = (typeof BillingStatus)[keyof typeof BillingStatus]


export const ClientType: {
  individual: 'individual',
  sole_proprietorship: 'sole_proprietorship',
  partnership: 'partnership',
  llc: 'llc',
  corporation: 'corporation',
  non_profit: 'non_profit',
  government: 'government',
  other: 'other'
};

export type ClientType = (typeof ClientType)[keyof typeof ClientType]

}

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

export type EntityType = $Enums.EntityType

export const EntityType: typeof $Enums.EntityType

export type AccountStatus = $Enums.AccountStatus

export const AccountStatus: typeof $Enums.AccountStatus

export type BillingStatus = $Enums.BillingStatus

export const BillingStatus: typeof $Enums.BillingStatus

export type ClientType = $Enums.ClientType

export const ClientType: typeof $Enums.ClientType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accountGeneralInfo`: Exposes CRUD operations for the **AccountGeneralInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountGeneralInfos
    * const accountGeneralInfos = await prisma.accountGeneralInfo.findMany()
    * ```
    */
  get accountGeneralInfo(): Prisma.AccountGeneralInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accountContactInfo`: Exposes CRUD operations for the **AccountContactInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountContactInfos
    * const accountContactInfos = await prisma.accountContactInfo.findMany()
    * ```
    */
  get accountContactInfo(): Prisma.AccountContactInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accountCompliance`: Exposes CRUD operations for the **AccountCompliance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountCompliances
    * const accountCompliances = await prisma.accountCompliance.findMany()
    * ```
    */
  get accountCompliance(): Prisma.AccountComplianceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAccount`: Exposes CRUD operations for the **UserAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAccounts
    * const userAccounts = await prisma.userAccount.findMany()
    * ```
    */
  get userAccount(): Prisma.UserAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accountAuth`: Exposes CRUD operations for the **AccountAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountAuths
    * const accountAuths = await prisma.accountAuth.findMany()
    * ```
    */
  get accountAuth(): Prisma.AccountAuthDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profileEmail`: Exposes CRUD operations for the **ProfileEmail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileEmails
    * const profileEmails = await prisma.profileEmail.findMany()
    * ```
    */
  get profileEmail(): Prisma.ProfileEmailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profilePhone`: Exposes CRUD operations for the **ProfilePhone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfilePhones
    * const profilePhones = await prisma.profilePhone.findMany()
    * ```
    */
  get profilePhone(): Prisma.ProfilePhoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientPhone`: Exposes CRUD operations for the **ClientPhone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientPhones
    * const clientPhones = await prisma.clientPhone.findMany()
    * ```
    */
  get clientPhone(): Prisma.ClientPhoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientEmail`: Exposes CRUD operations for the **ClientEmail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientEmails
    * const clientEmails = await prisma.clientEmail.findMany()
    * ```
    */
  get clientEmail(): Prisma.ClientEmailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientAddress`: Exposes CRUD operations for the **ClientAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientAddresses
    * const clientAddresses = await prisma.clientAddress.findMany()
    * ```
    */
  get clientAddress(): Prisma.ClientAddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientCompany`: Exposes CRUD operations for the **ClientCompany** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientCompanies
    * const clientCompanies = await prisma.clientCompany.findMany()
    * ```
    */
  get clientCompany(): Prisma.ClientCompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientCompanyPhone`: Exposes CRUD operations for the **ClientCompanyPhone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientCompanyPhones
    * const clientCompanyPhones = await prisma.clientCompanyPhone.findMany()
    * ```
    */
  get clientCompanyPhone(): Prisma.ClientCompanyPhoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientCompanyEmail`: Exposes CRUD operations for the **ClientCompanyEmail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientCompanyEmails
    * const clientCompanyEmails = await prisma.clientCompanyEmail.findMany()
    * ```
    */
  get clientCompanyEmail(): Prisma.ClientCompanyEmailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientCompanyAddress`: Exposes CRUD operations for the **ClientCompanyAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientCompanyAddresses
    * const clientCompanyAddresses = await prisma.clientCompanyAddress.findMany()
    * ```
    */
  get clientCompanyAddress(): Prisma.ClientCompanyAddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitOfMeasure`: Exposes CRUD operations for the **UnitOfMeasure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitOfMeasures
    * const unitOfMeasures = await prisma.unitOfMeasure.findMany()
    * ```
    */
  get unitOfMeasure(): Prisma.UnitOfMeasureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billing`: Exposes CRUD operations for the **Billing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Billings
    * const billings = await prisma.billing.findMany()
    * ```
    */
  get billing(): Prisma.BillingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billingItem`: Exposes CRUD operations for the **BillingItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingItems
    * const billingItems = await prisma.billingItem.findMany()
    * ```
    */
  get billingItem(): Prisma.BillingItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bankAccount`: Exposes CRUD operations for the **BankAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankAccounts
    * const bankAccounts = await prisma.bankAccount.findMany()
    * ```
    */
  get bankAccount(): Prisma.BankAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pDFTemplate`: Exposes CRUD operations for the **PDFTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PDFTemplates
    * const pDFTemplates = await prisma.pDFTemplate.findMany()
    * ```
    */
  get pDFTemplate(): Prisma.PDFTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    AccountGeneralInfo: 'AccountGeneralInfo',
    AccountContactInfo: 'AccountContactInfo',
    AccountCompliance: 'AccountCompliance',
    UserAccount: 'UserAccount',
    AccountAuth: 'AccountAuth',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    Profile: 'Profile',
    ProfileEmail: 'ProfileEmail',
    ProfilePhone: 'ProfilePhone',
    Client: 'Client',
    ClientPhone: 'ClientPhone',
    ClientEmail: 'ClientEmail',
    ClientAddress: 'ClientAddress',
    ClientCompany: 'ClientCompany',
    ClientCompanyPhone: 'ClientCompanyPhone',
    ClientCompanyEmail: 'ClientCompanyEmail',
    ClientCompanyAddress: 'ClientCompanyAddress',
    UnitOfMeasure: 'UnitOfMeasure',
    Service: 'Service',
    Billing: 'Billing',
    BillingItem: 'BillingItem',
    BankAccount: 'BankAccount',
    PDFTemplate: 'PDFTemplate',
    User: 'User'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "account" | "accountGeneralInfo" | "accountContactInfo" | "accountCompliance" | "userAccount" | "accountAuth" | "session" | "verificationToken" | "profile" | "profileEmail" | "profilePhone" | "client" | "clientPhone" | "clientEmail" | "clientAddress" | "clientCompany" | "clientCompanyPhone" | "clientCompanyEmail" | "clientCompanyAddress" | "unitOfMeasure" | "service" | "billing" | "billingItem" | "bankAccount" | "pDFTemplate" | "user"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      AccountGeneralInfo: {
        payload: Prisma.$AccountGeneralInfoPayload<ExtArgs>
        fields: Prisma.AccountGeneralInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountGeneralInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountGeneralInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountGeneralInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountGeneralInfoPayload>
          }
          findFirst: {
            args: Prisma.AccountGeneralInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountGeneralInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountGeneralInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountGeneralInfoPayload>
          }
          findMany: {
            args: Prisma.AccountGeneralInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountGeneralInfoPayload>[]
          }
          create: {
            args: Prisma.AccountGeneralInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountGeneralInfoPayload>
          }
          createMany: {
            args: Prisma.AccountGeneralInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountGeneralInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountGeneralInfoPayload>
          }
          update: {
            args: Prisma.AccountGeneralInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountGeneralInfoPayload>
          }
          deleteMany: {
            args: Prisma.AccountGeneralInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountGeneralInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountGeneralInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountGeneralInfoPayload>
          }
          aggregate: {
            args: Prisma.AccountGeneralInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountGeneralInfo>
          }
          groupBy: {
            args: Prisma.AccountGeneralInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGeneralInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountGeneralInfoCountArgs<ExtArgs>
            result: $Utils.Optional<AccountGeneralInfoCountAggregateOutputType> | number
          }
        }
      }
      AccountContactInfo: {
        payload: Prisma.$AccountContactInfoPayload<ExtArgs>
        fields: Prisma.AccountContactInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountContactInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountContactInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountContactInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountContactInfoPayload>
          }
          findFirst: {
            args: Prisma.AccountContactInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountContactInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountContactInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountContactInfoPayload>
          }
          findMany: {
            args: Prisma.AccountContactInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountContactInfoPayload>[]
          }
          create: {
            args: Prisma.AccountContactInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountContactInfoPayload>
          }
          createMany: {
            args: Prisma.AccountContactInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountContactInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountContactInfoPayload>
          }
          update: {
            args: Prisma.AccountContactInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountContactInfoPayload>
          }
          deleteMany: {
            args: Prisma.AccountContactInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountContactInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountContactInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountContactInfoPayload>
          }
          aggregate: {
            args: Prisma.AccountContactInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountContactInfo>
          }
          groupBy: {
            args: Prisma.AccountContactInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountContactInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountContactInfoCountArgs<ExtArgs>
            result: $Utils.Optional<AccountContactInfoCountAggregateOutputType> | number
          }
        }
      }
      AccountCompliance: {
        payload: Prisma.$AccountCompliancePayload<ExtArgs>
        fields: Prisma.AccountComplianceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountComplianceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountCompliancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountComplianceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountCompliancePayload>
          }
          findFirst: {
            args: Prisma.AccountComplianceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountCompliancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountComplianceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountCompliancePayload>
          }
          findMany: {
            args: Prisma.AccountComplianceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountCompliancePayload>[]
          }
          create: {
            args: Prisma.AccountComplianceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountCompliancePayload>
          }
          createMany: {
            args: Prisma.AccountComplianceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountComplianceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountCompliancePayload>
          }
          update: {
            args: Prisma.AccountComplianceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountCompliancePayload>
          }
          deleteMany: {
            args: Prisma.AccountComplianceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountComplianceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountComplianceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountCompliancePayload>
          }
          aggregate: {
            args: Prisma.AccountComplianceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountCompliance>
          }
          groupBy: {
            args: Prisma.AccountComplianceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountComplianceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountComplianceCountArgs<ExtArgs>
            result: $Utils.Optional<AccountComplianceCountAggregateOutputType> | number
          }
        }
      }
      UserAccount: {
        payload: Prisma.$UserAccountPayload<ExtArgs>
        fields: Prisma.UserAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          findFirst: {
            args: Prisma.UserAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          findMany: {
            args: Prisma.UserAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>[]
          }
          create: {
            args: Prisma.UserAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          createMany: {
            args: Prisma.UserAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          update: {
            args: Prisma.UserAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          deleteMany: {
            args: Prisma.UserAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          aggregate: {
            args: Prisma.UserAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAccount>
          }
          groupBy: {
            args: Prisma.UserAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAccountCountArgs<ExtArgs>
            result: $Utils.Optional<UserAccountCountAggregateOutputType> | number
          }
        }
      }
      AccountAuth: {
        payload: Prisma.$AccountAuthPayload<ExtArgs>
        fields: Prisma.AccountAuthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountAuthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAuthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountAuthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAuthPayload>
          }
          findFirst: {
            args: Prisma.AccountAuthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAuthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountAuthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAuthPayload>
          }
          findMany: {
            args: Prisma.AccountAuthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAuthPayload>[]
          }
          create: {
            args: Prisma.AccountAuthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAuthPayload>
          }
          createMany: {
            args: Prisma.AccountAuthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountAuthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAuthPayload>
          }
          update: {
            args: Prisma.AccountAuthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAuthPayload>
          }
          deleteMany: {
            args: Prisma.AccountAuthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountAuthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountAuthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountAuthPayload>
          }
          aggregate: {
            args: Prisma.AccountAuthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountAuth>
          }
          groupBy: {
            args: Prisma.AccountAuthGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountAuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountAuthCountArgs<ExtArgs>
            result: $Utils.Optional<AccountAuthCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      ProfileEmail: {
        payload: Prisma.$ProfileEmailPayload<ExtArgs>
        fields: Prisma.ProfileEmailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileEmailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileEmailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileEmailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileEmailPayload>
          }
          findFirst: {
            args: Prisma.ProfileEmailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileEmailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileEmailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileEmailPayload>
          }
          findMany: {
            args: Prisma.ProfileEmailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileEmailPayload>[]
          }
          create: {
            args: Prisma.ProfileEmailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileEmailPayload>
          }
          createMany: {
            args: Prisma.ProfileEmailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProfileEmailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileEmailPayload>
          }
          update: {
            args: Prisma.ProfileEmailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileEmailPayload>
          }
          deleteMany: {
            args: Prisma.ProfileEmailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileEmailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileEmailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileEmailPayload>
          }
          aggregate: {
            args: Prisma.ProfileEmailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileEmail>
          }
          groupBy: {
            args: Prisma.ProfileEmailGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileEmailGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileEmailCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileEmailCountAggregateOutputType> | number
          }
        }
      }
      ProfilePhone: {
        payload: Prisma.$ProfilePhonePayload<ExtArgs>
        fields: Prisma.ProfilePhoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfilePhoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePhonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfilePhoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePhonePayload>
          }
          findFirst: {
            args: Prisma.ProfilePhoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePhonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfilePhoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePhonePayload>
          }
          findMany: {
            args: Prisma.ProfilePhoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePhonePayload>[]
          }
          create: {
            args: Prisma.ProfilePhoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePhonePayload>
          }
          createMany: {
            args: Prisma.ProfilePhoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProfilePhoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePhonePayload>
          }
          update: {
            args: Prisma.ProfilePhoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePhonePayload>
          }
          deleteMany: {
            args: Prisma.ProfilePhoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfilePhoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfilePhoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePhonePayload>
          }
          aggregate: {
            args: Prisma.ProfilePhoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfilePhone>
          }
          groupBy: {
            args: Prisma.ProfilePhoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfilePhoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfilePhoneCountArgs<ExtArgs>
            result: $Utils.Optional<ProfilePhoneCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      ClientPhone: {
        payload: Prisma.$ClientPhonePayload<ExtArgs>
        fields: Prisma.ClientPhoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientPhoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPhonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientPhoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPhonePayload>
          }
          findFirst: {
            args: Prisma.ClientPhoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPhonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientPhoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPhonePayload>
          }
          findMany: {
            args: Prisma.ClientPhoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPhonePayload>[]
          }
          create: {
            args: Prisma.ClientPhoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPhonePayload>
          }
          createMany: {
            args: Prisma.ClientPhoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClientPhoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPhonePayload>
          }
          update: {
            args: Prisma.ClientPhoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPhonePayload>
          }
          deleteMany: {
            args: Prisma.ClientPhoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientPhoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientPhoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPhonePayload>
          }
          aggregate: {
            args: Prisma.ClientPhoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientPhone>
          }
          groupBy: {
            args: Prisma.ClientPhoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientPhoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientPhoneCountArgs<ExtArgs>
            result: $Utils.Optional<ClientPhoneCountAggregateOutputType> | number
          }
        }
      }
      ClientEmail: {
        payload: Prisma.$ClientEmailPayload<ExtArgs>
        fields: Prisma.ClientEmailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientEmailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEmailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientEmailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEmailPayload>
          }
          findFirst: {
            args: Prisma.ClientEmailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEmailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientEmailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEmailPayload>
          }
          findMany: {
            args: Prisma.ClientEmailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEmailPayload>[]
          }
          create: {
            args: Prisma.ClientEmailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEmailPayload>
          }
          createMany: {
            args: Prisma.ClientEmailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClientEmailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEmailPayload>
          }
          update: {
            args: Prisma.ClientEmailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEmailPayload>
          }
          deleteMany: {
            args: Prisma.ClientEmailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientEmailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientEmailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEmailPayload>
          }
          aggregate: {
            args: Prisma.ClientEmailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientEmail>
          }
          groupBy: {
            args: Prisma.ClientEmailGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientEmailGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientEmailCountArgs<ExtArgs>
            result: $Utils.Optional<ClientEmailCountAggregateOutputType> | number
          }
        }
      }
      ClientAddress: {
        payload: Prisma.$ClientAddressPayload<ExtArgs>
        fields: Prisma.ClientAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAddressPayload>
          }
          findFirst: {
            args: Prisma.ClientAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAddressPayload>
          }
          findMany: {
            args: Prisma.ClientAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAddressPayload>[]
          }
          create: {
            args: Prisma.ClientAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAddressPayload>
          }
          createMany: {
            args: Prisma.ClientAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClientAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAddressPayload>
          }
          update: {
            args: Prisma.ClientAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAddressPayload>
          }
          deleteMany: {
            args: Prisma.ClientAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAddressPayload>
          }
          aggregate: {
            args: Prisma.ClientAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientAddress>
          }
          groupBy: {
            args: Prisma.ClientAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientAddressCountArgs<ExtArgs>
            result: $Utils.Optional<ClientAddressCountAggregateOutputType> | number
          }
        }
      }
      ClientCompany: {
        payload: Prisma.$ClientCompanyPayload<ExtArgs>
        fields: Prisma.ClientCompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientCompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientCompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyPayload>
          }
          findFirst: {
            args: Prisma.ClientCompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientCompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyPayload>
          }
          findMany: {
            args: Prisma.ClientCompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyPayload>[]
          }
          create: {
            args: Prisma.ClientCompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyPayload>
          }
          createMany: {
            args: Prisma.ClientCompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClientCompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyPayload>
          }
          update: {
            args: Prisma.ClientCompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyPayload>
          }
          deleteMany: {
            args: Prisma.ClientCompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientCompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientCompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyPayload>
          }
          aggregate: {
            args: Prisma.ClientCompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientCompany>
          }
          groupBy: {
            args: Prisma.ClientCompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientCompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCompanyCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCompanyCountAggregateOutputType> | number
          }
        }
      }
      ClientCompanyPhone: {
        payload: Prisma.$ClientCompanyPhonePayload<ExtArgs>
        fields: Prisma.ClientCompanyPhoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientCompanyPhoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyPhonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientCompanyPhoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyPhonePayload>
          }
          findFirst: {
            args: Prisma.ClientCompanyPhoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyPhonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientCompanyPhoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyPhonePayload>
          }
          findMany: {
            args: Prisma.ClientCompanyPhoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyPhonePayload>[]
          }
          create: {
            args: Prisma.ClientCompanyPhoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyPhonePayload>
          }
          createMany: {
            args: Prisma.ClientCompanyPhoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClientCompanyPhoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyPhonePayload>
          }
          update: {
            args: Prisma.ClientCompanyPhoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyPhonePayload>
          }
          deleteMany: {
            args: Prisma.ClientCompanyPhoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientCompanyPhoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientCompanyPhoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyPhonePayload>
          }
          aggregate: {
            args: Prisma.ClientCompanyPhoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientCompanyPhone>
          }
          groupBy: {
            args: Prisma.ClientCompanyPhoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientCompanyPhoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCompanyPhoneCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCompanyPhoneCountAggregateOutputType> | number
          }
        }
      }
      ClientCompanyEmail: {
        payload: Prisma.$ClientCompanyEmailPayload<ExtArgs>
        fields: Prisma.ClientCompanyEmailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientCompanyEmailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyEmailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientCompanyEmailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyEmailPayload>
          }
          findFirst: {
            args: Prisma.ClientCompanyEmailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyEmailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientCompanyEmailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyEmailPayload>
          }
          findMany: {
            args: Prisma.ClientCompanyEmailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyEmailPayload>[]
          }
          create: {
            args: Prisma.ClientCompanyEmailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyEmailPayload>
          }
          createMany: {
            args: Prisma.ClientCompanyEmailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClientCompanyEmailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyEmailPayload>
          }
          update: {
            args: Prisma.ClientCompanyEmailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyEmailPayload>
          }
          deleteMany: {
            args: Prisma.ClientCompanyEmailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientCompanyEmailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientCompanyEmailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyEmailPayload>
          }
          aggregate: {
            args: Prisma.ClientCompanyEmailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientCompanyEmail>
          }
          groupBy: {
            args: Prisma.ClientCompanyEmailGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientCompanyEmailGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCompanyEmailCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCompanyEmailCountAggregateOutputType> | number
          }
        }
      }
      ClientCompanyAddress: {
        payload: Prisma.$ClientCompanyAddressPayload<ExtArgs>
        fields: Prisma.ClientCompanyAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientCompanyAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientCompanyAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyAddressPayload>
          }
          findFirst: {
            args: Prisma.ClientCompanyAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientCompanyAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyAddressPayload>
          }
          findMany: {
            args: Prisma.ClientCompanyAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyAddressPayload>[]
          }
          create: {
            args: Prisma.ClientCompanyAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyAddressPayload>
          }
          createMany: {
            args: Prisma.ClientCompanyAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClientCompanyAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyAddressPayload>
          }
          update: {
            args: Prisma.ClientCompanyAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyAddressPayload>
          }
          deleteMany: {
            args: Prisma.ClientCompanyAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientCompanyAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientCompanyAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCompanyAddressPayload>
          }
          aggregate: {
            args: Prisma.ClientCompanyAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientCompanyAddress>
          }
          groupBy: {
            args: Prisma.ClientCompanyAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientCompanyAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCompanyAddressCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCompanyAddressCountAggregateOutputType> | number
          }
        }
      }
      UnitOfMeasure: {
        payload: Prisma.$UnitOfMeasurePayload<ExtArgs>
        fields: Prisma.UnitOfMeasureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitOfMeasureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitOfMeasureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurePayload>
          }
          findFirst: {
            args: Prisma.UnitOfMeasureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitOfMeasureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurePayload>
          }
          findMany: {
            args: Prisma.UnitOfMeasureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurePayload>[]
          }
          create: {
            args: Prisma.UnitOfMeasureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurePayload>
          }
          createMany: {
            args: Prisma.UnitOfMeasureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UnitOfMeasureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurePayload>
          }
          update: {
            args: Prisma.UnitOfMeasureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurePayload>
          }
          deleteMany: {
            args: Prisma.UnitOfMeasureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitOfMeasureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnitOfMeasureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurePayload>
          }
          aggregate: {
            args: Prisma.UnitOfMeasureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitOfMeasure>
          }
          groupBy: {
            args: Prisma.UnitOfMeasureGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitOfMeasureGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitOfMeasureCountArgs<ExtArgs>
            result: $Utils.Optional<UnitOfMeasureCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Billing: {
        payload: Prisma.$BillingPayload<ExtArgs>
        fields: Prisma.BillingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPayload>
          }
          findFirst: {
            args: Prisma.BillingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPayload>
          }
          findMany: {
            args: Prisma.BillingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPayload>[]
          }
          create: {
            args: Prisma.BillingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPayload>
          }
          createMany: {
            args: Prisma.BillingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BillingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPayload>
          }
          update: {
            args: Prisma.BillingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPayload>
          }
          deleteMany: {
            args: Prisma.BillingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BillingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPayload>
          }
          aggregate: {
            args: Prisma.BillingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBilling>
          }
          groupBy: {
            args: Prisma.BillingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingCountArgs<ExtArgs>
            result: $Utils.Optional<BillingCountAggregateOutputType> | number
          }
        }
      }
      BillingItem: {
        payload: Prisma.$BillingItemPayload<ExtArgs>
        fields: Prisma.BillingItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingItemPayload>
          }
          findFirst: {
            args: Prisma.BillingItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingItemPayload>
          }
          findMany: {
            args: Prisma.BillingItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingItemPayload>[]
          }
          create: {
            args: Prisma.BillingItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingItemPayload>
          }
          createMany: {
            args: Prisma.BillingItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BillingItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingItemPayload>
          }
          update: {
            args: Prisma.BillingItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingItemPayload>
          }
          deleteMany: {
            args: Prisma.BillingItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillingItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BillingItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingItemPayload>
          }
          aggregate: {
            args: Prisma.BillingItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillingItem>
          }
          groupBy: {
            args: Prisma.BillingItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingItemCountArgs<ExtArgs>
            result: $Utils.Optional<BillingItemCountAggregateOutputType> | number
          }
        }
      }
      BankAccount: {
        payload: Prisma.$BankAccountPayload<ExtArgs>
        fields: Prisma.BankAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findFirst: {
            args: Prisma.BankAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findMany: {
            args: Prisma.BankAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          create: {
            args: Prisma.BankAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          createMany: {
            args: Prisma.BankAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BankAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          update: {
            args: Prisma.BankAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          deleteMany: {
            args: Prisma.BankAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BankAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          aggregate: {
            args: Prisma.BankAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankAccount>
          }
          groupBy: {
            args: Prisma.BankAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankAccountCountArgs<ExtArgs>
            result: $Utils.Optional<BankAccountCountAggregateOutputType> | number
          }
        }
      }
      PDFTemplate: {
        payload: Prisma.$PDFTemplatePayload<ExtArgs>
        fields: Prisma.PDFTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PDFTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PDFTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PDFTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PDFTemplatePayload>
          }
          findFirst: {
            args: Prisma.PDFTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PDFTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PDFTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PDFTemplatePayload>
          }
          findMany: {
            args: Prisma.PDFTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PDFTemplatePayload>[]
          }
          create: {
            args: Prisma.PDFTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PDFTemplatePayload>
          }
          createMany: {
            args: Prisma.PDFTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PDFTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PDFTemplatePayload>
          }
          update: {
            args: Prisma.PDFTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PDFTemplatePayload>
          }
          deleteMany: {
            args: Prisma.PDFTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PDFTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PDFTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PDFTemplatePayload>
          }
          aggregate: {
            args: Prisma.PDFTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePDFTemplate>
          }
          groupBy: {
            args: Prisma.PDFTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<PDFTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.PDFTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<PDFTemplateCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    account?: AccountOmit
    accountGeneralInfo?: AccountGeneralInfoOmit
    accountContactInfo?: AccountContactInfoOmit
    accountCompliance?: AccountComplianceOmit
    userAccount?: UserAccountOmit
    accountAuth?: AccountAuthOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    profile?: ProfileOmit
    profileEmail?: ProfileEmailOmit
    profilePhone?: ProfilePhoneOmit
    client?: ClientOmit
    clientPhone?: ClientPhoneOmit
    clientEmail?: ClientEmailOmit
    clientAddress?: ClientAddressOmit
    clientCompany?: ClientCompanyOmit
    clientCompanyPhone?: ClientCompanyPhoneOmit
    clientCompanyEmail?: ClientCompanyEmailOmit
    clientCompanyAddress?: ClientCompanyAddressOmit
    unitOfMeasure?: UnitOfMeasureOmit
    service?: ServiceOmit
    billing?: BillingOmit
    billingItem?: BillingItemOmit
    bankAccount?: BankAccountOmit
    pDFTemplate?: PDFTemplateOmit
    user?: UserOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    bank_accounts: number
    billings: number
    clients: number
    services: number
    units_of_measure: number
    pdf_templates: number
    users: number
    child_accounts: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bank_accounts?: boolean | AccountCountOutputTypeCountBank_accountsArgs
    billings?: boolean | AccountCountOutputTypeCountBillingsArgs
    clients?: boolean | AccountCountOutputTypeCountClientsArgs
    services?: boolean | AccountCountOutputTypeCountServicesArgs
    units_of_measure?: boolean | AccountCountOutputTypeCountUnits_of_measureArgs
    pdf_templates?: boolean | AccountCountOutputTypeCountPdf_templatesArgs
    users?: boolean | AccountCountOutputTypeCountUsersArgs
    child_accounts?: boolean | AccountCountOutputTypeCountChild_accountsArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountBank_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankAccountWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountBillingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountUnits_of_measureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitOfMeasureWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountPdf_templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PDFTemplateWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAccountWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountChild_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }


  /**
   * Count Type ProfileCountOutputType
   */

  export type ProfileCountOutputType = {
    emails: number
    phones: number
  }

  export type ProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emails?: boolean | ProfileCountOutputTypeCountEmailsArgs
    phones?: boolean | ProfileCountOutputTypeCountPhonesArgs
  }

  // Custom InputTypes
  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileCountOutputType
     */
    select?: ProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileEmailWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountPhonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfilePhoneWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    billings: number
    phones: number
    emails: number
    addresses: number
    ClientCompany: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billings?: boolean | ClientCountOutputTypeCountBillingsArgs
    phones?: boolean | ClientCountOutputTypeCountPhonesArgs
    emails?: boolean | ClientCountOutputTypeCountEmailsArgs
    addresses?: boolean | ClientCountOutputTypeCountAddressesArgs
    ClientCompany?: boolean | ClientCountOutputTypeCountClientCompanyArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountBillingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountPhonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientPhoneWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientEmailWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientAddressWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountClientCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientCompanyWhereInput
  }


  /**
   * Count Type ClientCompanyCountOutputType
   */

  export type ClientCompanyCountOutputType = {
    phones: number
    emails: number
    addresses: number
    billings: number
  }

  export type ClientCompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phones?: boolean | ClientCompanyCountOutputTypeCountPhonesArgs
    emails?: boolean | ClientCompanyCountOutputTypeCountEmailsArgs
    addresses?: boolean | ClientCompanyCountOutputTypeCountAddressesArgs
    billings?: boolean | ClientCompanyCountOutputTypeCountBillingsArgs
  }

  // Custom InputTypes
  /**
   * ClientCompanyCountOutputType without action
   */
  export type ClientCompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyCountOutputType
     */
    select?: ClientCompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCompanyCountOutputType without action
   */
  export type ClientCompanyCountOutputTypeCountPhonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientCompanyPhoneWhereInput
  }

  /**
   * ClientCompanyCountOutputType without action
   */
  export type ClientCompanyCountOutputTypeCountEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientCompanyEmailWhereInput
  }

  /**
   * ClientCompanyCountOutputType without action
   */
  export type ClientCompanyCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientCompanyAddressWhereInput
  }

  /**
   * ClientCompanyCountOutputType without action
   */
  export type ClientCompanyCountOutputTypeCountBillingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingWhereInput
  }


  /**
   * Count Type UnitOfMeasureCountOutputType
   */

  export type UnitOfMeasureCountOutputType = {
    services: number
  }

  export type UnitOfMeasureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | UnitOfMeasureCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * UnitOfMeasureCountOutputType without action
   */
  export type UnitOfMeasureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasureCountOutputType
     */
    select?: UnitOfMeasureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitOfMeasureCountOutputType without action
   */
  export type UnitOfMeasureCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    billing_items: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billing_items?: boolean | ServiceCountOutputTypeCountBilling_itemsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountBilling_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingItemWhereInput
  }


  /**
   * Count Type BillingCountOutputType
   */

  export type BillingCountOutputType = {
    items: number
  }

  export type BillingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | BillingCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * BillingCountOutputType without action
   */
  export type BillingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingCountOutputType
     */
    select?: BillingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BillingCountOutputType without action
   */
  export type BillingCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingItemWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    accountsAuth: number
    sessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    accountsAuth?: boolean | UserCountOutputTypeCountAccountsAuthArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountAuthWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    legal_name: string | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    parent_account_id: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    legal_name: string | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    parent_account_id: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    legal_name: number
    created_at: number
    created_by: number
    updated_at: number
    updated_by: number
    parent_account_id: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    legal_name?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    parent_account_id?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    legal_name?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    parent_account_id?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    legal_name?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    parent_account_id?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    legal_name: string
    created_at: Date
    created_by: string | null
    updated_at: Date
    updated_by: string | null
    parent_account_id: string | null
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    legal_name?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    parent_account_id?: boolean
    general_info?: boolean | Account$general_infoArgs<ExtArgs>
    contact_info?: boolean | Account$contact_infoArgs<ExtArgs>
    compliance_info?: boolean | Account$compliance_infoArgs<ExtArgs>
    bank_accounts?: boolean | Account$bank_accountsArgs<ExtArgs>
    billings?: boolean | Account$billingsArgs<ExtArgs>
    clients?: boolean | Account$clientsArgs<ExtArgs>
    services?: boolean | Account$servicesArgs<ExtArgs>
    units_of_measure?: boolean | Account$units_of_measureArgs<ExtArgs>
    pdf_templates?: boolean | Account$pdf_templatesArgs<ExtArgs>
    users?: boolean | Account$usersArgs<ExtArgs>
    parent_account?: boolean | Account$parent_accountArgs<ExtArgs>
    child_accounts?: boolean | Account$child_accountsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>



  export type AccountSelectScalar = {
    id?: boolean
    legal_name?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    parent_account_id?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "legal_name" | "created_at" | "created_by" | "updated_at" | "updated_by" | "parent_account_id", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    general_info?: boolean | Account$general_infoArgs<ExtArgs>
    contact_info?: boolean | Account$contact_infoArgs<ExtArgs>
    compliance_info?: boolean | Account$compliance_infoArgs<ExtArgs>
    bank_accounts?: boolean | Account$bank_accountsArgs<ExtArgs>
    billings?: boolean | Account$billingsArgs<ExtArgs>
    clients?: boolean | Account$clientsArgs<ExtArgs>
    services?: boolean | Account$servicesArgs<ExtArgs>
    units_of_measure?: boolean | Account$units_of_measureArgs<ExtArgs>
    pdf_templates?: boolean | Account$pdf_templatesArgs<ExtArgs>
    users?: boolean | Account$usersArgs<ExtArgs>
    parent_account?: boolean | Account$parent_accountArgs<ExtArgs>
    child_accounts?: boolean | Account$child_accountsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      general_info: Prisma.$AccountGeneralInfoPayload<ExtArgs> | null
      contact_info: Prisma.$AccountContactInfoPayload<ExtArgs> | null
      compliance_info: Prisma.$AccountCompliancePayload<ExtArgs> | null
      bank_accounts: Prisma.$BankAccountPayload<ExtArgs>[]
      billings: Prisma.$BillingPayload<ExtArgs>[]
      clients: Prisma.$ClientPayload<ExtArgs>[]
      services: Prisma.$ServicePayload<ExtArgs>[]
      units_of_measure: Prisma.$UnitOfMeasurePayload<ExtArgs>[]
      pdf_templates: Prisma.$PDFTemplatePayload<ExtArgs>[]
      users: Prisma.$UserAccountPayload<ExtArgs>[]
      parent_account: Prisma.$AccountPayload<ExtArgs> | null
      child_accounts: Prisma.$AccountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      legal_name: string
      created_at: Date
      created_by: string | null
      updated_at: Date
      updated_by: string | null
      parent_account_id: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    general_info<T extends Account$general_infoArgs<ExtArgs> = {}>(args?: Subset<T, Account$general_infoArgs<ExtArgs>>): Prisma__AccountGeneralInfoClient<$Result.GetResult<Prisma.$AccountGeneralInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contact_info<T extends Account$contact_infoArgs<ExtArgs> = {}>(args?: Subset<T, Account$contact_infoArgs<ExtArgs>>): Prisma__AccountContactInfoClient<$Result.GetResult<Prisma.$AccountContactInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    compliance_info<T extends Account$compliance_infoArgs<ExtArgs> = {}>(args?: Subset<T, Account$compliance_infoArgs<ExtArgs>>): Prisma__AccountComplianceClient<$Result.GetResult<Prisma.$AccountCompliancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bank_accounts<T extends Account$bank_accountsArgs<ExtArgs> = {}>(args?: Subset<T, Account$bank_accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    billings<T extends Account$billingsArgs<ExtArgs> = {}>(args?: Subset<T, Account$billingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clients<T extends Account$clientsArgs<ExtArgs> = {}>(args?: Subset<T, Account$clientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    services<T extends Account$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Account$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    units_of_measure<T extends Account$units_of_measureArgs<ExtArgs> = {}>(args?: Subset<T, Account$units_of_measureArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pdf_templates<T extends Account$pdf_templatesArgs<ExtArgs> = {}>(args?: Subset<T, Account$pdf_templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PDFTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Account$usersArgs<ExtArgs> = {}>(args?: Subset<T, Account$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parent_account<T extends Account$parent_accountArgs<ExtArgs> = {}>(args?: Subset<T, Account$parent_accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    child_accounts<T extends Account$child_accountsArgs<ExtArgs> = {}>(args?: Subset<T, Account$child_accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly legal_name: FieldRef<"Account", 'String'>
    readonly created_at: FieldRef<"Account", 'DateTime'>
    readonly created_by: FieldRef<"Account", 'String'>
    readonly updated_at: FieldRef<"Account", 'DateTime'>
    readonly updated_by: FieldRef<"Account", 'String'>
    readonly parent_account_id: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account.general_info
   */
  export type Account$general_infoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountGeneralInfo
     */
    select?: AccountGeneralInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountGeneralInfo
     */
    omit?: AccountGeneralInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountGeneralInfoInclude<ExtArgs> | null
    where?: AccountGeneralInfoWhereInput
  }

  /**
   * Account.contact_info
   */
  export type Account$contact_infoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountContactInfo
     */
    select?: AccountContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountContactInfo
     */
    omit?: AccountContactInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountContactInfoInclude<ExtArgs> | null
    where?: AccountContactInfoWhereInput
  }

  /**
   * Account.compliance_info
   */
  export type Account$compliance_infoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCompliance
     */
    select?: AccountComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountCompliance
     */
    omit?: AccountComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountComplianceInclude<ExtArgs> | null
    where?: AccountComplianceWhereInput
  }

  /**
   * Account.bank_accounts
   */
  export type Account$bank_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    where?: BankAccountWhereInput
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    cursor?: BankAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * Account.billings
   */
  export type Account$billingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing
     */
    select?: BillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing
     */
    omit?: BillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInclude<ExtArgs> | null
    where?: BillingWhereInput
    orderBy?: BillingOrderByWithRelationInput | BillingOrderByWithRelationInput[]
    cursor?: BillingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillingScalarFieldEnum | BillingScalarFieldEnum[]
  }

  /**
   * Account.clients
   */
  export type Account$clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Account.services
   */
  export type Account$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Account.units_of_measure
   */
  export type Account$units_of_measureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasure
     */
    select?: UnitOfMeasureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasure
     */
    omit?: UnitOfMeasureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasureInclude<ExtArgs> | null
    where?: UnitOfMeasureWhereInput
    orderBy?: UnitOfMeasureOrderByWithRelationInput | UnitOfMeasureOrderByWithRelationInput[]
    cursor?: UnitOfMeasureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitOfMeasureScalarFieldEnum | UnitOfMeasureScalarFieldEnum[]
  }

  /**
   * Account.pdf_templates
   */
  export type Account$pdf_templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PDFTemplate
     */
    select?: PDFTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PDFTemplate
     */
    omit?: PDFTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PDFTemplateInclude<ExtArgs> | null
    where?: PDFTemplateWhereInput
    orderBy?: PDFTemplateOrderByWithRelationInput | PDFTemplateOrderByWithRelationInput[]
    cursor?: PDFTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PDFTemplateScalarFieldEnum | PDFTemplateScalarFieldEnum[]
  }

  /**
   * Account.users
   */
  export type Account$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    where?: UserAccountWhereInput
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    cursor?: UserAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAccountScalarFieldEnum | UserAccountScalarFieldEnum[]
  }

  /**
   * Account.parent_account
   */
  export type Account$parent_accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Account.child_accounts
   */
  export type Account$child_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model AccountGeneralInfo
   */

  export type AggregateAccountGeneralInfo = {
    _count: AccountGeneralInfoCountAggregateOutputType | null
    _min: AccountGeneralInfoMinAggregateOutputType | null
    _max: AccountGeneralInfoMaxAggregateOutputType | null
  }

  export type AccountGeneralInfoMinAggregateOutputType = {
    id: string | null
    account_id: string | null
    type: $Enums.AccountType | null
    status: $Enums.AccountStatus | null
    dba_name: string | null
    entity_type: $Enums.EntityType | null
    ein: string | null
    duns_number: string | null
    incorporation_date: Date | null
    incorporation_state: string | null
    industry: string | null
    currency: string | null
    payment_terms: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AccountGeneralInfoMaxAggregateOutputType = {
    id: string | null
    account_id: string | null
    type: $Enums.AccountType | null
    status: $Enums.AccountStatus | null
    dba_name: string | null
    entity_type: $Enums.EntityType | null
    ein: string | null
    duns_number: string | null
    incorporation_date: Date | null
    incorporation_state: string | null
    industry: string | null
    currency: string | null
    payment_terms: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AccountGeneralInfoCountAggregateOutputType = {
    id: number
    account_id: number
    type: number
    status: number
    dba_name: number
    entity_type: number
    ein: number
    duns_number: number
    incorporation_date: number
    incorporation_state: number
    industry: number
    currency: number
    payment_terms: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AccountGeneralInfoMinAggregateInputType = {
    id?: true
    account_id?: true
    type?: true
    status?: true
    dba_name?: true
    entity_type?: true
    ein?: true
    duns_number?: true
    incorporation_date?: true
    incorporation_state?: true
    industry?: true
    currency?: true
    payment_terms?: true
    created_at?: true
    updated_at?: true
  }

  export type AccountGeneralInfoMaxAggregateInputType = {
    id?: true
    account_id?: true
    type?: true
    status?: true
    dba_name?: true
    entity_type?: true
    ein?: true
    duns_number?: true
    incorporation_date?: true
    incorporation_state?: true
    industry?: true
    currency?: true
    payment_terms?: true
    created_at?: true
    updated_at?: true
  }

  export type AccountGeneralInfoCountAggregateInputType = {
    id?: true
    account_id?: true
    type?: true
    status?: true
    dba_name?: true
    entity_type?: true
    ein?: true
    duns_number?: true
    incorporation_date?: true
    incorporation_state?: true
    industry?: true
    currency?: true
    payment_terms?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AccountGeneralInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountGeneralInfo to aggregate.
     */
    where?: AccountGeneralInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountGeneralInfos to fetch.
     */
    orderBy?: AccountGeneralInfoOrderByWithRelationInput | AccountGeneralInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountGeneralInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountGeneralInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountGeneralInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountGeneralInfos
    **/
    _count?: true | AccountGeneralInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountGeneralInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountGeneralInfoMaxAggregateInputType
  }

  export type GetAccountGeneralInfoAggregateType<T extends AccountGeneralInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountGeneralInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountGeneralInfo[P]>
      : GetScalarType<T[P], AggregateAccountGeneralInfo[P]>
  }




  export type AccountGeneralInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountGeneralInfoWhereInput
    orderBy?: AccountGeneralInfoOrderByWithAggregationInput | AccountGeneralInfoOrderByWithAggregationInput[]
    by: AccountGeneralInfoScalarFieldEnum[] | AccountGeneralInfoScalarFieldEnum
    having?: AccountGeneralInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountGeneralInfoCountAggregateInputType | true
    _min?: AccountGeneralInfoMinAggregateInputType
    _max?: AccountGeneralInfoMaxAggregateInputType
  }

  export type AccountGeneralInfoGroupByOutputType = {
    id: string
    account_id: string
    type: $Enums.AccountType
    status: $Enums.AccountStatus
    dba_name: string | null
    entity_type: $Enums.EntityType | null
    ein: string | null
    duns_number: string | null
    incorporation_date: Date | null
    incorporation_state: string | null
    industry: string | null
    currency: string | null
    payment_terms: string | null
    created_at: Date
    updated_at: Date
    _count: AccountGeneralInfoCountAggregateOutputType | null
    _min: AccountGeneralInfoMinAggregateOutputType | null
    _max: AccountGeneralInfoMaxAggregateOutputType | null
  }

  type GetAccountGeneralInfoGroupByPayload<T extends AccountGeneralInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGeneralInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGeneralInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGeneralInfoGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGeneralInfoGroupByOutputType[P]>
        }
      >
    >


  export type AccountGeneralInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    type?: boolean
    status?: boolean
    dba_name?: boolean
    entity_type?: boolean
    ein?: boolean
    duns_number?: boolean
    incorporation_date?: boolean
    incorporation_state?: boolean
    industry?: boolean
    currency?: boolean
    payment_terms?: boolean
    created_at?: boolean
    updated_at?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountGeneralInfo"]>



  export type AccountGeneralInfoSelectScalar = {
    id?: boolean
    account_id?: boolean
    type?: boolean
    status?: boolean
    dba_name?: boolean
    entity_type?: boolean
    ein?: boolean
    duns_number?: boolean
    incorporation_date?: boolean
    incorporation_state?: boolean
    industry?: boolean
    currency?: boolean
    payment_terms?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AccountGeneralInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "account_id" | "type" | "status" | "dba_name" | "entity_type" | "ein" | "duns_number" | "incorporation_date" | "incorporation_state" | "industry" | "currency" | "payment_terms" | "created_at" | "updated_at", ExtArgs["result"]["accountGeneralInfo"]>
  export type AccountGeneralInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $AccountGeneralInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountGeneralInfo"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      account_id: string
      type: $Enums.AccountType
      status: $Enums.AccountStatus
      dba_name: string | null
      entity_type: $Enums.EntityType | null
      ein: string | null
      duns_number: string | null
      incorporation_date: Date | null
      incorporation_state: string | null
      industry: string | null
      currency: string | null
      payment_terms: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["accountGeneralInfo"]>
    composites: {}
  }

  type AccountGeneralInfoGetPayload<S extends boolean | null | undefined | AccountGeneralInfoDefaultArgs> = $Result.GetResult<Prisma.$AccountGeneralInfoPayload, S>

  type AccountGeneralInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountGeneralInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountGeneralInfoCountAggregateInputType | true
    }

  export interface AccountGeneralInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountGeneralInfo'], meta: { name: 'AccountGeneralInfo' } }
    /**
     * Find zero or one AccountGeneralInfo that matches the filter.
     * @param {AccountGeneralInfoFindUniqueArgs} args - Arguments to find a AccountGeneralInfo
     * @example
     * // Get one AccountGeneralInfo
     * const accountGeneralInfo = await prisma.accountGeneralInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountGeneralInfoFindUniqueArgs>(args: SelectSubset<T, AccountGeneralInfoFindUniqueArgs<ExtArgs>>): Prisma__AccountGeneralInfoClient<$Result.GetResult<Prisma.$AccountGeneralInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccountGeneralInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountGeneralInfoFindUniqueOrThrowArgs} args - Arguments to find a AccountGeneralInfo
     * @example
     * // Get one AccountGeneralInfo
     * const accountGeneralInfo = await prisma.accountGeneralInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountGeneralInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountGeneralInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountGeneralInfoClient<$Result.GetResult<Prisma.$AccountGeneralInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountGeneralInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGeneralInfoFindFirstArgs} args - Arguments to find a AccountGeneralInfo
     * @example
     * // Get one AccountGeneralInfo
     * const accountGeneralInfo = await prisma.accountGeneralInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountGeneralInfoFindFirstArgs>(args?: SelectSubset<T, AccountGeneralInfoFindFirstArgs<ExtArgs>>): Prisma__AccountGeneralInfoClient<$Result.GetResult<Prisma.$AccountGeneralInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountGeneralInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGeneralInfoFindFirstOrThrowArgs} args - Arguments to find a AccountGeneralInfo
     * @example
     * // Get one AccountGeneralInfo
     * const accountGeneralInfo = await prisma.accountGeneralInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountGeneralInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountGeneralInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountGeneralInfoClient<$Result.GetResult<Prisma.$AccountGeneralInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccountGeneralInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGeneralInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountGeneralInfos
     * const accountGeneralInfos = await prisma.accountGeneralInfo.findMany()
     * 
     * // Get first 10 AccountGeneralInfos
     * const accountGeneralInfos = await prisma.accountGeneralInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountGeneralInfoWithIdOnly = await prisma.accountGeneralInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountGeneralInfoFindManyArgs>(args?: SelectSubset<T, AccountGeneralInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountGeneralInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccountGeneralInfo.
     * @param {AccountGeneralInfoCreateArgs} args - Arguments to create a AccountGeneralInfo.
     * @example
     * // Create one AccountGeneralInfo
     * const AccountGeneralInfo = await prisma.accountGeneralInfo.create({
     *   data: {
     *     // ... data to create a AccountGeneralInfo
     *   }
     * })
     * 
     */
    create<T extends AccountGeneralInfoCreateArgs>(args: SelectSubset<T, AccountGeneralInfoCreateArgs<ExtArgs>>): Prisma__AccountGeneralInfoClient<$Result.GetResult<Prisma.$AccountGeneralInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccountGeneralInfos.
     * @param {AccountGeneralInfoCreateManyArgs} args - Arguments to create many AccountGeneralInfos.
     * @example
     * // Create many AccountGeneralInfos
     * const accountGeneralInfo = await prisma.accountGeneralInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountGeneralInfoCreateManyArgs>(args?: SelectSubset<T, AccountGeneralInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AccountGeneralInfo.
     * @param {AccountGeneralInfoDeleteArgs} args - Arguments to delete one AccountGeneralInfo.
     * @example
     * // Delete one AccountGeneralInfo
     * const AccountGeneralInfo = await prisma.accountGeneralInfo.delete({
     *   where: {
     *     // ... filter to delete one AccountGeneralInfo
     *   }
     * })
     * 
     */
    delete<T extends AccountGeneralInfoDeleteArgs>(args: SelectSubset<T, AccountGeneralInfoDeleteArgs<ExtArgs>>): Prisma__AccountGeneralInfoClient<$Result.GetResult<Prisma.$AccountGeneralInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccountGeneralInfo.
     * @param {AccountGeneralInfoUpdateArgs} args - Arguments to update one AccountGeneralInfo.
     * @example
     * // Update one AccountGeneralInfo
     * const accountGeneralInfo = await prisma.accountGeneralInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountGeneralInfoUpdateArgs>(args: SelectSubset<T, AccountGeneralInfoUpdateArgs<ExtArgs>>): Prisma__AccountGeneralInfoClient<$Result.GetResult<Prisma.$AccountGeneralInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccountGeneralInfos.
     * @param {AccountGeneralInfoDeleteManyArgs} args - Arguments to filter AccountGeneralInfos to delete.
     * @example
     * // Delete a few AccountGeneralInfos
     * const { count } = await prisma.accountGeneralInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountGeneralInfoDeleteManyArgs>(args?: SelectSubset<T, AccountGeneralInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountGeneralInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGeneralInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountGeneralInfos
     * const accountGeneralInfo = await prisma.accountGeneralInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountGeneralInfoUpdateManyArgs>(args: SelectSubset<T, AccountGeneralInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountGeneralInfo.
     * @param {AccountGeneralInfoUpsertArgs} args - Arguments to update or create a AccountGeneralInfo.
     * @example
     * // Update or create a AccountGeneralInfo
     * const accountGeneralInfo = await prisma.accountGeneralInfo.upsert({
     *   create: {
     *     // ... data to create a AccountGeneralInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountGeneralInfo we want to update
     *   }
     * })
     */
    upsert<T extends AccountGeneralInfoUpsertArgs>(args: SelectSubset<T, AccountGeneralInfoUpsertArgs<ExtArgs>>): Prisma__AccountGeneralInfoClient<$Result.GetResult<Prisma.$AccountGeneralInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccountGeneralInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGeneralInfoCountArgs} args - Arguments to filter AccountGeneralInfos to count.
     * @example
     * // Count the number of AccountGeneralInfos
     * const count = await prisma.accountGeneralInfo.count({
     *   where: {
     *     // ... the filter for the AccountGeneralInfos we want to count
     *   }
     * })
    **/
    count<T extends AccountGeneralInfoCountArgs>(
      args?: Subset<T, AccountGeneralInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountGeneralInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountGeneralInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGeneralInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountGeneralInfoAggregateArgs>(args: Subset<T, AccountGeneralInfoAggregateArgs>): Prisma.PrismaPromise<GetAccountGeneralInfoAggregateType<T>>

    /**
     * Group by AccountGeneralInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGeneralInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGeneralInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGeneralInfoGroupByArgs['orderBy'] }
        : { orderBy?: AccountGeneralInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGeneralInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGeneralInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountGeneralInfo model
   */
  readonly fields: AccountGeneralInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountGeneralInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountGeneralInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountGeneralInfo model
   */
  interface AccountGeneralInfoFieldRefs {
    readonly id: FieldRef<"AccountGeneralInfo", 'String'>
    readonly account_id: FieldRef<"AccountGeneralInfo", 'String'>
    readonly type: FieldRef<"AccountGeneralInfo", 'AccountType'>
    readonly status: FieldRef<"AccountGeneralInfo", 'AccountStatus'>
    readonly dba_name: FieldRef<"AccountGeneralInfo", 'String'>
    readonly entity_type: FieldRef<"AccountGeneralInfo", 'EntityType'>
    readonly ein: FieldRef<"AccountGeneralInfo", 'String'>
    readonly duns_number: FieldRef<"AccountGeneralInfo", 'String'>
    readonly incorporation_date: FieldRef<"AccountGeneralInfo", 'DateTime'>
    readonly incorporation_state: FieldRef<"AccountGeneralInfo", 'String'>
    readonly industry: FieldRef<"AccountGeneralInfo", 'String'>
    readonly currency: FieldRef<"AccountGeneralInfo", 'String'>
    readonly payment_terms: FieldRef<"AccountGeneralInfo", 'String'>
    readonly created_at: FieldRef<"AccountGeneralInfo", 'DateTime'>
    readonly updated_at: FieldRef<"AccountGeneralInfo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccountGeneralInfo findUnique
   */
  export type AccountGeneralInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountGeneralInfo
     */
    select?: AccountGeneralInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountGeneralInfo
     */
    omit?: AccountGeneralInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountGeneralInfoInclude<ExtArgs> | null
    /**
     * Filter, which AccountGeneralInfo to fetch.
     */
    where: AccountGeneralInfoWhereUniqueInput
  }

  /**
   * AccountGeneralInfo findUniqueOrThrow
   */
  export type AccountGeneralInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountGeneralInfo
     */
    select?: AccountGeneralInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountGeneralInfo
     */
    omit?: AccountGeneralInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountGeneralInfoInclude<ExtArgs> | null
    /**
     * Filter, which AccountGeneralInfo to fetch.
     */
    where: AccountGeneralInfoWhereUniqueInput
  }

  /**
   * AccountGeneralInfo findFirst
   */
  export type AccountGeneralInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountGeneralInfo
     */
    select?: AccountGeneralInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountGeneralInfo
     */
    omit?: AccountGeneralInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountGeneralInfoInclude<ExtArgs> | null
    /**
     * Filter, which AccountGeneralInfo to fetch.
     */
    where?: AccountGeneralInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountGeneralInfos to fetch.
     */
    orderBy?: AccountGeneralInfoOrderByWithRelationInput | AccountGeneralInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountGeneralInfos.
     */
    cursor?: AccountGeneralInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountGeneralInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountGeneralInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountGeneralInfos.
     */
    distinct?: AccountGeneralInfoScalarFieldEnum | AccountGeneralInfoScalarFieldEnum[]
  }

  /**
   * AccountGeneralInfo findFirstOrThrow
   */
  export type AccountGeneralInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountGeneralInfo
     */
    select?: AccountGeneralInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountGeneralInfo
     */
    omit?: AccountGeneralInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountGeneralInfoInclude<ExtArgs> | null
    /**
     * Filter, which AccountGeneralInfo to fetch.
     */
    where?: AccountGeneralInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountGeneralInfos to fetch.
     */
    orderBy?: AccountGeneralInfoOrderByWithRelationInput | AccountGeneralInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountGeneralInfos.
     */
    cursor?: AccountGeneralInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountGeneralInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountGeneralInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountGeneralInfos.
     */
    distinct?: AccountGeneralInfoScalarFieldEnum | AccountGeneralInfoScalarFieldEnum[]
  }

  /**
   * AccountGeneralInfo findMany
   */
  export type AccountGeneralInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountGeneralInfo
     */
    select?: AccountGeneralInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountGeneralInfo
     */
    omit?: AccountGeneralInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountGeneralInfoInclude<ExtArgs> | null
    /**
     * Filter, which AccountGeneralInfos to fetch.
     */
    where?: AccountGeneralInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountGeneralInfos to fetch.
     */
    orderBy?: AccountGeneralInfoOrderByWithRelationInput | AccountGeneralInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountGeneralInfos.
     */
    cursor?: AccountGeneralInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountGeneralInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountGeneralInfos.
     */
    skip?: number
    distinct?: AccountGeneralInfoScalarFieldEnum | AccountGeneralInfoScalarFieldEnum[]
  }

  /**
   * AccountGeneralInfo create
   */
  export type AccountGeneralInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountGeneralInfo
     */
    select?: AccountGeneralInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountGeneralInfo
     */
    omit?: AccountGeneralInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountGeneralInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountGeneralInfo.
     */
    data: XOR<AccountGeneralInfoCreateInput, AccountGeneralInfoUncheckedCreateInput>
  }

  /**
   * AccountGeneralInfo createMany
   */
  export type AccountGeneralInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountGeneralInfos.
     */
    data: AccountGeneralInfoCreateManyInput | AccountGeneralInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountGeneralInfo update
   */
  export type AccountGeneralInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountGeneralInfo
     */
    select?: AccountGeneralInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountGeneralInfo
     */
    omit?: AccountGeneralInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountGeneralInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountGeneralInfo.
     */
    data: XOR<AccountGeneralInfoUpdateInput, AccountGeneralInfoUncheckedUpdateInput>
    /**
     * Choose, which AccountGeneralInfo to update.
     */
    where: AccountGeneralInfoWhereUniqueInput
  }

  /**
   * AccountGeneralInfo updateMany
   */
  export type AccountGeneralInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountGeneralInfos.
     */
    data: XOR<AccountGeneralInfoUpdateManyMutationInput, AccountGeneralInfoUncheckedUpdateManyInput>
    /**
     * Filter which AccountGeneralInfos to update
     */
    where?: AccountGeneralInfoWhereInput
    /**
     * Limit how many AccountGeneralInfos to update.
     */
    limit?: number
  }

  /**
   * AccountGeneralInfo upsert
   */
  export type AccountGeneralInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountGeneralInfo
     */
    select?: AccountGeneralInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountGeneralInfo
     */
    omit?: AccountGeneralInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountGeneralInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountGeneralInfo to update in case it exists.
     */
    where: AccountGeneralInfoWhereUniqueInput
    /**
     * In case the AccountGeneralInfo found by the `where` argument doesn't exist, create a new AccountGeneralInfo with this data.
     */
    create: XOR<AccountGeneralInfoCreateInput, AccountGeneralInfoUncheckedCreateInput>
    /**
     * In case the AccountGeneralInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountGeneralInfoUpdateInput, AccountGeneralInfoUncheckedUpdateInput>
  }

  /**
   * AccountGeneralInfo delete
   */
  export type AccountGeneralInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountGeneralInfo
     */
    select?: AccountGeneralInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountGeneralInfo
     */
    omit?: AccountGeneralInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountGeneralInfoInclude<ExtArgs> | null
    /**
     * Filter which AccountGeneralInfo to delete.
     */
    where: AccountGeneralInfoWhereUniqueInput
  }

  /**
   * AccountGeneralInfo deleteMany
   */
  export type AccountGeneralInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountGeneralInfos to delete
     */
    where?: AccountGeneralInfoWhereInput
    /**
     * Limit how many AccountGeneralInfos to delete.
     */
    limit?: number
  }

  /**
   * AccountGeneralInfo without action
   */
  export type AccountGeneralInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountGeneralInfo
     */
    select?: AccountGeneralInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountGeneralInfo
     */
    omit?: AccountGeneralInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountGeneralInfoInclude<ExtArgs> | null
  }


  /**
   * Model AccountContactInfo
   */

  export type AggregateAccountContactInfo = {
    _count: AccountContactInfoCountAggregateOutputType | null
    _min: AccountContactInfoMinAggregateOutputType | null
    _max: AccountContactInfoMaxAggregateOutputType | null
  }

  export type AccountContactInfoMinAggregateOutputType = {
    id: string | null
    account_id: string | null
    address_street: string | null
    address_suite: string | null
    address_city: string | null
    address_state: string | null
    address_zip: string | null
    address_country: string | null
    phone: string | null
    fax: string | null
    email: string | null
    website: string | null
    mailing_address_street: string | null
    mailing_address_suite: string | null
    mailing_address_city: string | null
    mailing_address_state: string | null
    mailing_address_zip: string | null
    mailing_address_country: string | null
    contact_name: string | null
    contact_title: string | null
    contact_phone: string | null
    contact_email: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AccountContactInfoMaxAggregateOutputType = {
    id: string | null
    account_id: string | null
    address_street: string | null
    address_suite: string | null
    address_city: string | null
    address_state: string | null
    address_zip: string | null
    address_country: string | null
    phone: string | null
    fax: string | null
    email: string | null
    website: string | null
    mailing_address_street: string | null
    mailing_address_suite: string | null
    mailing_address_city: string | null
    mailing_address_state: string | null
    mailing_address_zip: string | null
    mailing_address_country: string | null
    contact_name: string | null
    contact_title: string | null
    contact_phone: string | null
    contact_email: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AccountContactInfoCountAggregateOutputType = {
    id: number
    account_id: number
    address_street: number
    address_suite: number
    address_city: number
    address_state: number
    address_zip: number
    address_country: number
    phone: number
    fax: number
    email: number
    website: number
    mailing_address_street: number
    mailing_address_suite: number
    mailing_address_city: number
    mailing_address_state: number
    mailing_address_zip: number
    mailing_address_country: number
    contact_name: number
    contact_title: number
    contact_phone: number
    contact_email: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AccountContactInfoMinAggregateInputType = {
    id?: true
    account_id?: true
    address_street?: true
    address_suite?: true
    address_city?: true
    address_state?: true
    address_zip?: true
    address_country?: true
    phone?: true
    fax?: true
    email?: true
    website?: true
    mailing_address_street?: true
    mailing_address_suite?: true
    mailing_address_city?: true
    mailing_address_state?: true
    mailing_address_zip?: true
    mailing_address_country?: true
    contact_name?: true
    contact_title?: true
    contact_phone?: true
    contact_email?: true
    created_at?: true
    updated_at?: true
  }

  export type AccountContactInfoMaxAggregateInputType = {
    id?: true
    account_id?: true
    address_street?: true
    address_suite?: true
    address_city?: true
    address_state?: true
    address_zip?: true
    address_country?: true
    phone?: true
    fax?: true
    email?: true
    website?: true
    mailing_address_street?: true
    mailing_address_suite?: true
    mailing_address_city?: true
    mailing_address_state?: true
    mailing_address_zip?: true
    mailing_address_country?: true
    contact_name?: true
    contact_title?: true
    contact_phone?: true
    contact_email?: true
    created_at?: true
    updated_at?: true
  }

  export type AccountContactInfoCountAggregateInputType = {
    id?: true
    account_id?: true
    address_street?: true
    address_suite?: true
    address_city?: true
    address_state?: true
    address_zip?: true
    address_country?: true
    phone?: true
    fax?: true
    email?: true
    website?: true
    mailing_address_street?: true
    mailing_address_suite?: true
    mailing_address_city?: true
    mailing_address_state?: true
    mailing_address_zip?: true
    mailing_address_country?: true
    contact_name?: true
    contact_title?: true
    contact_phone?: true
    contact_email?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AccountContactInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountContactInfo to aggregate.
     */
    where?: AccountContactInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountContactInfos to fetch.
     */
    orderBy?: AccountContactInfoOrderByWithRelationInput | AccountContactInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountContactInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountContactInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountContactInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountContactInfos
    **/
    _count?: true | AccountContactInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountContactInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountContactInfoMaxAggregateInputType
  }

  export type GetAccountContactInfoAggregateType<T extends AccountContactInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountContactInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountContactInfo[P]>
      : GetScalarType<T[P], AggregateAccountContactInfo[P]>
  }




  export type AccountContactInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountContactInfoWhereInput
    orderBy?: AccountContactInfoOrderByWithAggregationInput | AccountContactInfoOrderByWithAggregationInput[]
    by: AccountContactInfoScalarFieldEnum[] | AccountContactInfoScalarFieldEnum
    having?: AccountContactInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountContactInfoCountAggregateInputType | true
    _min?: AccountContactInfoMinAggregateInputType
    _max?: AccountContactInfoMaxAggregateInputType
  }

  export type AccountContactInfoGroupByOutputType = {
    id: string
    account_id: string
    address_street: string | null
    address_suite: string | null
    address_city: string | null
    address_state: string | null
    address_zip: string | null
    address_country: string | null
    phone: string | null
    fax: string | null
    email: string | null
    website: string | null
    mailing_address_street: string | null
    mailing_address_suite: string | null
    mailing_address_city: string | null
    mailing_address_state: string | null
    mailing_address_zip: string | null
    mailing_address_country: string | null
    contact_name: string | null
    contact_title: string | null
    contact_phone: string | null
    contact_email: string | null
    created_at: Date
    updated_at: Date
    _count: AccountContactInfoCountAggregateOutputType | null
    _min: AccountContactInfoMinAggregateOutputType | null
    _max: AccountContactInfoMaxAggregateOutputType | null
  }

  type GetAccountContactInfoGroupByPayload<T extends AccountContactInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountContactInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountContactInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountContactInfoGroupByOutputType[P]>
            : GetScalarType<T[P], AccountContactInfoGroupByOutputType[P]>
        }
      >
    >


  export type AccountContactInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    address_street?: boolean
    address_suite?: boolean
    address_city?: boolean
    address_state?: boolean
    address_zip?: boolean
    address_country?: boolean
    phone?: boolean
    fax?: boolean
    email?: boolean
    website?: boolean
    mailing_address_street?: boolean
    mailing_address_suite?: boolean
    mailing_address_city?: boolean
    mailing_address_state?: boolean
    mailing_address_zip?: boolean
    mailing_address_country?: boolean
    contact_name?: boolean
    contact_title?: boolean
    contact_phone?: boolean
    contact_email?: boolean
    created_at?: boolean
    updated_at?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountContactInfo"]>



  export type AccountContactInfoSelectScalar = {
    id?: boolean
    account_id?: boolean
    address_street?: boolean
    address_suite?: boolean
    address_city?: boolean
    address_state?: boolean
    address_zip?: boolean
    address_country?: boolean
    phone?: boolean
    fax?: boolean
    email?: boolean
    website?: boolean
    mailing_address_street?: boolean
    mailing_address_suite?: boolean
    mailing_address_city?: boolean
    mailing_address_state?: boolean
    mailing_address_zip?: boolean
    mailing_address_country?: boolean
    contact_name?: boolean
    contact_title?: boolean
    contact_phone?: boolean
    contact_email?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AccountContactInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "account_id" | "address_street" | "address_suite" | "address_city" | "address_state" | "address_zip" | "address_country" | "phone" | "fax" | "email" | "website" | "mailing_address_street" | "mailing_address_suite" | "mailing_address_city" | "mailing_address_state" | "mailing_address_zip" | "mailing_address_country" | "contact_name" | "contact_title" | "contact_phone" | "contact_email" | "created_at" | "updated_at", ExtArgs["result"]["accountContactInfo"]>
  export type AccountContactInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $AccountContactInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountContactInfo"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      account_id: string
      address_street: string | null
      address_suite: string | null
      address_city: string | null
      address_state: string | null
      address_zip: string | null
      address_country: string | null
      phone: string | null
      fax: string | null
      email: string | null
      website: string | null
      mailing_address_street: string | null
      mailing_address_suite: string | null
      mailing_address_city: string | null
      mailing_address_state: string | null
      mailing_address_zip: string | null
      mailing_address_country: string | null
      contact_name: string | null
      contact_title: string | null
      contact_phone: string | null
      contact_email: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["accountContactInfo"]>
    composites: {}
  }

  type AccountContactInfoGetPayload<S extends boolean | null | undefined | AccountContactInfoDefaultArgs> = $Result.GetResult<Prisma.$AccountContactInfoPayload, S>

  type AccountContactInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountContactInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountContactInfoCountAggregateInputType | true
    }

  export interface AccountContactInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountContactInfo'], meta: { name: 'AccountContactInfo' } }
    /**
     * Find zero or one AccountContactInfo that matches the filter.
     * @param {AccountContactInfoFindUniqueArgs} args - Arguments to find a AccountContactInfo
     * @example
     * // Get one AccountContactInfo
     * const accountContactInfo = await prisma.accountContactInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountContactInfoFindUniqueArgs>(args: SelectSubset<T, AccountContactInfoFindUniqueArgs<ExtArgs>>): Prisma__AccountContactInfoClient<$Result.GetResult<Prisma.$AccountContactInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccountContactInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountContactInfoFindUniqueOrThrowArgs} args - Arguments to find a AccountContactInfo
     * @example
     * // Get one AccountContactInfo
     * const accountContactInfo = await prisma.accountContactInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountContactInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountContactInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountContactInfoClient<$Result.GetResult<Prisma.$AccountContactInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountContactInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountContactInfoFindFirstArgs} args - Arguments to find a AccountContactInfo
     * @example
     * // Get one AccountContactInfo
     * const accountContactInfo = await prisma.accountContactInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountContactInfoFindFirstArgs>(args?: SelectSubset<T, AccountContactInfoFindFirstArgs<ExtArgs>>): Prisma__AccountContactInfoClient<$Result.GetResult<Prisma.$AccountContactInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountContactInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountContactInfoFindFirstOrThrowArgs} args - Arguments to find a AccountContactInfo
     * @example
     * // Get one AccountContactInfo
     * const accountContactInfo = await prisma.accountContactInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountContactInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountContactInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountContactInfoClient<$Result.GetResult<Prisma.$AccountContactInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccountContactInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountContactInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountContactInfos
     * const accountContactInfos = await prisma.accountContactInfo.findMany()
     * 
     * // Get first 10 AccountContactInfos
     * const accountContactInfos = await prisma.accountContactInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountContactInfoWithIdOnly = await prisma.accountContactInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountContactInfoFindManyArgs>(args?: SelectSubset<T, AccountContactInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountContactInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccountContactInfo.
     * @param {AccountContactInfoCreateArgs} args - Arguments to create a AccountContactInfo.
     * @example
     * // Create one AccountContactInfo
     * const AccountContactInfo = await prisma.accountContactInfo.create({
     *   data: {
     *     // ... data to create a AccountContactInfo
     *   }
     * })
     * 
     */
    create<T extends AccountContactInfoCreateArgs>(args: SelectSubset<T, AccountContactInfoCreateArgs<ExtArgs>>): Prisma__AccountContactInfoClient<$Result.GetResult<Prisma.$AccountContactInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccountContactInfos.
     * @param {AccountContactInfoCreateManyArgs} args - Arguments to create many AccountContactInfos.
     * @example
     * // Create many AccountContactInfos
     * const accountContactInfo = await prisma.accountContactInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountContactInfoCreateManyArgs>(args?: SelectSubset<T, AccountContactInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AccountContactInfo.
     * @param {AccountContactInfoDeleteArgs} args - Arguments to delete one AccountContactInfo.
     * @example
     * // Delete one AccountContactInfo
     * const AccountContactInfo = await prisma.accountContactInfo.delete({
     *   where: {
     *     // ... filter to delete one AccountContactInfo
     *   }
     * })
     * 
     */
    delete<T extends AccountContactInfoDeleteArgs>(args: SelectSubset<T, AccountContactInfoDeleteArgs<ExtArgs>>): Prisma__AccountContactInfoClient<$Result.GetResult<Prisma.$AccountContactInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccountContactInfo.
     * @param {AccountContactInfoUpdateArgs} args - Arguments to update one AccountContactInfo.
     * @example
     * // Update one AccountContactInfo
     * const accountContactInfo = await prisma.accountContactInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountContactInfoUpdateArgs>(args: SelectSubset<T, AccountContactInfoUpdateArgs<ExtArgs>>): Prisma__AccountContactInfoClient<$Result.GetResult<Prisma.$AccountContactInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccountContactInfos.
     * @param {AccountContactInfoDeleteManyArgs} args - Arguments to filter AccountContactInfos to delete.
     * @example
     * // Delete a few AccountContactInfos
     * const { count } = await prisma.accountContactInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountContactInfoDeleteManyArgs>(args?: SelectSubset<T, AccountContactInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountContactInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountContactInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountContactInfos
     * const accountContactInfo = await prisma.accountContactInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountContactInfoUpdateManyArgs>(args: SelectSubset<T, AccountContactInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountContactInfo.
     * @param {AccountContactInfoUpsertArgs} args - Arguments to update or create a AccountContactInfo.
     * @example
     * // Update or create a AccountContactInfo
     * const accountContactInfo = await prisma.accountContactInfo.upsert({
     *   create: {
     *     // ... data to create a AccountContactInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountContactInfo we want to update
     *   }
     * })
     */
    upsert<T extends AccountContactInfoUpsertArgs>(args: SelectSubset<T, AccountContactInfoUpsertArgs<ExtArgs>>): Prisma__AccountContactInfoClient<$Result.GetResult<Prisma.$AccountContactInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccountContactInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountContactInfoCountArgs} args - Arguments to filter AccountContactInfos to count.
     * @example
     * // Count the number of AccountContactInfos
     * const count = await prisma.accountContactInfo.count({
     *   where: {
     *     // ... the filter for the AccountContactInfos we want to count
     *   }
     * })
    **/
    count<T extends AccountContactInfoCountArgs>(
      args?: Subset<T, AccountContactInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountContactInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountContactInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountContactInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountContactInfoAggregateArgs>(args: Subset<T, AccountContactInfoAggregateArgs>): Prisma.PrismaPromise<GetAccountContactInfoAggregateType<T>>

    /**
     * Group by AccountContactInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountContactInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountContactInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountContactInfoGroupByArgs['orderBy'] }
        : { orderBy?: AccountContactInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountContactInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountContactInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountContactInfo model
   */
  readonly fields: AccountContactInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountContactInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountContactInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountContactInfo model
   */
  interface AccountContactInfoFieldRefs {
    readonly id: FieldRef<"AccountContactInfo", 'String'>
    readonly account_id: FieldRef<"AccountContactInfo", 'String'>
    readonly address_street: FieldRef<"AccountContactInfo", 'String'>
    readonly address_suite: FieldRef<"AccountContactInfo", 'String'>
    readonly address_city: FieldRef<"AccountContactInfo", 'String'>
    readonly address_state: FieldRef<"AccountContactInfo", 'String'>
    readonly address_zip: FieldRef<"AccountContactInfo", 'String'>
    readonly address_country: FieldRef<"AccountContactInfo", 'String'>
    readonly phone: FieldRef<"AccountContactInfo", 'String'>
    readonly fax: FieldRef<"AccountContactInfo", 'String'>
    readonly email: FieldRef<"AccountContactInfo", 'String'>
    readonly website: FieldRef<"AccountContactInfo", 'String'>
    readonly mailing_address_street: FieldRef<"AccountContactInfo", 'String'>
    readonly mailing_address_suite: FieldRef<"AccountContactInfo", 'String'>
    readonly mailing_address_city: FieldRef<"AccountContactInfo", 'String'>
    readonly mailing_address_state: FieldRef<"AccountContactInfo", 'String'>
    readonly mailing_address_zip: FieldRef<"AccountContactInfo", 'String'>
    readonly mailing_address_country: FieldRef<"AccountContactInfo", 'String'>
    readonly contact_name: FieldRef<"AccountContactInfo", 'String'>
    readonly contact_title: FieldRef<"AccountContactInfo", 'String'>
    readonly contact_phone: FieldRef<"AccountContactInfo", 'String'>
    readonly contact_email: FieldRef<"AccountContactInfo", 'String'>
    readonly created_at: FieldRef<"AccountContactInfo", 'DateTime'>
    readonly updated_at: FieldRef<"AccountContactInfo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccountContactInfo findUnique
   */
  export type AccountContactInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountContactInfo
     */
    select?: AccountContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountContactInfo
     */
    omit?: AccountContactInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountContactInfoInclude<ExtArgs> | null
    /**
     * Filter, which AccountContactInfo to fetch.
     */
    where: AccountContactInfoWhereUniqueInput
  }

  /**
   * AccountContactInfo findUniqueOrThrow
   */
  export type AccountContactInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountContactInfo
     */
    select?: AccountContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountContactInfo
     */
    omit?: AccountContactInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountContactInfoInclude<ExtArgs> | null
    /**
     * Filter, which AccountContactInfo to fetch.
     */
    where: AccountContactInfoWhereUniqueInput
  }

  /**
   * AccountContactInfo findFirst
   */
  export type AccountContactInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountContactInfo
     */
    select?: AccountContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountContactInfo
     */
    omit?: AccountContactInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountContactInfoInclude<ExtArgs> | null
    /**
     * Filter, which AccountContactInfo to fetch.
     */
    where?: AccountContactInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountContactInfos to fetch.
     */
    orderBy?: AccountContactInfoOrderByWithRelationInput | AccountContactInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountContactInfos.
     */
    cursor?: AccountContactInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountContactInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountContactInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountContactInfos.
     */
    distinct?: AccountContactInfoScalarFieldEnum | AccountContactInfoScalarFieldEnum[]
  }

  /**
   * AccountContactInfo findFirstOrThrow
   */
  export type AccountContactInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountContactInfo
     */
    select?: AccountContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountContactInfo
     */
    omit?: AccountContactInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountContactInfoInclude<ExtArgs> | null
    /**
     * Filter, which AccountContactInfo to fetch.
     */
    where?: AccountContactInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountContactInfos to fetch.
     */
    orderBy?: AccountContactInfoOrderByWithRelationInput | AccountContactInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountContactInfos.
     */
    cursor?: AccountContactInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountContactInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountContactInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountContactInfos.
     */
    distinct?: AccountContactInfoScalarFieldEnum | AccountContactInfoScalarFieldEnum[]
  }

  /**
   * AccountContactInfo findMany
   */
  export type AccountContactInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountContactInfo
     */
    select?: AccountContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountContactInfo
     */
    omit?: AccountContactInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountContactInfoInclude<ExtArgs> | null
    /**
     * Filter, which AccountContactInfos to fetch.
     */
    where?: AccountContactInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountContactInfos to fetch.
     */
    orderBy?: AccountContactInfoOrderByWithRelationInput | AccountContactInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountContactInfos.
     */
    cursor?: AccountContactInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountContactInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountContactInfos.
     */
    skip?: number
    distinct?: AccountContactInfoScalarFieldEnum | AccountContactInfoScalarFieldEnum[]
  }

  /**
   * AccountContactInfo create
   */
  export type AccountContactInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountContactInfo
     */
    select?: AccountContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountContactInfo
     */
    omit?: AccountContactInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountContactInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountContactInfo.
     */
    data: XOR<AccountContactInfoCreateInput, AccountContactInfoUncheckedCreateInput>
  }

  /**
   * AccountContactInfo createMany
   */
  export type AccountContactInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountContactInfos.
     */
    data: AccountContactInfoCreateManyInput | AccountContactInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountContactInfo update
   */
  export type AccountContactInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountContactInfo
     */
    select?: AccountContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountContactInfo
     */
    omit?: AccountContactInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountContactInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountContactInfo.
     */
    data: XOR<AccountContactInfoUpdateInput, AccountContactInfoUncheckedUpdateInput>
    /**
     * Choose, which AccountContactInfo to update.
     */
    where: AccountContactInfoWhereUniqueInput
  }

  /**
   * AccountContactInfo updateMany
   */
  export type AccountContactInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountContactInfos.
     */
    data: XOR<AccountContactInfoUpdateManyMutationInput, AccountContactInfoUncheckedUpdateManyInput>
    /**
     * Filter which AccountContactInfos to update
     */
    where?: AccountContactInfoWhereInput
    /**
     * Limit how many AccountContactInfos to update.
     */
    limit?: number
  }

  /**
   * AccountContactInfo upsert
   */
  export type AccountContactInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountContactInfo
     */
    select?: AccountContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountContactInfo
     */
    omit?: AccountContactInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountContactInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountContactInfo to update in case it exists.
     */
    where: AccountContactInfoWhereUniqueInput
    /**
     * In case the AccountContactInfo found by the `where` argument doesn't exist, create a new AccountContactInfo with this data.
     */
    create: XOR<AccountContactInfoCreateInput, AccountContactInfoUncheckedCreateInput>
    /**
     * In case the AccountContactInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountContactInfoUpdateInput, AccountContactInfoUncheckedUpdateInput>
  }

  /**
   * AccountContactInfo delete
   */
  export type AccountContactInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountContactInfo
     */
    select?: AccountContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountContactInfo
     */
    omit?: AccountContactInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountContactInfoInclude<ExtArgs> | null
    /**
     * Filter which AccountContactInfo to delete.
     */
    where: AccountContactInfoWhereUniqueInput
  }

  /**
   * AccountContactInfo deleteMany
   */
  export type AccountContactInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountContactInfos to delete
     */
    where?: AccountContactInfoWhereInput
    /**
     * Limit how many AccountContactInfos to delete.
     */
    limit?: number
  }

  /**
   * AccountContactInfo without action
   */
  export type AccountContactInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountContactInfo
     */
    select?: AccountContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountContactInfo
     */
    omit?: AccountContactInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountContactInfoInclude<ExtArgs> | null
  }


  /**
   * Model AccountCompliance
   */

  export type AggregateAccountCompliance = {
    _count: AccountComplianceCountAggregateOutputType | null
    _min: AccountComplianceMinAggregateOutputType | null
    _max: AccountComplianceMaxAggregateOutputType | null
  }

  export type AccountComplianceMinAggregateOutputType = {
    id: string | null
    account_id: string | null
    license_numbers: string | null
    insurance_info: string | null
    invoice_prefix: string | null
    logo_url: string | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AccountComplianceMaxAggregateOutputType = {
    id: string | null
    account_id: string | null
    license_numbers: string | null
    insurance_info: string | null
    invoice_prefix: string | null
    logo_url: string | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AccountComplianceCountAggregateOutputType = {
    id: number
    account_id: number
    license_numbers: number
    insurance_info: number
    invoice_prefix: number
    logo_url: number
    notes: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AccountComplianceMinAggregateInputType = {
    id?: true
    account_id?: true
    license_numbers?: true
    insurance_info?: true
    invoice_prefix?: true
    logo_url?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type AccountComplianceMaxAggregateInputType = {
    id?: true
    account_id?: true
    license_numbers?: true
    insurance_info?: true
    invoice_prefix?: true
    logo_url?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type AccountComplianceCountAggregateInputType = {
    id?: true
    account_id?: true
    license_numbers?: true
    insurance_info?: true
    invoice_prefix?: true
    logo_url?: true
    notes?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AccountComplianceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountCompliance to aggregate.
     */
    where?: AccountComplianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountCompliances to fetch.
     */
    orderBy?: AccountComplianceOrderByWithRelationInput | AccountComplianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountComplianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountCompliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountCompliances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountCompliances
    **/
    _count?: true | AccountComplianceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountComplianceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountComplianceMaxAggregateInputType
  }

  export type GetAccountComplianceAggregateType<T extends AccountComplianceAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountCompliance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountCompliance[P]>
      : GetScalarType<T[P], AggregateAccountCompliance[P]>
  }




  export type AccountComplianceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountComplianceWhereInput
    orderBy?: AccountComplianceOrderByWithAggregationInput | AccountComplianceOrderByWithAggregationInput[]
    by: AccountComplianceScalarFieldEnum[] | AccountComplianceScalarFieldEnum
    having?: AccountComplianceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountComplianceCountAggregateInputType | true
    _min?: AccountComplianceMinAggregateInputType
    _max?: AccountComplianceMaxAggregateInputType
  }

  export type AccountComplianceGroupByOutputType = {
    id: string
    account_id: string
    license_numbers: string | null
    insurance_info: string | null
    invoice_prefix: string | null
    logo_url: string | null
    notes: string | null
    created_at: Date
    updated_at: Date
    _count: AccountComplianceCountAggregateOutputType | null
    _min: AccountComplianceMinAggregateOutputType | null
    _max: AccountComplianceMaxAggregateOutputType | null
  }

  type GetAccountComplianceGroupByPayload<T extends AccountComplianceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountComplianceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountComplianceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountComplianceGroupByOutputType[P]>
            : GetScalarType<T[P], AccountComplianceGroupByOutputType[P]>
        }
      >
    >


  export type AccountComplianceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    license_numbers?: boolean
    insurance_info?: boolean
    invoice_prefix?: boolean
    logo_url?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountCompliance"]>



  export type AccountComplianceSelectScalar = {
    id?: boolean
    account_id?: boolean
    license_numbers?: boolean
    insurance_info?: boolean
    invoice_prefix?: boolean
    logo_url?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AccountComplianceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "account_id" | "license_numbers" | "insurance_info" | "invoice_prefix" | "logo_url" | "notes" | "created_at" | "updated_at", ExtArgs["result"]["accountCompliance"]>
  export type AccountComplianceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $AccountCompliancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountCompliance"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      account_id: string
      license_numbers: string | null
      insurance_info: string | null
      invoice_prefix: string | null
      logo_url: string | null
      notes: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["accountCompliance"]>
    composites: {}
  }

  type AccountComplianceGetPayload<S extends boolean | null | undefined | AccountComplianceDefaultArgs> = $Result.GetResult<Prisma.$AccountCompliancePayload, S>

  type AccountComplianceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountComplianceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountComplianceCountAggregateInputType | true
    }

  export interface AccountComplianceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountCompliance'], meta: { name: 'AccountCompliance' } }
    /**
     * Find zero or one AccountCompliance that matches the filter.
     * @param {AccountComplianceFindUniqueArgs} args - Arguments to find a AccountCompliance
     * @example
     * // Get one AccountCompliance
     * const accountCompliance = await prisma.accountCompliance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountComplianceFindUniqueArgs>(args: SelectSubset<T, AccountComplianceFindUniqueArgs<ExtArgs>>): Prisma__AccountComplianceClient<$Result.GetResult<Prisma.$AccountCompliancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccountCompliance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountComplianceFindUniqueOrThrowArgs} args - Arguments to find a AccountCompliance
     * @example
     * // Get one AccountCompliance
     * const accountCompliance = await prisma.accountCompliance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountComplianceFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountComplianceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountComplianceClient<$Result.GetResult<Prisma.$AccountCompliancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountCompliance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountComplianceFindFirstArgs} args - Arguments to find a AccountCompliance
     * @example
     * // Get one AccountCompliance
     * const accountCompliance = await prisma.accountCompliance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountComplianceFindFirstArgs>(args?: SelectSubset<T, AccountComplianceFindFirstArgs<ExtArgs>>): Prisma__AccountComplianceClient<$Result.GetResult<Prisma.$AccountCompliancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountCompliance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountComplianceFindFirstOrThrowArgs} args - Arguments to find a AccountCompliance
     * @example
     * // Get one AccountCompliance
     * const accountCompliance = await prisma.accountCompliance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountComplianceFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountComplianceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountComplianceClient<$Result.GetResult<Prisma.$AccountCompliancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccountCompliances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountComplianceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountCompliances
     * const accountCompliances = await prisma.accountCompliance.findMany()
     * 
     * // Get first 10 AccountCompliances
     * const accountCompliances = await prisma.accountCompliance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountComplianceWithIdOnly = await prisma.accountCompliance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountComplianceFindManyArgs>(args?: SelectSubset<T, AccountComplianceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountCompliancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccountCompliance.
     * @param {AccountComplianceCreateArgs} args - Arguments to create a AccountCompliance.
     * @example
     * // Create one AccountCompliance
     * const AccountCompliance = await prisma.accountCompliance.create({
     *   data: {
     *     // ... data to create a AccountCompliance
     *   }
     * })
     * 
     */
    create<T extends AccountComplianceCreateArgs>(args: SelectSubset<T, AccountComplianceCreateArgs<ExtArgs>>): Prisma__AccountComplianceClient<$Result.GetResult<Prisma.$AccountCompliancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccountCompliances.
     * @param {AccountComplianceCreateManyArgs} args - Arguments to create many AccountCompliances.
     * @example
     * // Create many AccountCompliances
     * const accountCompliance = await prisma.accountCompliance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountComplianceCreateManyArgs>(args?: SelectSubset<T, AccountComplianceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AccountCompliance.
     * @param {AccountComplianceDeleteArgs} args - Arguments to delete one AccountCompliance.
     * @example
     * // Delete one AccountCompliance
     * const AccountCompliance = await prisma.accountCompliance.delete({
     *   where: {
     *     // ... filter to delete one AccountCompliance
     *   }
     * })
     * 
     */
    delete<T extends AccountComplianceDeleteArgs>(args: SelectSubset<T, AccountComplianceDeleteArgs<ExtArgs>>): Prisma__AccountComplianceClient<$Result.GetResult<Prisma.$AccountCompliancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccountCompliance.
     * @param {AccountComplianceUpdateArgs} args - Arguments to update one AccountCompliance.
     * @example
     * // Update one AccountCompliance
     * const accountCompliance = await prisma.accountCompliance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountComplianceUpdateArgs>(args: SelectSubset<T, AccountComplianceUpdateArgs<ExtArgs>>): Prisma__AccountComplianceClient<$Result.GetResult<Prisma.$AccountCompliancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccountCompliances.
     * @param {AccountComplianceDeleteManyArgs} args - Arguments to filter AccountCompliances to delete.
     * @example
     * // Delete a few AccountCompliances
     * const { count } = await prisma.accountCompliance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountComplianceDeleteManyArgs>(args?: SelectSubset<T, AccountComplianceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountCompliances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountComplianceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountCompliances
     * const accountCompliance = await prisma.accountCompliance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountComplianceUpdateManyArgs>(args: SelectSubset<T, AccountComplianceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountCompliance.
     * @param {AccountComplianceUpsertArgs} args - Arguments to update or create a AccountCompliance.
     * @example
     * // Update or create a AccountCompliance
     * const accountCompliance = await prisma.accountCompliance.upsert({
     *   create: {
     *     // ... data to create a AccountCompliance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountCompliance we want to update
     *   }
     * })
     */
    upsert<T extends AccountComplianceUpsertArgs>(args: SelectSubset<T, AccountComplianceUpsertArgs<ExtArgs>>): Prisma__AccountComplianceClient<$Result.GetResult<Prisma.$AccountCompliancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccountCompliances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountComplianceCountArgs} args - Arguments to filter AccountCompliances to count.
     * @example
     * // Count the number of AccountCompliances
     * const count = await prisma.accountCompliance.count({
     *   where: {
     *     // ... the filter for the AccountCompliances we want to count
     *   }
     * })
    **/
    count<T extends AccountComplianceCountArgs>(
      args?: Subset<T, AccountComplianceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountComplianceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountCompliance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountComplianceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountComplianceAggregateArgs>(args: Subset<T, AccountComplianceAggregateArgs>): Prisma.PrismaPromise<GetAccountComplianceAggregateType<T>>

    /**
     * Group by AccountCompliance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountComplianceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountComplianceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountComplianceGroupByArgs['orderBy'] }
        : { orderBy?: AccountComplianceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountComplianceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountComplianceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountCompliance model
   */
  readonly fields: AccountComplianceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountCompliance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountComplianceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountCompliance model
   */
  interface AccountComplianceFieldRefs {
    readonly id: FieldRef<"AccountCompliance", 'String'>
    readonly account_id: FieldRef<"AccountCompliance", 'String'>
    readonly license_numbers: FieldRef<"AccountCompliance", 'String'>
    readonly insurance_info: FieldRef<"AccountCompliance", 'String'>
    readonly invoice_prefix: FieldRef<"AccountCompliance", 'String'>
    readonly logo_url: FieldRef<"AccountCompliance", 'String'>
    readonly notes: FieldRef<"AccountCompliance", 'String'>
    readonly created_at: FieldRef<"AccountCompliance", 'DateTime'>
    readonly updated_at: FieldRef<"AccountCompliance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccountCompliance findUnique
   */
  export type AccountComplianceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCompliance
     */
    select?: AccountComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountCompliance
     */
    omit?: AccountComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountComplianceInclude<ExtArgs> | null
    /**
     * Filter, which AccountCompliance to fetch.
     */
    where: AccountComplianceWhereUniqueInput
  }

  /**
   * AccountCompliance findUniqueOrThrow
   */
  export type AccountComplianceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCompliance
     */
    select?: AccountComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountCompliance
     */
    omit?: AccountComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountComplianceInclude<ExtArgs> | null
    /**
     * Filter, which AccountCompliance to fetch.
     */
    where: AccountComplianceWhereUniqueInput
  }

  /**
   * AccountCompliance findFirst
   */
  export type AccountComplianceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCompliance
     */
    select?: AccountComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountCompliance
     */
    omit?: AccountComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountComplianceInclude<ExtArgs> | null
    /**
     * Filter, which AccountCompliance to fetch.
     */
    where?: AccountComplianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountCompliances to fetch.
     */
    orderBy?: AccountComplianceOrderByWithRelationInput | AccountComplianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountCompliances.
     */
    cursor?: AccountComplianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountCompliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountCompliances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountCompliances.
     */
    distinct?: AccountComplianceScalarFieldEnum | AccountComplianceScalarFieldEnum[]
  }

  /**
   * AccountCompliance findFirstOrThrow
   */
  export type AccountComplianceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCompliance
     */
    select?: AccountComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountCompliance
     */
    omit?: AccountComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountComplianceInclude<ExtArgs> | null
    /**
     * Filter, which AccountCompliance to fetch.
     */
    where?: AccountComplianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountCompliances to fetch.
     */
    orderBy?: AccountComplianceOrderByWithRelationInput | AccountComplianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountCompliances.
     */
    cursor?: AccountComplianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountCompliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountCompliances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountCompliances.
     */
    distinct?: AccountComplianceScalarFieldEnum | AccountComplianceScalarFieldEnum[]
  }

  /**
   * AccountCompliance findMany
   */
  export type AccountComplianceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCompliance
     */
    select?: AccountComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountCompliance
     */
    omit?: AccountComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountComplianceInclude<ExtArgs> | null
    /**
     * Filter, which AccountCompliances to fetch.
     */
    where?: AccountComplianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountCompliances to fetch.
     */
    orderBy?: AccountComplianceOrderByWithRelationInput | AccountComplianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountCompliances.
     */
    cursor?: AccountComplianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountCompliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountCompliances.
     */
    skip?: number
    distinct?: AccountComplianceScalarFieldEnum | AccountComplianceScalarFieldEnum[]
  }

  /**
   * AccountCompliance create
   */
  export type AccountComplianceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCompliance
     */
    select?: AccountComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountCompliance
     */
    omit?: AccountComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountComplianceInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountCompliance.
     */
    data: XOR<AccountComplianceCreateInput, AccountComplianceUncheckedCreateInput>
  }

  /**
   * AccountCompliance createMany
   */
  export type AccountComplianceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountCompliances.
     */
    data: AccountComplianceCreateManyInput | AccountComplianceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountCompliance update
   */
  export type AccountComplianceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCompliance
     */
    select?: AccountComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountCompliance
     */
    omit?: AccountComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountComplianceInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountCompliance.
     */
    data: XOR<AccountComplianceUpdateInput, AccountComplianceUncheckedUpdateInput>
    /**
     * Choose, which AccountCompliance to update.
     */
    where: AccountComplianceWhereUniqueInput
  }

  /**
   * AccountCompliance updateMany
   */
  export type AccountComplianceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountCompliances.
     */
    data: XOR<AccountComplianceUpdateManyMutationInput, AccountComplianceUncheckedUpdateManyInput>
    /**
     * Filter which AccountCompliances to update
     */
    where?: AccountComplianceWhereInput
    /**
     * Limit how many AccountCompliances to update.
     */
    limit?: number
  }

  /**
   * AccountCompliance upsert
   */
  export type AccountComplianceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCompliance
     */
    select?: AccountComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountCompliance
     */
    omit?: AccountComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountComplianceInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountCompliance to update in case it exists.
     */
    where: AccountComplianceWhereUniqueInput
    /**
     * In case the AccountCompliance found by the `where` argument doesn't exist, create a new AccountCompliance with this data.
     */
    create: XOR<AccountComplianceCreateInput, AccountComplianceUncheckedCreateInput>
    /**
     * In case the AccountCompliance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountComplianceUpdateInput, AccountComplianceUncheckedUpdateInput>
  }

  /**
   * AccountCompliance delete
   */
  export type AccountComplianceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCompliance
     */
    select?: AccountComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountCompliance
     */
    omit?: AccountComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountComplianceInclude<ExtArgs> | null
    /**
     * Filter which AccountCompliance to delete.
     */
    where: AccountComplianceWhereUniqueInput
  }

  /**
   * AccountCompliance deleteMany
   */
  export type AccountComplianceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountCompliances to delete
     */
    where?: AccountComplianceWhereInput
    /**
     * Limit how many AccountCompliances to delete.
     */
    limit?: number
  }

  /**
   * AccountCompliance without action
   */
  export type AccountComplianceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCompliance
     */
    select?: AccountComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountCompliance
     */
    omit?: AccountComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountComplianceInclude<ExtArgs> | null
  }


  /**
   * Model UserAccount
   */

  export type AggregateUserAccount = {
    _count: UserAccountCountAggregateOutputType | null
    _min: UserAccountMinAggregateOutputType | null
    _max: UserAccountMaxAggregateOutputType | null
  }

  export type UserAccountMinAggregateOutputType = {
    user_id: string | null
    account_id: string | null
    role: string | null
    created_at: Date | null
  }

  export type UserAccountMaxAggregateOutputType = {
    user_id: string | null
    account_id: string | null
    role: string | null
    created_at: Date | null
  }

  export type UserAccountCountAggregateOutputType = {
    user_id: number
    account_id: number
    role: number
    created_at: number
    _all: number
  }


  export type UserAccountMinAggregateInputType = {
    user_id?: true
    account_id?: true
    role?: true
    created_at?: true
  }

  export type UserAccountMaxAggregateInputType = {
    user_id?: true
    account_id?: true
    role?: true
    created_at?: true
  }

  export type UserAccountCountAggregateInputType = {
    user_id?: true
    account_id?: true
    role?: true
    created_at?: true
    _all?: true
  }

  export type UserAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAccount to aggregate.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAccounts
    **/
    _count?: true | UserAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAccountMaxAggregateInputType
  }

  export type GetUserAccountAggregateType<T extends UserAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAccount[P]>
      : GetScalarType<T[P], AggregateUserAccount[P]>
  }




  export type UserAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAccountWhereInput
    orderBy?: UserAccountOrderByWithAggregationInput | UserAccountOrderByWithAggregationInput[]
    by: UserAccountScalarFieldEnum[] | UserAccountScalarFieldEnum
    having?: UserAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAccountCountAggregateInputType | true
    _min?: UserAccountMinAggregateInputType
    _max?: UserAccountMaxAggregateInputType
  }

  export type UserAccountGroupByOutputType = {
    user_id: string
    account_id: string
    role: string
    created_at: Date
    _count: UserAccountCountAggregateOutputType | null
    _min: UserAccountMinAggregateOutputType | null
    _max: UserAccountMaxAggregateOutputType | null
  }

  type GetUserAccountGroupByPayload<T extends UserAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAccountGroupByOutputType[P]>
            : GetScalarType<T[P], UserAccountGroupByOutputType[P]>
        }
      >
    >


  export type UserAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    account_id?: boolean
    role?: boolean
    created_at?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAccount"]>



  export type UserAccountSelectScalar = {
    user_id?: boolean
    account_id?: boolean
    role?: boolean
    created_at?: boolean
  }

  export type UserAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "account_id" | "role" | "created_at", ExtArgs["result"]["userAccount"]>
  export type UserAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAccount"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      account_id: string
      role: string
      created_at: Date
    }, ExtArgs["result"]["userAccount"]>
    composites: {}
  }

  type UserAccountGetPayload<S extends boolean | null | undefined | UserAccountDefaultArgs> = $Result.GetResult<Prisma.$UserAccountPayload, S>

  type UserAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAccountCountAggregateInputType | true
    }

  export interface UserAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAccount'], meta: { name: 'UserAccount' } }
    /**
     * Find zero or one UserAccount that matches the filter.
     * @param {UserAccountFindUniqueArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAccountFindUniqueArgs>(args: SelectSubset<T, UserAccountFindUniqueArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAccountFindUniqueOrThrowArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountFindFirstArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAccountFindFirstArgs>(args?: SelectSubset<T, UserAccountFindFirstArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountFindFirstOrThrowArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAccounts
     * const userAccounts = await prisma.userAccount.findMany()
     * 
     * // Get first 10 UserAccounts
     * const userAccounts = await prisma.userAccount.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const userAccountWithUser_idOnly = await prisma.userAccount.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends UserAccountFindManyArgs>(args?: SelectSubset<T, UserAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAccount.
     * @param {UserAccountCreateArgs} args - Arguments to create a UserAccount.
     * @example
     * // Create one UserAccount
     * const UserAccount = await prisma.userAccount.create({
     *   data: {
     *     // ... data to create a UserAccount
     *   }
     * })
     * 
     */
    create<T extends UserAccountCreateArgs>(args: SelectSubset<T, UserAccountCreateArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAccounts.
     * @param {UserAccountCreateManyArgs} args - Arguments to create many UserAccounts.
     * @example
     * // Create many UserAccounts
     * const userAccount = await prisma.userAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAccountCreateManyArgs>(args?: SelectSubset<T, UserAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserAccount.
     * @param {UserAccountDeleteArgs} args - Arguments to delete one UserAccount.
     * @example
     * // Delete one UserAccount
     * const UserAccount = await prisma.userAccount.delete({
     *   where: {
     *     // ... filter to delete one UserAccount
     *   }
     * })
     * 
     */
    delete<T extends UserAccountDeleteArgs>(args: SelectSubset<T, UserAccountDeleteArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAccount.
     * @param {UserAccountUpdateArgs} args - Arguments to update one UserAccount.
     * @example
     * // Update one UserAccount
     * const userAccount = await prisma.userAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAccountUpdateArgs>(args: SelectSubset<T, UserAccountUpdateArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAccounts.
     * @param {UserAccountDeleteManyArgs} args - Arguments to filter UserAccounts to delete.
     * @example
     * // Delete a few UserAccounts
     * const { count } = await prisma.userAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAccountDeleteManyArgs>(args?: SelectSubset<T, UserAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAccounts
     * const userAccount = await prisma.userAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAccountUpdateManyArgs>(args: SelectSubset<T, UserAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAccount.
     * @param {UserAccountUpsertArgs} args - Arguments to update or create a UserAccount.
     * @example
     * // Update or create a UserAccount
     * const userAccount = await prisma.userAccount.upsert({
     *   create: {
     *     // ... data to create a UserAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAccount we want to update
     *   }
     * })
     */
    upsert<T extends UserAccountUpsertArgs>(args: SelectSubset<T, UserAccountUpsertArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountCountArgs} args - Arguments to filter UserAccounts to count.
     * @example
     * // Count the number of UserAccounts
     * const count = await prisma.userAccount.count({
     *   where: {
     *     // ... the filter for the UserAccounts we want to count
     *   }
     * })
    **/
    count<T extends UserAccountCountArgs>(
      args?: Subset<T, UserAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAccountAggregateArgs>(args: Subset<T, UserAccountAggregateArgs>): Prisma.PrismaPromise<GetUserAccountAggregateType<T>>

    /**
     * Group by UserAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAccountGroupByArgs['orderBy'] }
        : { orderBy?: UserAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAccount model
   */
  readonly fields: UserAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAccount model
   */
  interface UserAccountFieldRefs {
    readonly user_id: FieldRef<"UserAccount", 'String'>
    readonly account_id: FieldRef<"UserAccount", 'String'>
    readonly role: FieldRef<"UserAccount", 'String'>
    readonly created_at: FieldRef<"UserAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAccount findUnique
   */
  export type UserAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where: UserAccountWhereUniqueInput
  }

  /**
   * UserAccount findUniqueOrThrow
   */
  export type UserAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where: UserAccountWhereUniqueInput
  }

  /**
   * UserAccount findFirst
   */
  export type UserAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAccounts.
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAccounts.
     */
    distinct?: UserAccountScalarFieldEnum | UserAccountScalarFieldEnum[]
  }

  /**
   * UserAccount findFirstOrThrow
   */
  export type UserAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAccounts.
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAccounts.
     */
    distinct?: UserAccountScalarFieldEnum | UserAccountScalarFieldEnum[]
  }

  /**
   * UserAccount findMany
   */
  export type UserAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccounts to fetch.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAccounts.
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    distinct?: UserAccountScalarFieldEnum | UserAccountScalarFieldEnum[]
  }

  /**
   * UserAccount create
   */
  export type UserAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAccount.
     */
    data: XOR<UserAccountCreateInput, UserAccountUncheckedCreateInput>
  }

  /**
   * UserAccount createMany
   */
  export type UserAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAccounts.
     */
    data: UserAccountCreateManyInput | UserAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAccount update
   */
  export type UserAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAccount.
     */
    data: XOR<UserAccountUpdateInput, UserAccountUncheckedUpdateInput>
    /**
     * Choose, which UserAccount to update.
     */
    where: UserAccountWhereUniqueInput
  }

  /**
   * UserAccount updateMany
   */
  export type UserAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAccounts.
     */
    data: XOR<UserAccountUpdateManyMutationInput, UserAccountUncheckedUpdateManyInput>
    /**
     * Filter which UserAccounts to update
     */
    where?: UserAccountWhereInput
    /**
     * Limit how many UserAccounts to update.
     */
    limit?: number
  }

  /**
   * UserAccount upsert
   */
  export type UserAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAccount to update in case it exists.
     */
    where: UserAccountWhereUniqueInput
    /**
     * In case the UserAccount found by the `where` argument doesn't exist, create a new UserAccount with this data.
     */
    create: XOR<UserAccountCreateInput, UserAccountUncheckedCreateInput>
    /**
     * In case the UserAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAccountUpdateInput, UserAccountUncheckedUpdateInput>
  }

  /**
   * UserAccount delete
   */
  export type UserAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter which UserAccount to delete.
     */
    where: UserAccountWhereUniqueInput
  }

  /**
   * UserAccount deleteMany
   */
  export type UserAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAccounts to delete
     */
    where?: UserAccountWhereInput
    /**
     * Limit how many UserAccounts to delete.
     */
    limit?: number
  }

  /**
   * UserAccount without action
   */
  export type UserAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
  }


  /**
   * Model AccountAuth
   */

  export type AggregateAccountAuth = {
    _count: AccountAuthCountAggregateOutputType | null
    _avg: AccountAuthAvgAggregateOutputType | null
    _sum: AccountAuthSumAggregateOutputType | null
    _min: AccountAuthMinAggregateOutputType | null
    _max: AccountAuthMaxAggregateOutputType | null
  }

  export type AccountAuthAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountAuthSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountAuthMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountAuthMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountAuthCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAuthAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountAuthSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountAuthMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountAuthMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountAuthCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAuthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountAuth to aggregate.
     */
    where?: AccountAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountAuths to fetch.
     */
    orderBy?: AccountAuthOrderByWithRelationInput | AccountAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountAuths
    **/
    _count?: true | AccountAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAuthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountAuthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountAuthMaxAggregateInputType
  }

  export type GetAccountAuthAggregateType<T extends AccountAuthAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountAuth[P]>
      : GetScalarType<T[P], AggregateAccountAuth[P]>
  }




  export type AccountAuthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountAuthWhereInput
    orderBy?: AccountAuthOrderByWithAggregationInput | AccountAuthOrderByWithAggregationInput[]
    by: AccountAuthScalarFieldEnum[] | AccountAuthScalarFieldEnum
    having?: AccountAuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountAuthCountAggregateInputType | true
    _avg?: AccountAuthAvgAggregateInputType
    _sum?: AccountAuthSumAggregateInputType
    _min?: AccountAuthMinAggregateInputType
    _max?: AccountAuthMaxAggregateInputType
  }

  export type AccountAuthGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountAuthCountAggregateOutputType | null
    _avg: AccountAuthAvgAggregateOutputType | null
    _sum: AccountAuthSumAggregateOutputType | null
    _min: AccountAuthMinAggregateOutputType | null
    _max: AccountAuthMaxAggregateOutputType | null
  }

  type GetAccountAuthGroupByPayload<T extends AccountAuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountAuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountAuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountAuthGroupByOutputType[P]>
            : GetScalarType<T[P], AccountAuthGroupByOutputType[P]>
        }
      >
    >


  export type AccountAuthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountAuth"]>



  export type AccountAuthSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountAuthOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["accountAuth"]>
  export type AccountAuthInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountAuthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountAuth"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["accountAuth"]>
    composites: {}
  }

  type AccountAuthGetPayload<S extends boolean | null | undefined | AccountAuthDefaultArgs> = $Result.GetResult<Prisma.$AccountAuthPayload, S>

  type AccountAuthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountAuthFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountAuthCountAggregateInputType | true
    }

  export interface AccountAuthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountAuth'], meta: { name: 'AccountAuth' } }
    /**
     * Find zero or one AccountAuth that matches the filter.
     * @param {AccountAuthFindUniqueArgs} args - Arguments to find a AccountAuth
     * @example
     * // Get one AccountAuth
     * const accountAuth = await prisma.accountAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountAuthFindUniqueArgs>(args: SelectSubset<T, AccountAuthFindUniqueArgs<ExtArgs>>): Prisma__AccountAuthClient<$Result.GetResult<Prisma.$AccountAuthPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccountAuth that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountAuthFindUniqueOrThrowArgs} args - Arguments to find a AccountAuth
     * @example
     * // Get one AccountAuth
     * const accountAuth = await prisma.accountAuth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountAuthFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountAuthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountAuthClient<$Result.GetResult<Prisma.$AccountAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountAuth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAuthFindFirstArgs} args - Arguments to find a AccountAuth
     * @example
     * // Get one AccountAuth
     * const accountAuth = await prisma.accountAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountAuthFindFirstArgs>(args?: SelectSubset<T, AccountAuthFindFirstArgs<ExtArgs>>): Prisma__AccountAuthClient<$Result.GetResult<Prisma.$AccountAuthPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountAuth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAuthFindFirstOrThrowArgs} args - Arguments to find a AccountAuth
     * @example
     * // Get one AccountAuth
     * const accountAuth = await prisma.accountAuth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountAuthFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountAuthFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountAuthClient<$Result.GetResult<Prisma.$AccountAuthPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccountAuths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAuthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountAuths
     * const accountAuths = await prisma.accountAuth.findMany()
     * 
     * // Get first 10 AccountAuths
     * const accountAuths = await prisma.accountAuth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountAuthWithIdOnly = await prisma.accountAuth.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountAuthFindManyArgs>(args?: SelectSubset<T, AccountAuthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountAuthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccountAuth.
     * @param {AccountAuthCreateArgs} args - Arguments to create a AccountAuth.
     * @example
     * // Create one AccountAuth
     * const AccountAuth = await prisma.accountAuth.create({
     *   data: {
     *     // ... data to create a AccountAuth
     *   }
     * })
     * 
     */
    create<T extends AccountAuthCreateArgs>(args: SelectSubset<T, AccountAuthCreateArgs<ExtArgs>>): Prisma__AccountAuthClient<$Result.GetResult<Prisma.$AccountAuthPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccountAuths.
     * @param {AccountAuthCreateManyArgs} args - Arguments to create many AccountAuths.
     * @example
     * // Create many AccountAuths
     * const accountAuth = await prisma.accountAuth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountAuthCreateManyArgs>(args?: SelectSubset<T, AccountAuthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AccountAuth.
     * @param {AccountAuthDeleteArgs} args - Arguments to delete one AccountAuth.
     * @example
     * // Delete one AccountAuth
     * const AccountAuth = await prisma.accountAuth.delete({
     *   where: {
     *     // ... filter to delete one AccountAuth
     *   }
     * })
     * 
     */
    delete<T extends AccountAuthDeleteArgs>(args: SelectSubset<T, AccountAuthDeleteArgs<ExtArgs>>): Prisma__AccountAuthClient<$Result.GetResult<Prisma.$AccountAuthPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccountAuth.
     * @param {AccountAuthUpdateArgs} args - Arguments to update one AccountAuth.
     * @example
     * // Update one AccountAuth
     * const accountAuth = await prisma.accountAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountAuthUpdateArgs>(args: SelectSubset<T, AccountAuthUpdateArgs<ExtArgs>>): Prisma__AccountAuthClient<$Result.GetResult<Prisma.$AccountAuthPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccountAuths.
     * @param {AccountAuthDeleteManyArgs} args - Arguments to filter AccountAuths to delete.
     * @example
     * // Delete a few AccountAuths
     * const { count } = await prisma.accountAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountAuthDeleteManyArgs>(args?: SelectSubset<T, AccountAuthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountAuths
     * const accountAuth = await prisma.accountAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountAuthUpdateManyArgs>(args: SelectSubset<T, AccountAuthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountAuth.
     * @param {AccountAuthUpsertArgs} args - Arguments to update or create a AccountAuth.
     * @example
     * // Update or create a AccountAuth
     * const accountAuth = await prisma.accountAuth.upsert({
     *   create: {
     *     // ... data to create a AccountAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountAuth we want to update
     *   }
     * })
     */
    upsert<T extends AccountAuthUpsertArgs>(args: SelectSubset<T, AccountAuthUpsertArgs<ExtArgs>>): Prisma__AccountAuthClient<$Result.GetResult<Prisma.$AccountAuthPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccountAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAuthCountArgs} args - Arguments to filter AccountAuths to count.
     * @example
     * // Count the number of AccountAuths
     * const count = await prisma.accountAuth.count({
     *   where: {
     *     // ... the filter for the AccountAuths we want to count
     *   }
     * })
    **/
    count<T extends AccountAuthCountArgs>(
      args?: Subset<T, AccountAuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAuthAggregateArgs>(args: Subset<T, AccountAuthAggregateArgs>): Prisma.PrismaPromise<GetAccountAuthAggregateType<T>>

    /**
     * Group by AccountAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountAuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountAuthGroupByArgs['orderBy'] }
        : { orderBy?: AccountAuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountAuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountAuth model
   */
  readonly fields: AccountAuthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountAuthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountAuth model
   */
  interface AccountAuthFieldRefs {
    readonly id: FieldRef<"AccountAuth", 'String'>
    readonly userId: FieldRef<"AccountAuth", 'String'>
    readonly type: FieldRef<"AccountAuth", 'String'>
    readonly provider: FieldRef<"AccountAuth", 'String'>
    readonly providerAccountId: FieldRef<"AccountAuth", 'String'>
    readonly refresh_token: FieldRef<"AccountAuth", 'String'>
    readonly access_token: FieldRef<"AccountAuth", 'String'>
    readonly expires_at: FieldRef<"AccountAuth", 'Int'>
    readonly token_type: FieldRef<"AccountAuth", 'String'>
    readonly scope: FieldRef<"AccountAuth", 'String'>
    readonly id_token: FieldRef<"AccountAuth", 'String'>
    readonly session_state: FieldRef<"AccountAuth", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AccountAuth findUnique
   */
  export type AccountAuthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAuth
     */
    select?: AccountAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAuth
     */
    omit?: AccountAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAuthInclude<ExtArgs> | null
    /**
     * Filter, which AccountAuth to fetch.
     */
    where: AccountAuthWhereUniqueInput
  }

  /**
   * AccountAuth findUniqueOrThrow
   */
  export type AccountAuthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAuth
     */
    select?: AccountAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAuth
     */
    omit?: AccountAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAuthInclude<ExtArgs> | null
    /**
     * Filter, which AccountAuth to fetch.
     */
    where: AccountAuthWhereUniqueInput
  }

  /**
   * AccountAuth findFirst
   */
  export type AccountAuthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAuth
     */
    select?: AccountAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAuth
     */
    omit?: AccountAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAuthInclude<ExtArgs> | null
    /**
     * Filter, which AccountAuth to fetch.
     */
    where?: AccountAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountAuths to fetch.
     */
    orderBy?: AccountAuthOrderByWithRelationInput | AccountAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountAuths.
     */
    cursor?: AccountAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountAuths.
     */
    distinct?: AccountAuthScalarFieldEnum | AccountAuthScalarFieldEnum[]
  }

  /**
   * AccountAuth findFirstOrThrow
   */
  export type AccountAuthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAuth
     */
    select?: AccountAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAuth
     */
    omit?: AccountAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAuthInclude<ExtArgs> | null
    /**
     * Filter, which AccountAuth to fetch.
     */
    where?: AccountAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountAuths to fetch.
     */
    orderBy?: AccountAuthOrderByWithRelationInput | AccountAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountAuths.
     */
    cursor?: AccountAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountAuths.
     */
    distinct?: AccountAuthScalarFieldEnum | AccountAuthScalarFieldEnum[]
  }

  /**
   * AccountAuth findMany
   */
  export type AccountAuthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAuth
     */
    select?: AccountAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAuth
     */
    omit?: AccountAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAuthInclude<ExtArgs> | null
    /**
     * Filter, which AccountAuths to fetch.
     */
    where?: AccountAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountAuths to fetch.
     */
    orderBy?: AccountAuthOrderByWithRelationInput | AccountAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountAuths.
     */
    cursor?: AccountAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountAuths.
     */
    skip?: number
    distinct?: AccountAuthScalarFieldEnum | AccountAuthScalarFieldEnum[]
  }

  /**
   * AccountAuth create
   */
  export type AccountAuthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAuth
     */
    select?: AccountAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAuth
     */
    omit?: AccountAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAuthInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountAuth.
     */
    data: XOR<AccountAuthCreateInput, AccountAuthUncheckedCreateInput>
  }

  /**
   * AccountAuth createMany
   */
  export type AccountAuthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountAuths.
     */
    data: AccountAuthCreateManyInput | AccountAuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountAuth update
   */
  export type AccountAuthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAuth
     */
    select?: AccountAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAuth
     */
    omit?: AccountAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAuthInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountAuth.
     */
    data: XOR<AccountAuthUpdateInput, AccountAuthUncheckedUpdateInput>
    /**
     * Choose, which AccountAuth to update.
     */
    where: AccountAuthWhereUniqueInput
  }

  /**
   * AccountAuth updateMany
   */
  export type AccountAuthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountAuths.
     */
    data: XOR<AccountAuthUpdateManyMutationInput, AccountAuthUncheckedUpdateManyInput>
    /**
     * Filter which AccountAuths to update
     */
    where?: AccountAuthWhereInput
    /**
     * Limit how many AccountAuths to update.
     */
    limit?: number
  }

  /**
   * AccountAuth upsert
   */
  export type AccountAuthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAuth
     */
    select?: AccountAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAuth
     */
    omit?: AccountAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAuthInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountAuth to update in case it exists.
     */
    where: AccountAuthWhereUniqueInput
    /**
     * In case the AccountAuth found by the `where` argument doesn't exist, create a new AccountAuth with this data.
     */
    create: XOR<AccountAuthCreateInput, AccountAuthUncheckedCreateInput>
    /**
     * In case the AccountAuth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountAuthUpdateInput, AccountAuthUncheckedUpdateInput>
  }

  /**
   * AccountAuth delete
   */
  export type AccountAuthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAuth
     */
    select?: AccountAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAuth
     */
    omit?: AccountAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAuthInclude<ExtArgs> | null
    /**
     * Filter which AccountAuth to delete.
     */
    where: AccountAuthWhereUniqueInput
  }

  /**
   * AccountAuth deleteMany
   */
  export type AccountAuthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountAuths to delete
     */
    where?: AccountAuthWhereInput
    /**
     * Limit how many AccountAuths to delete.
     */
    limit?: number
  }

  /**
   * AccountAuth without action
   */
  export type AccountAuthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAuth
     */
    select?: AccountAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAuth
     */
    omit?: AccountAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAuthInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>



  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>



  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    displayName: string | null
    bio: string | null
    jobTitle: string | null
    company: string | null
    address1: string | null
    address2: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    language: string | null
    timezone: string | null
    website: string | null
    linkedin: string | null
    twitter: string | null
    facebook: string | null
    instagram: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    displayName: string | null
    bio: string | null
    jobTitle: string | null
    company: string | null
    address1: string | null
    address2: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    language: string | null
    timezone: string | null
    website: string | null
    linkedin: string | null
    twitter: string | null
    facebook: string | null
    instagram: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    displayName: number
    bio: number
    jobTitle: number
    company: number
    address1: number
    address2: number
    city: number
    state: number
    zipCode: number
    country: number
    language: number
    timezone: number
    website: number
    linkedin: number
    twitter: number
    facebook: number
    instagram: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    displayName?: true
    bio?: true
    jobTitle?: true
    company?: true
    address1?: true
    address2?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    language?: true
    timezone?: true
    website?: true
    linkedin?: true
    twitter?: true
    facebook?: true
    instagram?: true
    created_at?: true
    updated_at?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    displayName?: true
    bio?: true
    jobTitle?: true
    company?: true
    address1?: true
    address2?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    language?: true
    timezone?: true
    website?: true
    linkedin?: true
    twitter?: true
    facebook?: true
    instagram?: true
    created_at?: true
    updated_at?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    displayName?: true
    bio?: true
    jobTitle?: true
    company?: true
    address1?: true
    address2?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    language?: true
    timezone?: true
    website?: true
    linkedin?: true
    twitter?: true
    facebook?: true
    instagram?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    userId: string
    firstName: string | null
    lastName: string | null
    displayName: string | null
    bio: string | null
    jobTitle: string | null
    company: string | null
    address1: string | null
    address2: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    language: string | null
    timezone: string | null
    website: string | null
    linkedin: string | null
    twitter: string | null
    facebook: string | null
    instagram: string | null
    created_at: Date
    updated_at: Date
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    displayName?: boolean
    bio?: boolean
    jobTitle?: boolean
    company?: boolean
    address1?: boolean
    address2?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    language?: boolean
    timezone?: boolean
    website?: boolean
    linkedin?: boolean
    twitter?: boolean
    facebook?: boolean
    instagram?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    emails?: boolean | Profile$emailsArgs<ExtArgs>
    phones?: boolean | Profile$phonesArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>



  export type ProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    displayName?: boolean
    bio?: boolean
    jobTitle?: boolean
    company?: boolean
    address1?: boolean
    address2?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    language?: boolean
    timezone?: boolean
    website?: boolean
    linkedin?: boolean
    twitter?: boolean
    facebook?: boolean
    instagram?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "firstName" | "lastName" | "displayName" | "bio" | "jobTitle" | "company" | "address1" | "address2" | "city" | "state" | "zipCode" | "country" | "language" | "timezone" | "website" | "linkedin" | "twitter" | "facebook" | "instagram" | "created_at" | "updated_at", ExtArgs["result"]["profile"]>
  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    emails?: boolean | Profile$emailsArgs<ExtArgs>
    phones?: boolean | Profile$phonesArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      emails: Prisma.$ProfileEmailPayload<ExtArgs>[]
      phones: Prisma.$ProfilePhonePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      firstName: string | null
      lastName: string | null
      displayName: string | null
      bio: string | null
      jobTitle: string | null
      company: string | null
      address1: string | null
      address2: string | null
      city: string | null
      state: string | null
      zipCode: string | null
      country: string | null
      language: string | null
      timezone: string | null
      website: string | null
      linkedin: string | null
      twitter: string | null
      facebook: string | null
      instagram: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    emails<T extends Profile$emailsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$emailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileEmailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    phones<T extends Profile$phonesArgs<ExtArgs> = {}>(args?: Subset<T, Profile$phonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePhonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly userId: FieldRef<"Profile", 'String'>
    readonly firstName: FieldRef<"Profile", 'String'>
    readonly lastName: FieldRef<"Profile", 'String'>
    readonly displayName: FieldRef<"Profile", 'String'>
    readonly bio: FieldRef<"Profile", 'String'>
    readonly jobTitle: FieldRef<"Profile", 'String'>
    readonly company: FieldRef<"Profile", 'String'>
    readonly address1: FieldRef<"Profile", 'String'>
    readonly address2: FieldRef<"Profile", 'String'>
    readonly city: FieldRef<"Profile", 'String'>
    readonly state: FieldRef<"Profile", 'String'>
    readonly zipCode: FieldRef<"Profile", 'String'>
    readonly country: FieldRef<"Profile", 'String'>
    readonly language: FieldRef<"Profile", 'String'>
    readonly timezone: FieldRef<"Profile", 'String'>
    readonly website: FieldRef<"Profile", 'String'>
    readonly linkedin: FieldRef<"Profile", 'String'>
    readonly twitter: FieldRef<"Profile", 'String'>
    readonly facebook: FieldRef<"Profile", 'String'>
    readonly instagram: FieldRef<"Profile", 'String'>
    readonly created_at: FieldRef<"Profile", 'DateTime'>
    readonly updated_at: FieldRef<"Profile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to delete.
     */
    limit?: number
  }

  /**
   * Profile.emails
   */
  export type Profile$emailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileEmail
     */
    select?: ProfileEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileEmail
     */
    omit?: ProfileEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileEmailInclude<ExtArgs> | null
    where?: ProfileEmailWhereInput
    orderBy?: ProfileEmailOrderByWithRelationInput | ProfileEmailOrderByWithRelationInput[]
    cursor?: ProfileEmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileEmailScalarFieldEnum | ProfileEmailScalarFieldEnum[]
  }

  /**
   * Profile.phones
   */
  export type Profile$phonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilePhone
     */
    select?: ProfilePhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfilePhone
     */
    omit?: ProfilePhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilePhoneInclude<ExtArgs> | null
    where?: ProfilePhoneWhereInput
    orderBy?: ProfilePhoneOrderByWithRelationInput | ProfilePhoneOrderByWithRelationInput[]
    cursor?: ProfilePhoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfilePhoneScalarFieldEnum | ProfilePhoneScalarFieldEnum[]
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model ProfileEmail
   */

  export type AggregateProfileEmail = {
    _count: ProfileEmailCountAggregateOutputType | null
    _min: ProfileEmailMinAggregateOutputType | null
    _max: ProfileEmailMaxAggregateOutputType | null
  }

  export type ProfileEmailMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    email: string | null
    type: string | null
    isPrimary: boolean | null
    isVerified: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProfileEmailMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    email: string | null
    type: string | null
    isPrimary: boolean | null
    isVerified: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProfileEmailCountAggregateOutputType = {
    id: number
    profileId: number
    email: number
    type: number
    isPrimary: number
    isVerified: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProfileEmailMinAggregateInputType = {
    id?: true
    profileId?: true
    email?: true
    type?: true
    isPrimary?: true
    isVerified?: true
    created_at?: true
    updated_at?: true
  }

  export type ProfileEmailMaxAggregateInputType = {
    id?: true
    profileId?: true
    email?: true
    type?: true
    isPrimary?: true
    isVerified?: true
    created_at?: true
    updated_at?: true
  }

  export type ProfileEmailCountAggregateInputType = {
    id?: true
    profileId?: true
    email?: true
    type?: true
    isPrimary?: true
    isVerified?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProfileEmailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileEmail to aggregate.
     */
    where?: ProfileEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileEmails to fetch.
     */
    orderBy?: ProfileEmailOrderByWithRelationInput | ProfileEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileEmails
    **/
    _count?: true | ProfileEmailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileEmailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileEmailMaxAggregateInputType
  }

  export type GetProfileEmailAggregateType<T extends ProfileEmailAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileEmail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileEmail[P]>
      : GetScalarType<T[P], AggregateProfileEmail[P]>
  }




  export type ProfileEmailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileEmailWhereInput
    orderBy?: ProfileEmailOrderByWithAggregationInput | ProfileEmailOrderByWithAggregationInput[]
    by: ProfileEmailScalarFieldEnum[] | ProfileEmailScalarFieldEnum
    having?: ProfileEmailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileEmailCountAggregateInputType | true
    _min?: ProfileEmailMinAggregateInputType
    _max?: ProfileEmailMaxAggregateInputType
  }

  export type ProfileEmailGroupByOutputType = {
    id: string
    profileId: string
    email: string
    type: string
    isPrimary: boolean
    isVerified: boolean
    created_at: Date
    updated_at: Date
    _count: ProfileEmailCountAggregateOutputType | null
    _min: ProfileEmailMinAggregateOutputType | null
    _max: ProfileEmailMaxAggregateOutputType | null
  }

  type GetProfileEmailGroupByPayload<T extends ProfileEmailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileEmailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileEmailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileEmailGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileEmailGroupByOutputType[P]>
        }
      >
    >


  export type ProfileEmailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    email?: boolean
    type?: boolean
    isPrimary?: boolean
    isVerified?: boolean
    created_at?: boolean
    updated_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileEmail"]>



  export type ProfileEmailSelectScalar = {
    id?: boolean
    profileId?: boolean
    email?: boolean
    type?: boolean
    isPrimary?: boolean
    isVerified?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProfileEmailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profileId" | "email" | "type" | "isPrimary" | "isVerified" | "created_at" | "updated_at", ExtArgs["result"]["profileEmail"]>
  export type ProfileEmailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $ProfileEmailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileEmail"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      email: string
      type: string
      isPrimary: boolean
      isVerified: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["profileEmail"]>
    composites: {}
  }

  type ProfileEmailGetPayload<S extends boolean | null | undefined | ProfileEmailDefaultArgs> = $Result.GetResult<Prisma.$ProfileEmailPayload, S>

  type ProfileEmailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileEmailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileEmailCountAggregateInputType | true
    }

  export interface ProfileEmailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileEmail'], meta: { name: 'ProfileEmail' } }
    /**
     * Find zero or one ProfileEmail that matches the filter.
     * @param {ProfileEmailFindUniqueArgs} args - Arguments to find a ProfileEmail
     * @example
     * // Get one ProfileEmail
     * const profileEmail = await prisma.profileEmail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileEmailFindUniqueArgs>(args: SelectSubset<T, ProfileEmailFindUniqueArgs<ExtArgs>>): Prisma__ProfileEmailClient<$Result.GetResult<Prisma.$ProfileEmailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProfileEmail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileEmailFindUniqueOrThrowArgs} args - Arguments to find a ProfileEmail
     * @example
     * // Get one ProfileEmail
     * const profileEmail = await prisma.profileEmail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileEmailFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileEmailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileEmailClient<$Result.GetResult<Prisma.$ProfileEmailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfileEmail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileEmailFindFirstArgs} args - Arguments to find a ProfileEmail
     * @example
     * // Get one ProfileEmail
     * const profileEmail = await prisma.profileEmail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileEmailFindFirstArgs>(args?: SelectSubset<T, ProfileEmailFindFirstArgs<ExtArgs>>): Prisma__ProfileEmailClient<$Result.GetResult<Prisma.$ProfileEmailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfileEmail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileEmailFindFirstOrThrowArgs} args - Arguments to find a ProfileEmail
     * @example
     * // Get one ProfileEmail
     * const profileEmail = await prisma.profileEmail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileEmailFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileEmailFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileEmailClient<$Result.GetResult<Prisma.$ProfileEmailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProfileEmails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileEmailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileEmails
     * const profileEmails = await prisma.profileEmail.findMany()
     * 
     * // Get first 10 ProfileEmails
     * const profileEmails = await prisma.profileEmail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileEmailWithIdOnly = await prisma.profileEmail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileEmailFindManyArgs>(args?: SelectSubset<T, ProfileEmailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileEmailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProfileEmail.
     * @param {ProfileEmailCreateArgs} args - Arguments to create a ProfileEmail.
     * @example
     * // Create one ProfileEmail
     * const ProfileEmail = await prisma.profileEmail.create({
     *   data: {
     *     // ... data to create a ProfileEmail
     *   }
     * })
     * 
     */
    create<T extends ProfileEmailCreateArgs>(args: SelectSubset<T, ProfileEmailCreateArgs<ExtArgs>>): Prisma__ProfileEmailClient<$Result.GetResult<Prisma.$ProfileEmailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProfileEmails.
     * @param {ProfileEmailCreateManyArgs} args - Arguments to create many ProfileEmails.
     * @example
     * // Create many ProfileEmails
     * const profileEmail = await prisma.profileEmail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileEmailCreateManyArgs>(args?: SelectSubset<T, ProfileEmailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProfileEmail.
     * @param {ProfileEmailDeleteArgs} args - Arguments to delete one ProfileEmail.
     * @example
     * // Delete one ProfileEmail
     * const ProfileEmail = await prisma.profileEmail.delete({
     *   where: {
     *     // ... filter to delete one ProfileEmail
     *   }
     * })
     * 
     */
    delete<T extends ProfileEmailDeleteArgs>(args: SelectSubset<T, ProfileEmailDeleteArgs<ExtArgs>>): Prisma__ProfileEmailClient<$Result.GetResult<Prisma.$ProfileEmailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProfileEmail.
     * @param {ProfileEmailUpdateArgs} args - Arguments to update one ProfileEmail.
     * @example
     * // Update one ProfileEmail
     * const profileEmail = await prisma.profileEmail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileEmailUpdateArgs>(args: SelectSubset<T, ProfileEmailUpdateArgs<ExtArgs>>): Prisma__ProfileEmailClient<$Result.GetResult<Prisma.$ProfileEmailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProfileEmails.
     * @param {ProfileEmailDeleteManyArgs} args - Arguments to filter ProfileEmails to delete.
     * @example
     * // Delete a few ProfileEmails
     * const { count } = await prisma.profileEmail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileEmailDeleteManyArgs>(args?: SelectSubset<T, ProfileEmailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileEmailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileEmails
     * const profileEmail = await prisma.profileEmail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileEmailUpdateManyArgs>(args: SelectSubset<T, ProfileEmailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfileEmail.
     * @param {ProfileEmailUpsertArgs} args - Arguments to update or create a ProfileEmail.
     * @example
     * // Update or create a ProfileEmail
     * const profileEmail = await prisma.profileEmail.upsert({
     *   create: {
     *     // ... data to create a ProfileEmail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileEmail we want to update
     *   }
     * })
     */
    upsert<T extends ProfileEmailUpsertArgs>(args: SelectSubset<T, ProfileEmailUpsertArgs<ExtArgs>>): Prisma__ProfileEmailClient<$Result.GetResult<Prisma.$ProfileEmailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProfileEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileEmailCountArgs} args - Arguments to filter ProfileEmails to count.
     * @example
     * // Count the number of ProfileEmails
     * const count = await prisma.profileEmail.count({
     *   where: {
     *     // ... the filter for the ProfileEmails we want to count
     *   }
     * })
    **/
    count<T extends ProfileEmailCountArgs>(
      args?: Subset<T, ProfileEmailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileEmailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileEmailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileEmailAggregateArgs>(args: Subset<T, ProfileEmailAggregateArgs>): Prisma.PrismaPromise<GetProfileEmailAggregateType<T>>

    /**
     * Group by ProfileEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileEmailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileEmailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileEmailGroupByArgs['orderBy'] }
        : { orderBy?: ProfileEmailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileEmailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileEmailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileEmail model
   */
  readonly fields: ProfileEmailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileEmail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileEmailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileEmail model
   */
  interface ProfileEmailFieldRefs {
    readonly id: FieldRef<"ProfileEmail", 'String'>
    readonly profileId: FieldRef<"ProfileEmail", 'String'>
    readonly email: FieldRef<"ProfileEmail", 'String'>
    readonly type: FieldRef<"ProfileEmail", 'String'>
    readonly isPrimary: FieldRef<"ProfileEmail", 'Boolean'>
    readonly isVerified: FieldRef<"ProfileEmail", 'Boolean'>
    readonly created_at: FieldRef<"ProfileEmail", 'DateTime'>
    readonly updated_at: FieldRef<"ProfileEmail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProfileEmail findUnique
   */
  export type ProfileEmailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileEmail
     */
    select?: ProfileEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileEmail
     */
    omit?: ProfileEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileEmailInclude<ExtArgs> | null
    /**
     * Filter, which ProfileEmail to fetch.
     */
    where: ProfileEmailWhereUniqueInput
  }

  /**
   * ProfileEmail findUniqueOrThrow
   */
  export type ProfileEmailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileEmail
     */
    select?: ProfileEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileEmail
     */
    omit?: ProfileEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileEmailInclude<ExtArgs> | null
    /**
     * Filter, which ProfileEmail to fetch.
     */
    where: ProfileEmailWhereUniqueInput
  }

  /**
   * ProfileEmail findFirst
   */
  export type ProfileEmailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileEmail
     */
    select?: ProfileEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileEmail
     */
    omit?: ProfileEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileEmailInclude<ExtArgs> | null
    /**
     * Filter, which ProfileEmail to fetch.
     */
    where?: ProfileEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileEmails to fetch.
     */
    orderBy?: ProfileEmailOrderByWithRelationInput | ProfileEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileEmails.
     */
    cursor?: ProfileEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileEmails.
     */
    distinct?: ProfileEmailScalarFieldEnum | ProfileEmailScalarFieldEnum[]
  }

  /**
   * ProfileEmail findFirstOrThrow
   */
  export type ProfileEmailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileEmail
     */
    select?: ProfileEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileEmail
     */
    omit?: ProfileEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileEmailInclude<ExtArgs> | null
    /**
     * Filter, which ProfileEmail to fetch.
     */
    where?: ProfileEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileEmails to fetch.
     */
    orderBy?: ProfileEmailOrderByWithRelationInput | ProfileEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileEmails.
     */
    cursor?: ProfileEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileEmails.
     */
    distinct?: ProfileEmailScalarFieldEnum | ProfileEmailScalarFieldEnum[]
  }

  /**
   * ProfileEmail findMany
   */
  export type ProfileEmailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileEmail
     */
    select?: ProfileEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileEmail
     */
    omit?: ProfileEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileEmailInclude<ExtArgs> | null
    /**
     * Filter, which ProfileEmails to fetch.
     */
    where?: ProfileEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileEmails to fetch.
     */
    orderBy?: ProfileEmailOrderByWithRelationInput | ProfileEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileEmails.
     */
    cursor?: ProfileEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileEmails.
     */
    skip?: number
    distinct?: ProfileEmailScalarFieldEnum | ProfileEmailScalarFieldEnum[]
  }

  /**
   * ProfileEmail create
   */
  export type ProfileEmailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileEmail
     */
    select?: ProfileEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileEmail
     */
    omit?: ProfileEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileEmailInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileEmail.
     */
    data: XOR<ProfileEmailCreateInput, ProfileEmailUncheckedCreateInput>
  }

  /**
   * ProfileEmail createMany
   */
  export type ProfileEmailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileEmails.
     */
    data: ProfileEmailCreateManyInput | ProfileEmailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileEmail update
   */
  export type ProfileEmailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileEmail
     */
    select?: ProfileEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileEmail
     */
    omit?: ProfileEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileEmailInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileEmail.
     */
    data: XOR<ProfileEmailUpdateInput, ProfileEmailUncheckedUpdateInput>
    /**
     * Choose, which ProfileEmail to update.
     */
    where: ProfileEmailWhereUniqueInput
  }

  /**
   * ProfileEmail updateMany
   */
  export type ProfileEmailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileEmails.
     */
    data: XOR<ProfileEmailUpdateManyMutationInput, ProfileEmailUncheckedUpdateManyInput>
    /**
     * Filter which ProfileEmails to update
     */
    where?: ProfileEmailWhereInput
    /**
     * Limit how many ProfileEmails to update.
     */
    limit?: number
  }

  /**
   * ProfileEmail upsert
   */
  export type ProfileEmailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileEmail
     */
    select?: ProfileEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileEmail
     */
    omit?: ProfileEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileEmailInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileEmail to update in case it exists.
     */
    where: ProfileEmailWhereUniqueInput
    /**
     * In case the ProfileEmail found by the `where` argument doesn't exist, create a new ProfileEmail with this data.
     */
    create: XOR<ProfileEmailCreateInput, ProfileEmailUncheckedCreateInput>
    /**
     * In case the ProfileEmail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileEmailUpdateInput, ProfileEmailUncheckedUpdateInput>
  }

  /**
   * ProfileEmail delete
   */
  export type ProfileEmailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileEmail
     */
    select?: ProfileEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileEmail
     */
    omit?: ProfileEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileEmailInclude<ExtArgs> | null
    /**
     * Filter which ProfileEmail to delete.
     */
    where: ProfileEmailWhereUniqueInput
  }

  /**
   * ProfileEmail deleteMany
   */
  export type ProfileEmailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileEmails to delete
     */
    where?: ProfileEmailWhereInput
    /**
     * Limit how many ProfileEmails to delete.
     */
    limit?: number
  }

  /**
   * ProfileEmail without action
   */
  export type ProfileEmailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileEmail
     */
    select?: ProfileEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileEmail
     */
    omit?: ProfileEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileEmailInclude<ExtArgs> | null
  }


  /**
   * Model ProfilePhone
   */

  export type AggregateProfilePhone = {
    _count: ProfilePhoneCountAggregateOutputType | null
    _min: ProfilePhoneMinAggregateOutputType | null
    _max: ProfilePhoneMaxAggregateOutputType | null
  }

  export type ProfilePhoneMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    phoneNumber: string | null
    type: string | null
    isPrimary: boolean | null
    isVerified: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProfilePhoneMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    phoneNumber: string | null
    type: string | null
    isPrimary: boolean | null
    isVerified: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProfilePhoneCountAggregateOutputType = {
    id: number
    profileId: number
    phoneNumber: number
    type: number
    isPrimary: number
    isVerified: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProfilePhoneMinAggregateInputType = {
    id?: true
    profileId?: true
    phoneNumber?: true
    type?: true
    isPrimary?: true
    isVerified?: true
    created_at?: true
    updated_at?: true
  }

  export type ProfilePhoneMaxAggregateInputType = {
    id?: true
    profileId?: true
    phoneNumber?: true
    type?: true
    isPrimary?: true
    isVerified?: true
    created_at?: true
    updated_at?: true
  }

  export type ProfilePhoneCountAggregateInputType = {
    id?: true
    profileId?: true
    phoneNumber?: true
    type?: true
    isPrimary?: true
    isVerified?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProfilePhoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfilePhone to aggregate.
     */
    where?: ProfilePhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfilePhones to fetch.
     */
    orderBy?: ProfilePhoneOrderByWithRelationInput | ProfilePhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfilePhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfilePhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfilePhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfilePhones
    **/
    _count?: true | ProfilePhoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfilePhoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfilePhoneMaxAggregateInputType
  }

  export type GetProfilePhoneAggregateType<T extends ProfilePhoneAggregateArgs> = {
        [P in keyof T & keyof AggregateProfilePhone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfilePhone[P]>
      : GetScalarType<T[P], AggregateProfilePhone[P]>
  }




  export type ProfilePhoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfilePhoneWhereInput
    orderBy?: ProfilePhoneOrderByWithAggregationInput | ProfilePhoneOrderByWithAggregationInput[]
    by: ProfilePhoneScalarFieldEnum[] | ProfilePhoneScalarFieldEnum
    having?: ProfilePhoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfilePhoneCountAggregateInputType | true
    _min?: ProfilePhoneMinAggregateInputType
    _max?: ProfilePhoneMaxAggregateInputType
  }

  export type ProfilePhoneGroupByOutputType = {
    id: string
    profileId: string
    phoneNumber: string
    type: string
    isPrimary: boolean
    isVerified: boolean
    created_at: Date
    updated_at: Date
    _count: ProfilePhoneCountAggregateOutputType | null
    _min: ProfilePhoneMinAggregateOutputType | null
    _max: ProfilePhoneMaxAggregateOutputType | null
  }

  type GetProfilePhoneGroupByPayload<T extends ProfilePhoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfilePhoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfilePhoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfilePhoneGroupByOutputType[P]>
            : GetScalarType<T[P], ProfilePhoneGroupByOutputType[P]>
        }
      >
    >


  export type ProfilePhoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    phoneNumber?: boolean
    type?: boolean
    isPrimary?: boolean
    isVerified?: boolean
    created_at?: boolean
    updated_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profilePhone"]>



  export type ProfilePhoneSelectScalar = {
    id?: boolean
    profileId?: boolean
    phoneNumber?: boolean
    type?: boolean
    isPrimary?: boolean
    isVerified?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProfilePhoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profileId" | "phoneNumber" | "type" | "isPrimary" | "isVerified" | "created_at" | "updated_at", ExtArgs["result"]["profilePhone"]>
  export type ProfilePhoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $ProfilePhonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfilePhone"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      phoneNumber: string
      type: string
      isPrimary: boolean
      isVerified: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["profilePhone"]>
    composites: {}
  }

  type ProfilePhoneGetPayload<S extends boolean | null | undefined | ProfilePhoneDefaultArgs> = $Result.GetResult<Prisma.$ProfilePhonePayload, S>

  type ProfilePhoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfilePhoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfilePhoneCountAggregateInputType | true
    }

  export interface ProfilePhoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfilePhone'], meta: { name: 'ProfilePhone' } }
    /**
     * Find zero or one ProfilePhone that matches the filter.
     * @param {ProfilePhoneFindUniqueArgs} args - Arguments to find a ProfilePhone
     * @example
     * // Get one ProfilePhone
     * const profilePhone = await prisma.profilePhone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfilePhoneFindUniqueArgs>(args: SelectSubset<T, ProfilePhoneFindUniqueArgs<ExtArgs>>): Prisma__ProfilePhoneClient<$Result.GetResult<Prisma.$ProfilePhonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProfilePhone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfilePhoneFindUniqueOrThrowArgs} args - Arguments to find a ProfilePhone
     * @example
     * // Get one ProfilePhone
     * const profilePhone = await prisma.profilePhone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfilePhoneFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfilePhoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfilePhoneClient<$Result.GetResult<Prisma.$ProfilePhonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfilePhone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilePhoneFindFirstArgs} args - Arguments to find a ProfilePhone
     * @example
     * // Get one ProfilePhone
     * const profilePhone = await prisma.profilePhone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfilePhoneFindFirstArgs>(args?: SelectSubset<T, ProfilePhoneFindFirstArgs<ExtArgs>>): Prisma__ProfilePhoneClient<$Result.GetResult<Prisma.$ProfilePhonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfilePhone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilePhoneFindFirstOrThrowArgs} args - Arguments to find a ProfilePhone
     * @example
     * // Get one ProfilePhone
     * const profilePhone = await prisma.profilePhone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfilePhoneFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfilePhoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfilePhoneClient<$Result.GetResult<Prisma.$ProfilePhonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProfilePhones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilePhoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfilePhones
     * const profilePhones = await prisma.profilePhone.findMany()
     * 
     * // Get first 10 ProfilePhones
     * const profilePhones = await prisma.profilePhone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profilePhoneWithIdOnly = await prisma.profilePhone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfilePhoneFindManyArgs>(args?: SelectSubset<T, ProfilePhoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePhonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProfilePhone.
     * @param {ProfilePhoneCreateArgs} args - Arguments to create a ProfilePhone.
     * @example
     * // Create one ProfilePhone
     * const ProfilePhone = await prisma.profilePhone.create({
     *   data: {
     *     // ... data to create a ProfilePhone
     *   }
     * })
     * 
     */
    create<T extends ProfilePhoneCreateArgs>(args: SelectSubset<T, ProfilePhoneCreateArgs<ExtArgs>>): Prisma__ProfilePhoneClient<$Result.GetResult<Prisma.$ProfilePhonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProfilePhones.
     * @param {ProfilePhoneCreateManyArgs} args - Arguments to create many ProfilePhones.
     * @example
     * // Create many ProfilePhones
     * const profilePhone = await prisma.profilePhone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfilePhoneCreateManyArgs>(args?: SelectSubset<T, ProfilePhoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProfilePhone.
     * @param {ProfilePhoneDeleteArgs} args - Arguments to delete one ProfilePhone.
     * @example
     * // Delete one ProfilePhone
     * const ProfilePhone = await prisma.profilePhone.delete({
     *   where: {
     *     // ... filter to delete one ProfilePhone
     *   }
     * })
     * 
     */
    delete<T extends ProfilePhoneDeleteArgs>(args: SelectSubset<T, ProfilePhoneDeleteArgs<ExtArgs>>): Prisma__ProfilePhoneClient<$Result.GetResult<Prisma.$ProfilePhonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProfilePhone.
     * @param {ProfilePhoneUpdateArgs} args - Arguments to update one ProfilePhone.
     * @example
     * // Update one ProfilePhone
     * const profilePhone = await prisma.profilePhone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfilePhoneUpdateArgs>(args: SelectSubset<T, ProfilePhoneUpdateArgs<ExtArgs>>): Prisma__ProfilePhoneClient<$Result.GetResult<Prisma.$ProfilePhonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProfilePhones.
     * @param {ProfilePhoneDeleteManyArgs} args - Arguments to filter ProfilePhones to delete.
     * @example
     * // Delete a few ProfilePhones
     * const { count } = await prisma.profilePhone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfilePhoneDeleteManyArgs>(args?: SelectSubset<T, ProfilePhoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfilePhones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilePhoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfilePhones
     * const profilePhone = await prisma.profilePhone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfilePhoneUpdateManyArgs>(args: SelectSubset<T, ProfilePhoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfilePhone.
     * @param {ProfilePhoneUpsertArgs} args - Arguments to update or create a ProfilePhone.
     * @example
     * // Update or create a ProfilePhone
     * const profilePhone = await prisma.profilePhone.upsert({
     *   create: {
     *     // ... data to create a ProfilePhone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfilePhone we want to update
     *   }
     * })
     */
    upsert<T extends ProfilePhoneUpsertArgs>(args: SelectSubset<T, ProfilePhoneUpsertArgs<ExtArgs>>): Prisma__ProfilePhoneClient<$Result.GetResult<Prisma.$ProfilePhonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProfilePhones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilePhoneCountArgs} args - Arguments to filter ProfilePhones to count.
     * @example
     * // Count the number of ProfilePhones
     * const count = await prisma.profilePhone.count({
     *   where: {
     *     // ... the filter for the ProfilePhones we want to count
     *   }
     * })
    **/
    count<T extends ProfilePhoneCountArgs>(
      args?: Subset<T, ProfilePhoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfilePhoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfilePhone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilePhoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfilePhoneAggregateArgs>(args: Subset<T, ProfilePhoneAggregateArgs>): Prisma.PrismaPromise<GetProfilePhoneAggregateType<T>>

    /**
     * Group by ProfilePhone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilePhoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfilePhoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfilePhoneGroupByArgs['orderBy'] }
        : { orderBy?: ProfilePhoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfilePhoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfilePhoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfilePhone model
   */
  readonly fields: ProfilePhoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfilePhone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfilePhoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfilePhone model
   */
  interface ProfilePhoneFieldRefs {
    readonly id: FieldRef<"ProfilePhone", 'String'>
    readonly profileId: FieldRef<"ProfilePhone", 'String'>
    readonly phoneNumber: FieldRef<"ProfilePhone", 'String'>
    readonly type: FieldRef<"ProfilePhone", 'String'>
    readonly isPrimary: FieldRef<"ProfilePhone", 'Boolean'>
    readonly isVerified: FieldRef<"ProfilePhone", 'Boolean'>
    readonly created_at: FieldRef<"ProfilePhone", 'DateTime'>
    readonly updated_at: FieldRef<"ProfilePhone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProfilePhone findUnique
   */
  export type ProfilePhoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilePhone
     */
    select?: ProfilePhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfilePhone
     */
    omit?: ProfilePhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilePhoneInclude<ExtArgs> | null
    /**
     * Filter, which ProfilePhone to fetch.
     */
    where: ProfilePhoneWhereUniqueInput
  }

  /**
   * ProfilePhone findUniqueOrThrow
   */
  export type ProfilePhoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilePhone
     */
    select?: ProfilePhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfilePhone
     */
    omit?: ProfilePhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilePhoneInclude<ExtArgs> | null
    /**
     * Filter, which ProfilePhone to fetch.
     */
    where: ProfilePhoneWhereUniqueInput
  }

  /**
   * ProfilePhone findFirst
   */
  export type ProfilePhoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilePhone
     */
    select?: ProfilePhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfilePhone
     */
    omit?: ProfilePhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilePhoneInclude<ExtArgs> | null
    /**
     * Filter, which ProfilePhone to fetch.
     */
    where?: ProfilePhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfilePhones to fetch.
     */
    orderBy?: ProfilePhoneOrderByWithRelationInput | ProfilePhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfilePhones.
     */
    cursor?: ProfilePhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfilePhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfilePhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfilePhones.
     */
    distinct?: ProfilePhoneScalarFieldEnum | ProfilePhoneScalarFieldEnum[]
  }

  /**
   * ProfilePhone findFirstOrThrow
   */
  export type ProfilePhoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilePhone
     */
    select?: ProfilePhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfilePhone
     */
    omit?: ProfilePhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilePhoneInclude<ExtArgs> | null
    /**
     * Filter, which ProfilePhone to fetch.
     */
    where?: ProfilePhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfilePhones to fetch.
     */
    orderBy?: ProfilePhoneOrderByWithRelationInput | ProfilePhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfilePhones.
     */
    cursor?: ProfilePhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfilePhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfilePhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfilePhones.
     */
    distinct?: ProfilePhoneScalarFieldEnum | ProfilePhoneScalarFieldEnum[]
  }

  /**
   * ProfilePhone findMany
   */
  export type ProfilePhoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilePhone
     */
    select?: ProfilePhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfilePhone
     */
    omit?: ProfilePhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilePhoneInclude<ExtArgs> | null
    /**
     * Filter, which ProfilePhones to fetch.
     */
    where?: ProfilePhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfilePhones to fetch.
     */
    orderBy?: ProfilePhoneOrderByWithRelationInput | ProfilePhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfilePhones.
     */
    cursor?: ProfilePhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfilePhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfilePhones.
     */
    skip?: number
    distinct?: ProfilePhoneScalarFieldEnum | ProfilePhoneScalarFieldEnum[]
  }

  /**
   * ProfilePhone create
   */
  export type ProfilePhoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilePhone
     */
    select?: ProfilePhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfilePhone
     */
    omit?: ProfilePhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilePhoneInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfilePhone.
     */
    data: XOR<ProfilePhoneCreateInput, ProfilePhoneUncheckedCreateInput>
  }

  /**
   * ProfilePhone createMany
   */
  export type ProfilePhoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfilePhones.
     */
    data: ProfilePhoneCreateManyInput | ProfilePhoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfilePhone update
   */
  export type ProfilePhoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilePhone
     */
    select?: ProfilePhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfilePhone
     */
    omit?: ProfilePhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilePhoneInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfilePhone.
     */
    data: XOR<ProfilePhoneUpdateInput, ProfilePhoneUncheckedUpdateInput>
    /**
     * Choose, which ProfilePhone to update.
     */
    where: ProfilePhoneWhereUniqueInput
  }

  /**
   * ProfilePhone updateMany
   */
  export type ProfilePhoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfilePhones.
     */
    data: XOR<ProfilePhoneUpdateManyMutationInput, ProfilePhoneUncheckedUpdateManyInput>
    /**
     * Filter which ProfilePhones to update
     */
    where?: ProfilePhoneWhereInput
    /**
     * Limit how many ProfilePhones to update.
     */
    limit?: number
  }

  /**
   * ProfilePhone upsert
   */
  export type ProfilePhoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilePhone
     */
    select?: ProfilePhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfilePhone
     */
    omit?: ProfilePhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilePhoneInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfilePhone to update in case it exists.
     */
    where: ProfilePhoneWhereUniqueInput
    /**
     * In case the ProfilePhone found by the `where` argument doesn't exist, create a new ProfilePhone with this data.
     */
    create: XOR<ProfilePhoneCreateInput, ProfilePhoneUncheckedCreateInput>
    /**
     * In case the ProfilePhone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfilePhoneUpdateInput, ProfilePhoneUncheckedUpdateInput>
  }

  /**
   * ProfilePhone delete
   */
  export type ProfilePhoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilePhone
     */
    select?: ProfilePhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfilePhone
     */
    omit?: ProfilePhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilePhoneInclude<ExtArgs> | null
    /**
     * Filter which ProfilePhone to delete.
     */
    where: ProfilePhoneWhereUniqueInput
  }

  /**
   * ProfilePhone deleteMany
   */
  export type ProfilePhoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfilePhones to delete
     */
    where?: ProfilePhoneWhereInput
    /**
     * Limit how many ProfilePhones to delete.
     */
    limit?: number
  }

  /**
   * ProfilePhone without action
   */
  export type ProfilePhoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilePhone
     */
    select?: ProfilePhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfilePhone
     */
    omit?: ProfilePhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilePhoneInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    account_id: string | null
    client_type: $Enums.ClientType | null
    name: string | null
    company_name: string | null
    tax_id: string | null
    website: string | null
    notes: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    account_id: string | null
    client_type: $Enums.ClientType | null
    name: string | null
    company_name: string | null
    tax_id: string | null
    website: string | null
    notes: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    account_id: number
    client_type: number
    name: number
    company_name: number
    tax_id: number
    website: number
    notes: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    account_id?: true
    client_type?: true
    name?: true
    company_name?: true
    tax_id?: true
    website?: true
    notes?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    account_id?: true
    client_type?: true
    name?: true
    company_name?: true
    tax_id?: true
    website?: true
    notes?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    account_id?: true
    client_type?: true
    name?: true
    company_name?: true
    tax_id?: true
    website?: true
    notes?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    account_id: string
    client_type: $Enums.ClientType
    name: string
    company_name: string | null
    tax_id: string | null
    website: string | null
    notes: string | null
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    client_type?: boolean
    name?: boolean
    company_name?: boolean
    tax_id?: boolean
    website?: boolean
    notes?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    billings?: boolean | Client$billingsArgs<ExtArgs>
    phones?: boolean | Client$phonesArgs<ExtArgs>
    emails?: boolean | Client$emailsArgs<ExtArgs>
    addresses?: boolean | Client$addressesArgs<ExtArgs>
    ClientCompany?: boolean | Client$ClientCompanyArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>



  export type ClientSelectScalar = {
    id?: boolean
    account_id?: boolean
    client_type?: boolean
    name?: boolean
    company_name?: boolean
    tax_id?: boolean
    website?: boolean
    notes?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "account_id" | "client_type" | "name" | "company_name" | "tax_id" | "website" | "notes" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    billings?: boolean | Client$billingsArgs<ExtArgs>
    phones?: boolean | Client$phonesArgs<ExtArgs>
    emails?: boolean | Client$emailsArgs<ExtArgs>
    addresses?: boolean | Client$addressesArgs<ExtArgs>
    ClientCompany?: boolean | Client$ClientCompanyArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      billings: Prisma.$BillingPayload<ExtArgs>[]
      phones: Prisma.$ClientPhonePayload<ExtArgs>[]
      emails: Prisma.$ClientEmailPayload<ExtArgs>[]
      addresses: Prisma.$ClientAddressPayload<ExtArgs>[]
      ClientCompany: Prisma.$ClientCompanyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      account_id: string
      client_type: $Enums.ClientType
      name: string
      company_name: string | null
      tax_id: string | null
      website: string | null
      notes: string | null
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    billings<T extends Client$billingsArgs<ExtArgs> = {}>(args?: Subset<T, Client$billingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    phones<T extends Client$phonesArgs<ExtArgs> = {}>(args?: Subset<T, Client$phonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPhonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emails<T extends Client$emailsArgs<ExtArgs> = {}>(args?: Subset<T, Client$emailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientEmailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addresses<T extends Client$addressesArgs<ExtArgs> = {}>(args?: Subset<T, Client$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ClientCompany<T extends Client$ClientCompanyArgs<ExtArgs> = {}>(args?: Subset<T, Client$ClientCompanyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientCompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly account_id: FieldRef<"Client", 'String'>
    readonly client_type: FieldRef<"Client", 'ClientType'>
    readonly name: FieldRef<"Client", 'String'>
    readonly company_name: FieldRef<"Client", 'String'>
    readonly tax_id: FieldRef<"Client", 'String'>
    readonly website: FieldRef<"Client", 'String'>
    readonly notes: FieldRef<"Client", 'String'>
    readonly is_active: FieldRef<"Client", 'Boolean'>
    readonly created_at: FieldRef<"Client", 'DateTime'>
    readonly updated_at: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.billings
   */
  export type Client$billingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing
     */
    select?: BillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing
     */
    omit?: BillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInclude<ExtArgs> | null
    where?: BillingWhereInput
    orderBy?: BillingOrderByWithRelationInput | BillingOrderByWithRelationInput[]
    cursor?: BillingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillingScalarFieldEnum | BillingScalarFieldEnum[]
  }

  /**
   * Client.phones
   */
  export type Client$phonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPhone
     */
    select?: ClientPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPhone
     */
    omit?: ClientPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPhoneInclude<ExtArgs> | null
    where?: ClientPhoneWhereInput
    orderBy?: ClientPhoneOrderByWithRelationInput | ClientPhoneOrderByWithRelationInput[]
    cursor?: ClientPhoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientPhoneScalarFieldEnum | ClientPhoneScalarFieldEnum[]
  }

  /**
   * Client.emails
   */
  export type Client$emailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEmail
     */
    select?: ClientEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEmail
     */
    omit?: ClientEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEmailInclude<ExtArgs> | null
    where?: ClientEmailWhereInput
    orderBy?: ClientEmailOrderByWithRelationInput | ClientEmailOrderByWithRelationInput[]
    cursor?: ClientEmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientEmailScalarFieldEnum | ClientEmailScalarFieldEnum[]
  }

  /**
   * Client.addresses
   */
  export type Client$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressInclude<ExtArgs> | null
    where?: ClientAddressWhereInput
    orderBy?: ClientAddressOrderByWithRelationInput | ClientAddressOrderByWithRelationInput[]
    cursor?: ClientAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientAddressScalarFieldEnum | ClientAddressScalarFieldEnum[]
  }

  /**
   * Client.ClientCompany
   */
  export type Client$ClientCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompany
     */
    select?: ClientCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompany
     */
    omit?: ClientCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyInclude<ExtArgs> | null
    where?: ClientCompanyWhereInput
    orderBy?: ClientCompanyOrderByWithRelationInput | ClientCompanyOrderByWithRelationInput[]
    cursor?: ClientCompanyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientCompanyScalarFieldEnum | ClientCompanyScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model ClientPhone
   */

  export type AggregateClientPhone = {
    _count: ClientPhoneCountAggregateOutputType | null
    _min: ClientPhoneMinAggregateOutputType | null
    _max: ClientPhoneMaxAggregateOutputType | null
  }

  export type ClientPhoneMinAggregateOutputType = {
    id: string | null
    client_id: string | null
    phone_number: string | null
    type: string | null
    is_primary: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientPhoneMaxAggregateOutputType = {
    id: string | null
    client_id: string | null
    phone_number: string | null
    type: string | null
    is_primary: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientPhoneCountAggregateOutputType = {
    id: number
    client_id: number
    phone_number: number
    type: number
    is_primary: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ClientPhoneMinAggregateInputType = {
    id?: true
    client_id?: true
    phone_number?: true
    type?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientPhoneMaxAggregateInputType = {
    id?: true
    client_id?: true
    phone_number?: true
    type?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientPhoneCountAggregateInputType = {
    id?: true
    client_id?: true
    phone_number?: true
    type?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ClientPhoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientPhone to aggregate.
     */
    where?: ClientPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPhones to fetch.
     */
    orderBy?: ClientPhoneOrderByWithRelationInput | ClientPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientPhones
    **/
    _count?: true | ClientPhoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientPhoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientPhoneMaxAggregateInputType
  }

  export type GetClientPhoneAggregateType<T extends ClientPhoneAggregateArgs> = {
        [P in keyof T & keyof AggregateClientPhone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientPhone[P]>
      : GetScalarType<T[P], AggregateClientPhone[P]>
  }




  export type ClientPhoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientPhoneWhereInput
    orderBy?: ClientPhoneOrderByWithAggregationInput | ClientPhoneOrderByWithAggregationInput[]
    by: ClientPhoneScalarFieldEnum[] | ClientPhoneScalarFieldEnum
    having?: ClientPhoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientPhoneCountAggregateInputType | true
    _min?: ClientPhoneMinAggregateInputType
    _max?: ClientPhoneMaxAggregateInputType
  }

  export type ClientPhoneGroupByOutputType = {
    id: string
    client_id: string
    phone_number: string
    type: string
    is_primary: boolean
    created_at: Date
    updated_at: Date
    _count: ClientPhoneCountAggregateOutputType | null
    _min: ClientPhoneMinAggregateOutputType | null
    _max: ClientPhoneMaxAggregateOutputType | null
  }

  type GetClientPhoneGroupByPayload<T extends ClientPhoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientPhoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientPhoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientPhoneGroupByOutputType[P]>
            : GetScalarType<T[P], ClientPhoneGroupByOutputType[P]>
        }
      >
    >


  export type ClientPhoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    phone_number?: boolean
    type?: boolean
    is_primary?: boolean
    created_at?: boolean
    updated_at?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientPhone"]>



  export type ClientPhoneSelectScalar = {
    id?: boolean
    client_id?: boolean
    phone_number?: boolean
    type?: boolean
    is_primary?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ClientPhoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "client_id" | "phone_number" | "type" | "is_primary" | "created_at" | "updated_at", ExtArgs["result"]["clientPhone"]>
  export type ClientPhoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $ClientPhonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientPhone"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      client_id: string
      phone_number: string
      type: string
      is_primary: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["clientPhone"]>
    composites: {}
  }

  type ClientPhoneGetPayload<S extends boolean | null | undefined | ClientPhoneDefaultArgs> = $Result.GetResult<Prisma.$ClientPhonePayload, S>

  type ClientPhoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientPhoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientPhoneCountAggregateInputType | true
    }

  export interface ClientPhoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientPhone'], meta: { name: 'ClientPhone' } }
    /**
     * Find zero or one ClientPhone that matches the filter.
     * @param {ClientPhoneFindUniqueArgs} args - Arguments to find a ClientPhone
     * @example
     * // Get one ClientPhone
     * const clientPhone = await prisma.clientPhone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientPhoneFindUniqueArgs>(args: SelectSubset<T, ClientPhoneFindUniqueArgs<ExtArgs>>): Prisma__ClientPhoneClient<$Result.GetResult<Prisma.$ClientPhonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientPhone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientPhoneFindUniqueOrThrowArgs} args - Arguments to find a ClientPhone
     * @example
     * // Get one ClientPhone
     * const clientPhone = await prisma.clientPhone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientPhoneFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientPhoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientPhoneClient<$Result.GetResult<Prisma.$ClientPhonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientPhone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPhoneFindFirstArgs} args - Arguments to find a ClientPhone
     * @example
     * // Get one ClientPhone
     * const clientPhone = await prisma.clientPhone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientPhoneFindFirstArgs>(args?: SelectSubset<T, ClientPhoneFindFirstArgs<ExtArgs>>): Prisma__ClientPhoneClient<$Result.GetResult<Prisma.$ClientPhonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientPhone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPhoneFindFirstOrThrowArgs} args - Arguments to find a ClientPhone
     * @example
     * // Get one ClientPhone
     * const clientPhone = await prisma.clientPhone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientPhoneFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientPhoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientPhoneClient<$Result.GetResult<Prisma.$ClientPhonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientPhones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPhoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientPhones
     * const clientPhones = await prisma.clientPhone.findMany()
     * 
     * // Get first 10 ClientPhones
     * const clientPhones = await prisma.clientPhone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientPhoneWithIdOnly = await prisma.clientPhone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientPhoneFindManyArgs>(args?: SelectSubset<T, ClientPhoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPhonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientPhone.
     * @param {ClientPhoneCreateArgs} args - Arguments to create a ClientPhone.
     * @example
     * // Create one ClientPhone
     * const ClientPhone = await prisma.clientPhone.create({
     *   data: {
     *     // ... data to create a ClientPhone
     *   }
     * })
     * 
     */
    create<T extends ClientPhoneCreateArgs>(args: SelectSubset<T, ClientPhoneCreateArgs<ExtArgs>>): Prisma__ClientPhoneClient<$Result.GetResult<Prisma.$ClientPhonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientPhones.
     * @param {ClientPhoneCreateManyArgs} args - Arguments to create many ClientPhones.
     * @example
     * // Create many ClientPhones
     * const clientPhone = await prisma.clientPhone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientPhoneCreateManyArgs>(args?: SelectSubset<T, ClientPhoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientPhone.
     * @param {ClientPhoneDeleteArgs} args - Arguments to delete one ClientPhone.
     * @example
     * // Delete one ClientPhone
     * const ClientPhone = await prisma.clientPhone.delete({
     *   where: {
     *     // ... filter to delete one ClientPhone
     *   }
     * })
     * 
     */
    delete<T extends ClientPhoneDeleteArgs>(args: SelectSubset<T, ClientPhoneDeleteArgs<ExtArgs>>): Prisma__ClientPhoneClient<$Result.GetResult<Prisma.$ClientPhonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientPhone.
     * @param {ClientPhoneUpdateArgs} args - Arguments to update one ClientPhone.
     * @example
     * // Update one ClientPhone
     * const clientPhone = await prisma.clientPhone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientPhoneUpdateArgs>(args: SelectSubset<T, ClientPhoneUpdateArgs<ExtArgs>>): Prisma__ClientPhoneClient<$Result.GetResult<Prisma.$ClientPhonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientPhones.
     * @param {ClientPhoneDeleteManyArgs} args - Arguments to filter ClientPhones to delete.
     * @example
     * // Delete a few ClientPhones
     * const { count } = await prisma.clientPhone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientPhoneDeleteManyArgs>(args?: SelectSubset<T, ClientPhoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientPhones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPhoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientPhones
     * const clientPhone = await prisma.clientPhone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientPhoneUpdateManyArgs>(args: SelectSubset<T, ClientPhoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientPhone.
     * @param {ClientPhoneUpsertArgs} args - Arguments to update or create a ClientPhone.
     * @example
     * // Update or create a ClientPhone
     * const clientPhone = await prisma.clientPhone.upsert({
     *   create: {
     *     // ... data to create a ClientPhone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientPhone we want to update
     *   }
     * })
     */
    upsert<T extends ClientPhoneUpsertArgs>(args: SelectSubset<T, ClientPhoneUpsertArgs<ExtArgs>>): Prisma__ClientPhoneClient<$Result.GetResult<Prisma.$ClientPhonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientPhones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPhoneCountArgs} args - Arguments to filter ClientPhones to count.
     * @example
     * // Count the number of ClientPhones
     * const count = await prisma.clientPhone.count({
     *   where: {
     *     // ... the filter for the ClientPhones we want to count
     *   }
     * })
    **/
    count<T extends ClientPhoneCountArgs>(
      args?: Subset<T, ClientPhoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientPhoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientPhone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPhoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientPhoneAggregateArgs>(args: Subset<T, ClientPhoneAggregateArgs>): Prisma.PrismaPromise<GetClientPhoneAggregateType<T>>

    /**
     * Group by ClientPhone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPhoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientPhoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientPhoneGroupByArgs['orderBy'] }
        : { orderBy?: ClientPhoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientPhoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientPhoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientPhone model
   */
  readonly fields: ClientPhoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientPhone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientPhoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientPhone model
   */
  interface ClientPhoneFieldRefs {
    readonly id: FieldRef<"ClientPhone", 'String'>
    readonly client_id: FieldRef<"ClientPhone", 'String'>
    readonly phone_number: FieldRef<"ClientPhone", 'String'>
    readonly type: FieldRef<"ClientPhone", 'String'>
    readonly is_primary: FieldRef<"ClientPhone", 'Boolean'>
    readonly created_at: FieldRef<"ClientPhone", 'DateTime'>
    readonly updated_at: FieldRef<"ClientPhone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientPhone findUnique
   */
  export type ClientPhoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPhone
     */
    select?: ClientPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPhone
     */
    omit?: ClientPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPhoneInclude<ExtArgs> | null
    /**
     * Filter, which ClientPhone to fetch.
     */
    where: ClientPhoneWhereUniqueInput
  }

  /**
   * ClientPhone findUniqueOrThrow
   */
  export type ClientPhoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPhone
     */
    select?: ClientPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPhone
     */
    omit?: ClientPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPhoneInclude<ExtArgs> | null
    /**
     * Filter, which ClientPhone to fetch.
     */
    where: ClientPhoneWhereUniqueInput
  }

  /**
   * ClientPhone findFirst
   */
  export type ClientPhoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPhone
     */
    select?: ClientPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPhone
     */
    omit?: ClientPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPhoneInclude<ExtArgs> | null
    /**
     * Filter, which ClientPhone to fetch.
     */
    where?: ClientPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPhones to fetch.
     */
    orderBy?: ClientPhoneOrderByWithRelationInput | ClientPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientPhones.
     */
    cursor?: ClientPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientPhones.
     */
    distinct?: ClientPhoneScalarFieldEnum | ClientPhoneScalarFieldEnum[]
  }

  /**
   * ClientPhone findFirstOrThrow
   */
  export type ClientPhoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPhone
     */
    select?: ClientPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPhone
     */
    omit?: ClientPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPhoneInclude<ExtArgs> | null
    /**
     * Filter, which ClientPhone to fetch.
     */
    where?: ClientPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPhones to fetch.
     */
    orderBy?: ClientPhoneOrderByWithRelationInput | ClientPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientPhones.
     */
    cursor?: ClientPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientPhones.
     */
    distinct?: ClientPhoneScalarFieldEnum | ClientPhoneScalarFieldEnum[]
  }

  /**
   * ClientPhone findMany
   */
  export type ClientPhoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPhone
     */
    select?: ClientPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPhone
     */
    omit?: ClientPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPhoneInclude<ExtArgs> | null
    /**
     * Filter, which ClientPhones to fetch.
     */
    where?: ClientPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPhones to fetch.
     */
    orderBy?: ClientPhoneOrderByWithRelationInput | ClientPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientPhones.
     */
    cursor?: ClientPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPhones.
     */
    skip?: number
    distinct?: ClientPhoneScalarFieldEnum | ClientPhoneScalarFieldEnum[]
  }

  /**
   * ClientPhone create
   */
  export type ClientPhoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPhone
     */
    select?: ClientPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPhone
     */
    omit?: ClientPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPhoneInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientPhone.
     */
    data: XOR<ClientPhoneCreateInput, ClientPhoneUncheckedCreateInput>
  }

  /**
   * ClientPhone createMany
   */
  export type ClientPhoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientPhones.
     */
    data: ClientPhoneCreateManyInput | ClientPhoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientPhone update
   */
  export type ClientPhoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPhone
     */
    select?: ClientPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPhone
     */
    omit?: ClientPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPhoneInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientPhone.
     */
    data: XOR<ClientPhoneUpdateInput, ClientPhoneUncheckedUpdateInput>
    /**
     * Choose, which ClientPhone to update.
     */
    where: ClientPhoneWhereUniqueInput
  }

  /**
   * ClientPhone updateMany
   */
  export type ClientPhoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientPhones.
     */
    data: XOR<ClientPhoneUpdateManyMutationInput, ClientPhoneUncheckedUpdateManyInput>
    /**
     * Filter which ClientPhones to update
     */
    where?: ClientPhoneWhereInput
    /**
     * Limit how many ClientPhones to update.
     */
    limit?: number
  }

  /**
   * ClientPhone upsert
   */
  export type ClientPhoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPhone
     */
    select?: ClientPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPhone
     */
    omit?: ClientPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPhoneInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientPhone to update in case it exists.
     */
    where: ClientPhoneWhereUniqueInput
    /**
     * In case the ClientPhone found by the `where` argument doesn't exist, create a new ClientPhone with this data.
     */
    create: XOR<ClientPhoneCreateInput, ClientPhoneUncheckedCreateInput>
    /**
     * In case the ClientPhone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientPhoneUpdateInput, ClientPhoneUncheckedUpdateInput>
  }

  /**
   * ClientPhone delete
   */
  export type ClientPhoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPhone
     */
    select?: ClientPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPhone
     */
    omit?: ClientPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPhoneInclude<ExtArgs> | null
    /**
     * Filter which ClientPhone to delete.
     */
    where: ClientPhoneWhereUniqueInput
  }

  /**
   * ClientPhone deleteMany
   */
  export type ClientPhoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientPhones to delete
     */
    where?: ClientPhoneWhereInput
    /**
     * Limit how many ClientPhones to delete.
     */
    limit?: number
  }

  /**
   * ClientPhone without action
   */
  export type ClientPhoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPhone
     */
    select?: ClientPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPhone
     */
    omit?: ClientPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPhoneInclude<ExtArgs> | null
  }


  /**
   * Model ClientEmail
   */

  export type AggregateClientEmail = {
    _count: ClientEmailCountAggregateOutputType | null
    _min: ClientEmailMinAggregateOutputType | null
    _max: ClientEmailMaxAggregateOutputType | null
  }

  export type ClientEmailMinAggregateOutputType = {
    id: string | null
    client_id: string | null
    email: string | null
    type: string | null
    is_primary: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientEmailMaxAggregateOutputType = {
    id: string | null
    client_id: string | null
    email: string | null
    type: string | null
    is_primary: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientEmailCountAggregateOutputType = {
    id: number
    client_id: number
    email: number
    type: number
    is_primary: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ClientEmailMinAggregateInputType = {
    id?: true
    client_id?: true
    email?: true
    type?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientEmailMaxAggregateInputType = {
    id?: true
    client_id?: true
    email?: true
    type?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientEmailCountAggregateInputType = {
    id?: true
    client_id?: true
    email?: true
    type?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ClientEmailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientEmail to aggregate.
     */
    where?: ClientEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientEmails to fetch.
     */
    orderBy?: ClientEmailOrderByWithRelationInput | ClientEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientEmails
    **/
    _count?: true | ClientEmailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientEmailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientEmailMaxAggregateInputType
  }

  export type GetClientEmailAggregateType<T extends ClientEmailAggregateArgs> = {
        [P in keyof T & keyof AggregateClientEmail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientEmail[P]>
      : GetScalarType<T[P], AggregateClientEmail[P]>
  }




  export type ClientEmailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientEmailWhereInput
    orderBy?: ClientEmailOrderByWithAggregationInput | ClientEmailOrderByWithAggregationInput[]
    by: ClientEmailScalarFieldEnum[] | ClientEmailScalarFieldEnum
    having?: ClientEmailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientEmailCountAggregateInputType | true
    _min?: ClientEmailMinAggregateInputType
    _max?: ClientEmailMaxAggregateInputType
  }

  export type ClientEmailGroupByOutputType = {
    id: string
    client_id: string
    email: string
    type: string
    is_primary: boolean
    created_at: Date
    updated_at: Date
    _count: ClientEmailCountAggregateOutputType | null
    _min: ClientEmailMinAggregateOutputType | null
    _max: ClientEmailMaxAggregateOutputType | null
  }

  type GetClientEmailGroupByPayload<T extends ClientEmailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientEmailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientEmailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientEmailGroupByOutputType[P]>
            : GetScalarType<T[P], ClientEmailGroupByOutputType[P]>
        }
      >
    >


  export type ClientEmailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    email?: boolean
    type?: boolean
    is_primary?: boolean
    created_at?: boolean
    updated_at?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientEmail"]>



  export type ClientEmailSelectScalar = {
    id?: boolean
    client_id?: boolean
    email?: boolean
    type?: boolean
    is_primary?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ClientEmailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "client_id" | "email" | "type" | "is_primary" | "created_at" | "updated_at", ExtArgs["result"]["clientEmail"]>
  export type ClientEmailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $ClientEmailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientEmail"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      client_id: string
      email: string
      type: string
      is_primary: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["clientEmail"]>
    composites: {}
  }

  type ClientEmailGetPayload<S extends boolean | null | undefined | ClientEmailDefaultArgs> = $Result.GetResult<Prisma.$ClientEmailPayload, S>

  type ClientEmailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientEmailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientEmailCountAggregateInputType | true
    }

  export interface ClientEmailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientEmail'], meta: { name: 'ClientEmail' } }
    /**
     * Find zero or one ClientEmail that matches the filter.
     * @param {ClientEmailFindUniqueArgs} args - Arguments to find a ClientEmail
     * @example
     * // Get one ClientEmail
     * const clientEmail = await prisma.clientEmail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientEmailFindUniqueArgs>(args: SelectSubset<T, ClientEmailFindUniqueArgs<ExtArgs>>): Prisma__ClientEmailClient<$Result.GetResult<Prisma.$ClientEmailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientEmail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientEmailFindUniqueOrThrowArgs} args - Arguments to find a ClientEmail
     * @example
     * // Get one ClientEmail
     * const clientEmail = await prisma.clientEmail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientEmailFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientEmailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientEmailClient<$Result.GetResult<Prisma.$ClientEmailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientEmail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEmailFindFirstArgs} args - Arguments to find a ClientEmail
     * @example
     * // Get one ClientEmail
     * const clientEmail = await prisma.clientEmail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientEmailFindFirstArgs>(args?: SelectSubset<T, ClientEmailFindFirstArgs<ExtArgs>>): Prisma__ClientEmailClient<$Result.GetResult<Prisma.$ClientEmailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientEmail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEmailFindFirstOrThrowArgs} args - Arguments to find a ClientEmail
     * @example
     * // Get one ClientEmail
     * const clientEmail = await prisma.clientEmail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientEmailFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientEmailFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientEmailClient<$Result.GetResult<Prisma.$ClientEmailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientEmails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEmailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientEmails
     * const clientEmails = await prisma.clientEmail.findMany()
     * 
     * // Get first 10 ClientEmails
     * const clientEmails = await prisma.clientEmail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientEmailWithIdOnly = await prisma.clientEmail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientEmailFindManyArgs>(args?: SelectSubset<T, ClientEmailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientEmailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientEmail.
     * @param {ClientEmailCreateArgs} args - Arguments to create a ClientEmail.
     * @example
     * // Create one ClientEmail
     * const ClientEmail = await prisma.clientEmail.create({
     *   data: {
     *     // ... data to create a ClientEmail
     *   }
     * })
     * 
     */
    create<T extends ClientEmailCreateArgs>(args: SelectSubset<T, ClientEmailCreateArgs<ExtArgs>>): Prisma__ClientEmailClient<$Result.GetResult<Prisma.$ClientEmailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientEmails.
     * @param {ClientEmailCreateManyArgs} args - Arguments to create many ClientEmails.
     * @example
     * // Create many ClientEmails
     * const clientEmail = await prisma.clientEmail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientEmailCreateManyArgs>(args?: SelectSubset<T, ClientEmailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientEmail.
     * @param {ClientEmailDeleteArgs} args - Arguments to delete one ClientEmail.
     * @example
     * // Delete one ClientEmail
     * const ClientEmail = await prisma.clientEmail.delete({
     *   where: {
     *     // ... filter to delete one ClientEmail
     *   }
     * })
     * 
     */
    delete<T extends ClientEmailDeleteArgs>(args: SelectSubset<T, ClientEmailDeleteArgs<ExtArgs>>): Prisma__ClientEmailClient<$Result.GetResult<Prisma.$ClientEmailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientEmail.
     * @param {ClientEmailUpdateArgs} args - Arguments to update one ClientEmail.
     * @example
     * // Update one ClientEmail
     * const clientEmail = await prisma.clientEmail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientEmailUpdateArgs>(args: SelectSubset<T, ClientEmailUpdateArgs<ExtArgs>>): Prisma__ClientEmailClient<$Result.GetResult<Prisma.$ClientEmailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientEmails.
     * @param {ClientEmailDeleteManyArgs} args - Arguments to filter ClientEmails to delete.
     * @example
     * // Delete a few ClientEmails
     * const { count } = await prisma.clientEmail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientEmailDeleteManyArgs>(args?: SelectSubset<T, ClientEmailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEmailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientEmails
     * const clientEmail = await prisma.clientEmail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientEmailUpdateManyArgs>(args: SelectSubset<T, ClientEmailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientEmail.
     * @param {ClientEmailUpsertArgs} args - Arguments to update or create a ClientEmail.
     * @example
     * // Update or create a ClientEmail
     * const clientEmail = await prisma.clientEmail.upsert({
     *   create: {
     *     // ... data to create a ClientEmail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientEmail we want to update
     *   }
     * })
     */
    upsert<T extends ClientEmailUpsertArgs>(args: SelectSubset<T, ClientEmailUpsertArgs<ExtArgs>>): Prisma__ClientEmailClient<$Result.GetResult<Prisma.$ClientEmailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEmailCountArgs} args - Arguments to filter ClientEmails to count.
     * @example
     * // Count the number of ClientEmails
     * const count = await prisma.clientEmail.count({
     *   where: {
     *     // ... the filter for the ClientEmails we want to count
     *   }
     * })
    **/
    count<T extends ClientEmailCountArgs>(
      args?: Subset<T, ClientEmailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientEmailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEmailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientEmailAggregateArgs>(args: Subset<T, ClientEmailAggregateArgs>): Prisma.PrismaPromise<GetClientEmailAggregateType<T>>

    /**
     * Group by ClientEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEmailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientEmailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientEmailGroupByArgs['orderBy'] }
        : { orderBy?: ClientEmailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientEmailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientEmailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientEmail model
   */
  readonly fields: ClientEmailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientEmail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientEmailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientEmail model
   */
  interface ClientEmailFieldRefs {
    readonly id: FieldRef<"ClientEmail", 'String'>
    readonly client_id: FieldRef<"ClientEmail", 'String'>
    readonly email: FieldRef<"ClientEmail", 'String'>
    readonly type: FieldRef<"ClientEmail", 'String'>
    readonly is_primary: FieldRef<"ClientEmail", 'Boolean'>
    readonly created_at: FieldRef<"ClientEmail", 'DateTime'>
    readonly updated_at: FieldRef<"ClientEmail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientEmail findUnique
   */
  export type ClientEmailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEmail
     */
    select?: ClientEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEmail
     */
    omit?: ClientEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEmailInclude<ExtArgs> | null
    /**
     * Filter, which ClientEmail to fetch.
     */
    where: ClientEmailWhereUniqueInput
  }

  /**
   * ClientEmail findUniqueOrThrow
   */
  export type ClientEmailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEmail
     */
    select?: ClientEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEmail
     */
    omit?: ClientEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEmailInclude<ExtArgs> | null
    /**
     * Filter, which ClientEmail to fetch.
     */
    where: ClientEmailWhereUniqueInput
  }

  /**
   * ClientEmail findFirst
   */
  export type ClientEmailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEmail
     */
    select?: ClientEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEmail
     */
    omit?: ClientEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEmailInclude<ExtArgs> | null
    /**
     * Filter, which ClientEmail to fetch.
     */
    where?: ClientEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientEmails to fetch.
     */
    orderBy?: ClientEmailOrderByWithRelationInput | ClientEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientEmails.
     */
    cursor?: ClientEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientEmails.
     */
    distinct?: ClientEmailScalarFieldEnum | ClientEmailScalarFieldEnum[]
  }

  /**
   * ClientEmail findFirstOrThrow
   */
  export type ClientEmailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEmail
     */
    select?: ClientEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEmail
     */
    omit?: ClientEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEmailInclude<ExtArgs> | null
    /**
     * Filter, which ClientEmail to fetch.
     */
    where?: ClientEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientEmails to fetch.
     */
    orderBy?: ClientEmailOrderByWithRelationInput | ClientEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientEmails.
     */
    cursor?: ClientEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientEmails.
     */
    distinct?: ClientEmailScalarFieldEnum | ClientEmailScalarFieldEnum[]
  }

  /**
   * ClientEmail findMany
   */
  export type ClientEmailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEmail
     */
    select?: ClientEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEmail
     */
    omit?: ClientEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEmailInclude<ExtArgs> | null
    /**
     * Filter, which ClientEmails to fetch.
     */
    where?: ClientEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientEmails to fetch.
     */
    orderBy?: ClientEmailOrderByWithRelationInput | ClientEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientEmails.
     */
    cursor?: ClientEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientEmails.
     */
    skip?: number
    distinct?: ClientEmailScalarFieldEnum | ClientEmailScalarFieldEnum[]
  }

  /**
   * ClientEmail create
   */
  export type ClientEmailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEmail
     */
    select?: ClientEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEmail
     */
    omit?: ClientEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEmailInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientEmail.
     */
    data: XOR<ClientEmailCreateInput, ClientEmailUncheckedCreateInput>
  }

  /**
   * ClientEmail createMany
   */
  export type ClientEmailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientEmails.
     */
    data: ClientEmailCreateManyInput | ClientEmailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientEmail update
   */
  export type ClientEmailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEmail
     */
    select?: ClientEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEmail
     */
    omit?: ClientEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEmailInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientEmail.
     */
    data: XOR<ClientEmailUpdateInput, ClientEmailUncheckedUpdateInput>
    /**
     * Choose, which ClientEmail to update.
     */
    where: ClientEmailWhereUniqueInput
  }

  /**
   * ClientEmail updateMany
   */
  export type ClientEmailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientEmails.
     */
    data: XOR<ClientEmailUpdateManyMutationInput, ClientEmailUncheckedUpdateManyInput>
    /**
     * Filter which ClientEmails to update
     */
    where?: ClientEmailWhereInput
    /**
     * Limit how many ClientEmails to update.
     */
    limit?: number
  }

  /**
   * ClientEmail upsert
   */
  export type ClientEmailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEmail
     */
    select?: ClientEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEmail
     */
    omit?: ClientEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEmailInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientEmail to update in case it exists.
     */
    where: ClientEmailWhereUniqueInput
    /**
     * In case the ClientEmail found by the `where` argument doesn't exist, create a new ClientEmail with this data.
     */
    create: XOR<ClientEmailCreateInput, ClientEmailUncheckedCreateInput>
    /**
     * In case the ClientEmail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientEmailUpdateInput, ClientEmailUncheckedUpdateInput>
  }

  /**
   * ClientEmail delete
   */
  export type ClientEmailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEmail
     */
    select?: ClientEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEmail
     */
    omit?: ClientEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEmailInclude<ExtArgs> | null
    /**
     * Filter which ClientEmail to delete.
     */
    where: ClientEmailWhereUniqueInput
  }

  /**
   * ClientEmail deleteMany
   */
  export type ClientEmailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientEmails to delete
     */
    where?: ClientEmailWhereInput
    /**
     * Limit how many ClientEmails to delete.
     */
    limit?: number
  }

  /**
   * ClientEmail without action
   */
  export type ClientEmailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEmail
     */
    select?: ClientEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEmail
     */
    omit?: ClientEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEmailInclude<ExtArgs> | null
  }


  /**
   * Model ClientAddress
   */

  export type AggregateClientAddress = {
    _count: ClientAddressCountAggregateOutputType | null
    _min: ClientAddressMinAggregateOutputType | null
    _max: ClientAddressMaxAggregateOutputType | null
  }

  export type ClientAddressMinAggregateOutputType = {
    id: string | null
    client_id: string | null
    type: string | null
    street: string | null
    suite: string | null
    city: string | null
    state: string | null
    zip_code: string | null
    country: string | null
    is_primary: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientAddressMaxAggregateOutputType = {
    id: string | null
    client_id: string | null
    type: string | null
    street: string | null
    suite: string | null
    city: string | null
    state: string | null
    zip_code: string | null
    country: string | null
    is_primary: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientAddressCountAggregateOutputType = {
    id: number
    client_id: number
    type: number
    street: number
    suite: number
    city: number
    state: number
    zip_code: number
    country: number
    is_primary: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ClientAddressMinAggregateInputType = {
    id?: true
    client_id?: true
    type?: true
    street?: true
    suite?: true
    city?: true
    state?: true
    zip_code?: true
    country?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientAddressMaxAggregateInputType = {
    id?: true
    client_id?: true
    type?: true
    street?: true
    suite?: true
    city?: true
    state?: true
    zip_code?: true
    country?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientAddressCountAggregateInputType = {
    id?: true
    client_id?: true
    type?: true
    street?: true
    suite?: true
    city?: true
    state?: true
    zip_code?: true
    country?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ClientAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientAddress to aggregate.
     */
    where?: ClientAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientAddresses to fetch.
     */
    orderBy?: ClientAddressOrderByWithRelationInput | ClientAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientAddresses
    **/
    _count?: true | ClientAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientAddressMaxAggregateInputType
  }

  export type GetClientAddressAggregateType<T extends ClientAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateClientAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientAddress[P]>
      : GetScalarType<T[P], AggregateClientAddress[P]>
  }




  export type ClientAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientAddressWhereInput
    orderBy?: ClientAddressOrderByWithAggregationInput | ClientAddressOrderByWithAggregationInput[]
    by: ClientAddressScalarFieldEnum[] | ClientAddressScalarFieldEnum
    having?: ClientAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientAddressCountAggregateInputType | true
    _min?: ClientAddressMinAggregateInputType
    _max?: ClientAddressMaxAggregateInputType
  }

  export type ClientAddressGroupByOutputType = {
    id: string
    client_id: string
    type: string
    street: string
    suite: string | null
    city: string
    state: string
    zip_code: string
    country: string
    is_primary: boolean
    created_at: Date
    updated_at: Date
    _count: ClientAddressCountAggregateOutputType | null
    _min: ClientAddressMinAggregateOutputType | null
    _max: ClientAddressMaxAggregateOutputType | null
  }

  type GetClientAddressGroupByPayload<T extends ClientAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientAddressGroupByOutputType[P]>
            : GetScalarType<T[P], ClientAddressGroupByOutputType[P]>
        }
      >
    >


  export type ClientAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    type?: boolean
    street?: boolean
    suite?: boolean
    city?: boolean
    state?: boolean
    zip_code?: boolean
    country?: boolean
    is_primary?: boolean
    created_at?: boolean
    updated_at?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientAddress"]>



  export type ClientAddressSelectScalar = {
    id?: boolean
    client_id?: boolean
    type?: boolean
    street?: boolean
    suite?: boolean
    city?: boolean
    state?: boolean
    zip_code?: boolean
    country?: boolean
    is_primary?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ClientAddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "client_id" | "type" | "street" | "suite" | "city" | "state" | "zip_code" | "country" | "is_primary" | "created_at" | "updated_at", ExtArgs["result"]["clientAddress"]>
  export type ClientAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $ClientAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientAddress"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      client_id: string
      type: string
      street: string
      suite: string | null
      city: string
      state: string
      zip_code: string
      country: string
      is_primary: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["clientAddress"]>
    composites: {}
  }

  type ClientAddressGetPayload<S extends boolean | null | undefined | ClientAddressDefaultArgs> = $Result.GetResult<Prisma.$ClientAddressPayload, S>

  type ClientAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientAddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientAddressCountAggregateInputType | true
    }

  export interface ClientAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientAddress'], meta: { name: 'ClientAddress' } }
    /**
     * Find zero or one ClientAddress that matches the filter.
     * @param {ClientAddressFindUniqueArgs} args - Arguments to find a ClientAddress
     * @example
     * // Get one ClientAddress
     * const clientAddress = await prisma.clientAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientAddressFindUniqueArgs>(args: SelectSubset<T, ClientAddressFindUniqueArgs<ExtArgs>>): Prisma__ClientAddressClient<$Result.GetResult<Prisma.$ClientAddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientAddress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientAddressFindUniqueOrThrowArgs} args - Arguments to find a ClientAddress
     * @example
     * // Get one ClientAddress
     * const clientAddress = await prisma.clientAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientAddressClient<$Result.GetResult<Prisma.$ClientAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAddressFindFirstArgs} args - Arguments to find a ClientAddress
     * @example
     * // Get one ClientAddress
     * const clientAddress = await prisma.clientAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientAddressFindFirstArgs>(args?: SelectSubset<T, ClientAddressFindFirstArgs<ExtArgs>>): Prisma__ClientAddressClient<$Result.GetResult<Prisma.$ClientAddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAddressFindFirstOrThrowArgs} args - Arguments to find a ClientAddress
     * @example
     * // Get one ClientAddress
     * const clientAddress = await prisma.clientAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientAddressClient<$Result.GetResult<Prisma.$ClientAddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientAddresses
     * const clientAddresses = await prisma.clientAddress.findMany()
     * 
     * // Get first 10 ClientAddresses
     * const clientAddresses = await prisma.clientAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientAddressWithIdOnly = await prisma.clientAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientAddressFindManyArgs>(args?: SelectSubset<T, ClientAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientAddress.
     * @param {ClientAddressCreateArgs} args - Arguments to create a ClientAddress.
     * @example
     * // Create one ClientAddress
     * const ClientAddress = await prisma.clientAddress.create({
     *   data: {
     *     // ... data to create a ClientAddress
     *   }
     * })
     * 
     */
    create<T extends ClientAddressCreateArgs>(args: SelectSubset<T, ClientAddressCreateArgs<ExtArgs>>): Prisma__ClientAddressClient<$Result.GetResult<Prisma.$ClientAddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientAddresses.
     * @param {ClientAddressCreateManyArgs} args - Arguments to create many ClientAddresses.
     * @example
     * // Create many ClientAddresses
     * const clientAddress = await prisma.clientAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientAddressCreateManyArgs>(args?: SelectSubset<T, ClientAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientAddress.
     * @param {ClientAddressDeleteArgs} args - Arguments to delete one ClientAddress.
     * @example
     * // Delete one ClientAddress
     * const ClientAddress = await prisma.clientAddress.delete({
     *   where: {
     *     // ... filter to delete one ClientAddress
     *   }
     * })
     * 
     */
    delete<T extends ClientAddressDeleteArgs>(args: SelectSubset<T, ClientAddressDeleteArgs<ExtArgs>>): Prisma__ClientAddressClient<$Result.GetResult<Prisma.$ClientAddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientAddress.
     * @param {ClientAddressUpdateArgs} args - Arguments to update one ClientAddress.
     * @example
     * // Update one ClientAddress
     * const clientAddress = await prisma.clientAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientAddressUpdateArgs>(args: SelectSubset<T, ClientAddressUpdateArgs<ExtArgs>>): Prisma__ClientAddressClient<$Result.GetResult<Prisma.$ClientAddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientAddresses.
     * @param {ClientAddressDeleteManyArgs} args - Arguments to filter ClientAddresses to delete.
     * @example
     * // Delete a few ClientAddresses
     * const { count } = await prisma.clientAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientAddressDeleteManyArgs>(args?: SelectSubset<T, ClientAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientAddresses
     * const clientAddress = await prisma.clientAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientAddressUpdateManyArgs>(args: SelectSubset<T, ClientAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientAddress.
     * @param {ClientAddressUpsertArgs} args - Arguments to update or create a ClientAddress.
     * @example
     * // Update or create a ClientAddress
     * const clientAddress = await prisma.clientAddress.upsert({
     *   create: {
     *     // ... data to create a ClientAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientAddress we want to update
     *   }
     * })
     */
    upsert<T extends ClientAddressUpsertArgs>(args: SelectSubset<T, ClientAddressUpsertArgs<ExtArgs>>): Prisma__ClientAddressClient<$Result.GetResult<Prisma.$ClientAddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAddressCountArgs} args - Arguments to filter ClientAddresses to count.
     * @example
     * // Count the number of ClientAddresses
     * const count = await prisma.clientAddress.count({
     *   where: {
     *     // ... the filter for the ClientAddresses we want to count
     *   }
     * })
    **/
    count<T extends ClientAddressCountArgs>(
      args?: Subset<T, ClientAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAddressAggregateArgs>(args: Subset<T, ClientAddressAggregateArgs>): Prisma.PrismaPromise<GetClientAddressAggregateType<T>>

    /**
     * Group by ClientAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientAddressGroupByArgs['orderBy'] }
        : { orderBy?: ClientAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientAddress model
   */
  readonly fields: ClientAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientAddress model
   */
  interface ClientAddressFieldRefs {
    readonly id: FieldRef<"ClientAddress", 'String'>
    readonly client_id: FieldRef<"ClientAddress", 'String'>
    readonly type: FieldRef<"ClientAddress", 'String'>
    readonly street: FieldRef<"ClientAddress", 'String'>
    readonly suite: FieldRef<"ClientAddress", 'String'>
    readonly city: FieldRef<"ClientAddress", 'String'>
    readonly state: FieldRef<"ClientAddress", 'String'>
    readonly zip_code: FieldRef<"ClientAddress", 'String'>
    readonly country: FieldRef<"ClientAddress", 'String'>
    readonly is_primary: FieldRef<"ClientAddress", 'Boolean'>
    readonly created_at: FieldRef<"ClientAddress", 'DateTime'>
    readonly updated_at: FieldRef<"ClientAddress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientAddress findUnique
   */
  export type ClientAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressInclude<ExtArgs> | null
    /**
     * Filter, which ClientAddress to fetch.
     */
    where: ClientAddressWhereUniqueInput
  }

  /**
   * ClientAddress findUniqueOrThrow
   */
  export type ClientAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressInclude<ExtArgs> | null
    /**
     * Filter, which ClientAddress to fetch.
     */
    where: ClientAddressWhereUniqueInput
  }

  /**
   * ClientAddress findFirst
   */
  export type ClientAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressInclude<ExtArgs> | null
    /**
     * Filter, which ClientAddress to fetch.
     */
    where?: ClientAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientAddresses to fetch.
     */
    orderBy?: ClientAddressOrderByWithRelationInput | ClientAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientAddresses.
     */
    cursor?: ClientAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientAddresses.
     */
    distinct?: ClientAddressScalarFieldEnum | ClientAddressScalarFieldEnum[]
  }

  /**
   * ClientAddress findFirstOrThrow
   */
  export type ClientAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressInclude<ExtArgs> | null
    /**
     * Filter, which ClientAddress to fetch.
     */
    where?: ClientAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientAddresses to fetch.
     */
    orderBy?: ClientAddressOrderByWithRelationInput | ClientAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientAddresses.
     */
    cursor?: ClientAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientAddresses.
     */
    distinct?: ClientAddressScalarFieldEnum | ClientAddressScalarFieldEnum[]
  }

  /**
   * ClientAddress findMany
   */
  export type ClientAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressInclude<ExtArgs> | null
    /**
     * Filter, which ClientAddresses to fetch.
     */
    where?: ClientAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientAddresses to fetch.
     */
    orderBy?: ClientAddressOrderByWithRelationInput | ClientAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientAddresses.
     */
    cursor?: ClientAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientAddresses.
     */
    skip?: number
    distinct?: ClientAddressScalarFieldEnum | ClientAddressScalarFieldEnum[]
  }

  /**
   * ClientAddress create
   */
  export type ClientAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientAddress.
     */
    data: XOR<ClientAddressCreateInput, ClientAddressUncheckedCreateInput>
  }

  /**
   * ClientAddress createMany
   */
  export type ClientAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientAddresses.
     */
    data: ClientAddressCreateManyInput | ClientAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientAddress update
   */
  export type ClientAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientAddress.
     */
    data: XOR<ClientAddressUpdateInput, ClientAddressUncheckedUpdateInput>
    /**
     * Choose, which ClientAddress to update.
     */
    where: ClientAddressWhereUniqueInput
  }

  /**
   * ClientAddress updateMany
   */
  export type ClientAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientAddresses.
     */
    data: XOR<ClientAddressUpdateManyMutationInput, ClientAddressUncheckedUpdateManyInput>
    /**
     * Filter which ClientAddresses to update
     */
    where?: ClientAddressWhereInput
    /**
     * Limit how many ClientAddresses to update.
     */
    limit?: number
  }

  /**
   * ClientAddress upsert
   */
  export type ClientAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientAddress to update in case it exists.
     */
    where: ClientAddressWhereUniqueInput
    /**
     * In case the ClientAddress found by the `where` argument doesn't exist, create a new ClientAddress with this data.
     */
    create: XOR<ClientAddressCreateInput, ClientAddressUncheckedCreateInput>
    /**
     * In case the ClientAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientAddressUpdateInput, ClientAddressUncheckedUpdateInput>
  }

  /**
   * ClientAddress delete
   */
  export type ClientAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressInclude<ExtArgs> | null
    /**
     * Filter which ClientAddress to delete.
     */
    where: ClientAddressWhereUniqueInput
  }

  /**
   * ClientAddress deleteMany
   */
  export type ClientAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientAddresses to delete
     */
    where?: ClientAddressWhereInput
    /**
     * Limit how many ClientAddresses to delete.
     */
    limit?: number
  }

  /**
   * ClientAddress without action
   */
  export type ClientAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAddress
     */
    select?: ClientAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAddress
     */
    omit?: ClientAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAddressInclude<ExtArgs> | null
  }


  /**
   * Model ClientCompany
   */

  export type AggregateClientCompany = {
    _count: ClientCompanyCountAggregateOutputType | null
    _min: ClientCompanyMinAggregateOutputType | null
    _max: ClientCompanyMaxAggregateOutputType | null
  }

  export type ClientCompanyMinAggregateOutputType = {
    id: string | null
    client_id: string | null
    name: string | null
    tax_id: string | null
    website: string | null
    notes: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientCompanyMaxAggregateOutputType = {
    id: string | null
    client_id: string | null
    name: string | null
    tax_id: string | null
    website: string | null
    notes: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientCompanyCountAggregateOutputType = {
    id: number
    client_id: number
    name: number
    tax_id: number
    website: number
    notes: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ClientCompanyMinAggregateInputType = {
    id?: true
    client_id?: true
    name?: true
    tax_id?: true
    website?: true
    notes?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientCompanyMaxAggregateInputType = {
    id?: true
    client_id?: true
    name?: true
    tax_id?: true
    website?: true
    notes?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientCompanyCountAggregateInputType = {
    id?: true
    client_id?: true
    name?: true
    tax_id?: true
    website?: true
    notes?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ClientCompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientCompany to aggregate.
     */
    where?: ClientCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientCompanies to fetch.
     */
    orderBy?: ClientCompanyOrderByWithRelationInput | ClientCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientCompanies
    **/
    _count?: true | ClientCompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientCompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientCompanyMaxAggregateInputType
  }

  export type GetClientCompanyAggregateType<T extends ClientCompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateClientCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientCompany[P]>
      : GetScalarType<T[P], AggregateClientCompany[P]>
  }




  export type ClientCompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientCompanyWhereInput
    orderBy?: ClientCompanyOrderByWithAggregationInput | ClientCompanyOrderByWithAggregationInput[]
    by: ClientCompanyScalarFieldEnum[] | ClientCompanyScalarFieldEnum
    having?: ClientCompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCompanyCountAggregateInputType | true
    _min?: ClientCompanyMinAggregateInputType
    _max?: ClientCompanyMaxAggregateInputType
  }

  export type ClientCompanyGroupByOutputType = {
    id: string
    client_id: string
    name: string
    tax_id: string | null
    website: string | null
    notes: string | null
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: ClientCompanyCountAggregateOutputType | null
    _min: ClientCompanyMinAggregateOutputType | null
    _max: ClientCompanyMaxAggregateOutputType | null
  }

  type GetClientCompanyGroupByPayload<T extends ClientCompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientCompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientCompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientCompanyGroupByOutputType[P]>
            : GetScalarType<T[P], ClientCompanyGroupByOutputType[P]>
        }
      >
    >


  export type ClientCompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    name?: boolean
    tax_id?: boolean
    website?: boolean
    notes?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    phones?: boolean | ClientCompany$phonesArgs<ExtArgs>
    emails?: boolean | ClientCompany$emailsArgs<ExtArgs>
    addresses?: boolean | ClientCompany$addressesArgs<ExtArgs>
    billings?: boolean | ClientCompany$billingsArgs<ExtArgs>
    _count?: boolean | ClientCompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientCompany"]>



  export type ClientCompanySelectScalar = {
    id?: boolean
    client_id?: boolean
    name?: boolean
    tax_id?: boolean
    website?: boolean
    notes?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ClientCompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "client_id" | "name" | "tax_id" | "website" | "notes" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["clientCompany"]>
  export type ClientCompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    phones?: boolean | ClientCompany$phonesArgs<ExtArgs>
    emails?: boolean | ClientCompany$emailsArgs<ExtArgs>
    addresses?: boolean | ClientCompany$addressesArgs<ExtArgs>
    billings?: boolean | ClientCompany$billingsArgs<ExtArgs>
    _count?: boolean | ClientCompanyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClientCompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientCompany"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      phones: Prisma.$ClientCompanyPhonePayload<ExtArgs>[]
      emails: Prisma.$ClientCompanyEmailPayload<ExtArgs>[]
      addresses: Prisma.$ClientCompanyAddressPayload<ExtArgs>[]
      billings: Prisma.$BillingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      client_id: string
      name: string
      tax_id: string | null
      website: string | null
      notes: string | null
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["clientCompany"]>
    composites: {}
  }

  type ClientCompanyGetPayload<S extends boolean | null | undefined | ClientCompanyDefaultArgs> = $Result.GetResult<Prisma.$ClientCompanyPayload, S>

  type ClientCompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientCompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCompanyCountAggregateInputType | true
    }

  export interface ClientCompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientCompany'], meta: { name: 'ClientCompany' } }
    /**
     * Find zero or one ClientCompany that matches the filter.
     * @param {ClientCompanyFindUniqueArgs} args - Arguments to find a ClientCompany
     * @example
     * // Get one ClientCompany
     * const clientCompany = await prisma.clientCompany.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientCompanyFindUniqueArgs>(args: SelectSubset<T, ClientCompanyFindUniqueArgs<ExtArgs>>): Prisma__ClientCompanyClient<$Result.GetResult<Prisma.$ClientCompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientCompany that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientCompanyFindUniqueOrThrowArgs} args - Arguments to find a ClientCompany
     * @example
     * // Get one ClientCompany
     * const clientCompany = await prisma.clientCompany.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientCompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientCompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientCompanyClient<$Result.GetResult<Prisma.$ClientCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientCompany that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyFindFirstArgs} args - Arguments to find a ClientCompany
     * @example
     * // Get one ClientCompany
     * const clientCompany = await prisma.clientCompany.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientCompanyFindFirstArgs>(args?: SelectSubset<T, ClientCompanyFindFirstArgs<ExtArgs>>): Prisma__ClientCompanyClient<$Result.GetResult<Prisma.$ClientCompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientCompany that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyFindFirstOrThrowArgs} args - Arguments to find a ClientCompany
     * @example
     * // Get one ClientCompany
     * const clientCompany = await prisma.clientCompany.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientCompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientCompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientCompanyClient<$Result.GetResult<Prisma.$ClientCompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientCompanies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientCompanies
     * const clientCompanies = await prisma.clientCompany.findMany()
     * 
     * // Get first 10 ClientCompanies
     * const clientCompanies = await prisma.clientCompany.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientCompanyWithIdOnly = await prisma.clientCompany.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientCompanyFindManyArgs>(args?: SelectSubset<T, ClientCompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientCompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientCompany.
     * @param {ClientCompanyCreateArgs} args - Arguments to create a ClientCompany.
     * @example
     * // Create one ClientCompany
     * const ClientCompany = await prisma.clientCompany.create({
     *   data: {
     *     // ... data to create a ClientCompany
     *   }
     * })
     * 
     */
    create<T extends ClientCompanyCreateArgs>(args: SelectSubset<T, ClientCompanyCreateArgs<ExtArgs>>): Prisma__ClientCompanyClient<$Result.GetResult<Prisma.$ClientCompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientCompanies.
     * @param {ClientCompanyCreateManyArgs} args - Arguments to create many ClientCompanies.
     * @example
     * // Create many ClientCompanies
     * const clientCompany = await prisma.clientCompany.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCompanyCreateManyArgs>(args?: SelectSubset<T, ClientCompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientCompany.
     * @param {ClientCompanyDeleteArgs} args - Arguments to delete one ClientCompany.
     * @example
     * // Delete one ClientCompany
     * const ClientCompany = await prisma.clientCompany.delete({
     *   where: {
     *     // ... filter to delete one ClientCompany
     *   }
     * })
     * 
     */
    delete<T extends ClientCompanyDeleteArgs>(args: SelectSubset<T, ClientCompanyDeleteArgs<ExtArgs>>): Prisma__ClientCompanyClient<$Result.GetResult<Prisma.$ClientCompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientCompany.
     * @param {ClientCompanyUpdateArgs} args - Arguments to update one ClientCompany.
     * @example
     * // Update one ClientCompany
     * const clientCompany = await prisma.clientCompany.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientCompanyUpdateArgs>(args: SelectSubset<T, ClientCompanyUpdateArgs<ExtArgs>>): Prisma__ClientCompanyClient<$Result.GetResult<Prisma.$ClientCompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientCompanies.
     * @param {ClientCompanyDeleteManyArgs} args - Arguments to filter ClientCompanies to delete.
     * @example
     * // Delete a few ClientCompanies
     * const { count } = await prisma.clientCompany.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientCompanyDeleteManyArgs>(args?: SelectSubset<T, ClientCompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientCompanies
     * const clientCompany = await prisma.clientCompany.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientCompanyUpdateManyArgs>(args: SelectSubset<T, ClientCompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientCompany.
     * @param {ClientCompanyUpsertArgs} args - Arguments to update or create a ClientCompany.
     * @example
     * // Update or create a ClientCompany
     * const clientCompany = await prisma.clientCompany.upsert({
     *   create: {
     *     // ... data to create a ClientCompany
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientCompany we want to update
     *   }
     * })
     */
    upsert<T extends ClientCompanyUpsertArgs>(args: SelectSubset<T, ClientCompanyUpsertArgs<ExtArgs>>): Prisma__ClientCompanyClient<$Result.GetResult<Prisma.$ClientCompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyCountArgs} args - Arguments to filter ClientCompanies to count.
     * @example
     * // Count the number of ClientCompanies
     * const count = await prisma.clientCompany.count({
     *   where: {
     *     // ... the filter for the ClientCompanies we want to count
     *   }
     * })
    **/
    count<T extends ClientCompanyCountArgs>(
      args?: Subset<T, ClientCompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientCompanyAggregateArgs>(args: Subset<T, ClientCompanyAggregateArgs>): Prisma.PrismaPromise<GetClientCompanyAggregateType<T>>

    /**
     * Group by ClientCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientCompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientCompanyGroupByArgs['orderBy'] }
        : { orderBy?: ClientCompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientCompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientCompany model
   */
  readonly fields: ClientCompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientCompany.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientCompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    phones<T extends ClientCompany$phonesArgs<ExtArgs> = {}>(args?: Subset<T, ClientCompany$phonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientCompanyPhonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emails<T extends ClientCompany$emailsArgs<ExtArgs> = {}>(args?: Subset<T, ClientCompany$emailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientCompanyEmailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addresses<T extends ClientCompany$addressesArgs<ExtArgs> = {}>(args?: Subset<T, ClientCompany$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientCompanyAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    billings<T extends ClientCompany$billingsArgs<ExtArgs> = {}>(args?: Subset<T, ClientCompany$billingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientCompany model
   */
  interface ClientCompanyFieldRefs {
    readonly id: FieldRef<"ClientCompany", 'String'>
    readonly client_id: FieldRef<"ClientCompany", 'String'>
    readonly name: FieldRef<"ClientCompany", 'String'>
    readonly tax_id: FieldRef<"ClientCompany", 'String'>
    readonly website: FieldRef<"ClientCompany", 'String'>
    readonly notes: FieldRef<"ClientCompany", 'String'>
    readonly is_active: FieldRef<"ClientCompany", 'Boolean'>
    readonly created_at: FieldRef<"ClientCompany", 'DateTime'>
    readonly updated_at: FieldRef<"ClientCompany", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientCompany findUnique
   */
  export type ClientCompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompany
     */
    select?: ClientCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompany
     */
    omit?: ClientCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyInclude<ExtArgs> | null
    /**
     * Filter, which ClientCompany to fetch.
     */
    where: ClientCompanyWhereUniqueInput
  }

  /**
   * ClientCompany findUniqueOrThrow
   */
  export type ClientCompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompany
     */
    select?: ClientCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompany
     */
    omit?: ClientCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyInclude<ExtArgs> | null
    /**
     * Filter, which ClientCompany to fetch.
     */
    where: ClientCompanyWhereUniqueInput
  }

  /**
   * ClientCompany findFirst
   */
  export type ClientCompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompany
     */
    select?: ClientCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompany
     */
    omit?: ClientCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyInclude<ExtArgs> | null
    /**
     * Filter, which ClientCompany to fetch.
     */
    where?: ClientCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientCompanies to fetch.
     */
    orderBy?: ClientCompanyOrderByWithRelationInput | ClientCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientCompanies.
     */
    cursor?: ClientCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientCompanies.
     */
    distinct?: ClientCompanyScalarFieldEnum | ClientCompanyScalarFieldEnum[]
  }

  /**
   * ClientCompany findFirstOrThrow
   */
  export type ClientCompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompany
     */
    select?: ClientCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompany
     */
    omit?: ClientCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyInclude<ExtArgs> | null
    /**
     * Filter, which ClientCompany to fetch.
     */
    where?: ClientCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientCompanies to fetch.
     */
    orderBy?: ClientCompanyOrderByWithRelationInput | ClientCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientCompanies.
     */
    cursor?: ClientCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientCompanies.
     */
    distinct?: ClientCompanyScalarFieldEnum | ClientCompanyScalarFieldEnum[]
  }

  /**
   * ClientCompany findMany
   */
  export type ClientCompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompany
     */
    select?: ClientCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompany
     */
    omit?: ClientCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyInclude<ExtArgs> | null
    /**
     * Filter, which ClientCompanies to fetch.
     */
    where?: ClientCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientCompanies to fetch.
     */
    orderBy?: ClientCompanyOrderByWithRelationInput | ClientCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientCompanies.
     */
    cursor?: ClientCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientCompanies.
     */
    skip?: number
    distinct?: ClientCompanyScalarFieldEnum | ClientCompanyScalarFieldEnum[]
  }

  /**
   * ClientCompany create
   */
  export type ClientCompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompany
     */
    select?: ClientCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompany
     */
    omit?: ClientCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientCompany.
     */
    data: XOR<ClientCompanyCreateInput, ClientCompanyUncheckedCreateInput>
  }

  /**
   * ClientCompany createMany
   */
  export type ClientCompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientCompanies.
     */
    data: ClientCompanyCreateManyInput | ClientCompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientCompany update
   */
  export type ClientCompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompany
     */
    select?: ClientCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompany
     */
    omit?: ClientCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientCompany.
     */
    data: XOR<ClientCompanyUpdateInput, ClientCompanyUncheckedUpdateInput>
    /**
     * Choose, which ClientCompany to update.
     */
    where: ClientCompanyWhereUniqueInput
  }

  /**
   * ClientCompany updateMany
   */
  export type ClientCompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientCompanies.
     */
    data: XOR<ClientCompanyUpdateManyMutationInput, ClientCompanyUncheckedUpdateManyInput>
    /**
     * Filter which ClientCompanies to update
     */
    where?: ClientCompanyWhereInput
    /**
     * Limit how many ClientCompanies to update.
     */
    limit?: number
  }

  /**
   * ClientCompany upsert
   */
  export type ClientCompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompany
     */
    select?: ClientCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompany
     */
    omit?: ClientCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientCompany to update in case it exists.
     */
    where: ClientCompanyWhereUniqueInput
    /**
     * In case the ClientCompany found by the `where` argument doesn't exist, create a new ClientCompany with this data.
     */
    create: XOR<ClientCompanyCreateInput, ClientCompanyUncheckedCreateInput>
    /**
     * In case the ClientCompany was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientCompanyUpdateInput, ClientCompanyUncheckedUpdateInput>
  }

  /**
   * ClientCompany delete
   */
  export type ClientCompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompany
     */
    select?: ClientCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompany
     */
    omit?: ClientCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyInclude<ExtArgs> | null
    /**
     * Filter which ClientCompany to delete.
     */
    where: ClientCompanyWhereUniqueInput
  }

  /**
   * ClientCompany deleteMany
   */
  export type ClientCompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientCompanies to delete
     */
    where?: ClientCompanyWhereInput
    /**
     * Limit how many ClientCompanies to delete.
     */
    limit?: number
  }

  /**
   * ClientCompany.phones
   */
  export type ClientCompany$phonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyPhone
     */
    select?: ClientCompanyPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyPhone
     */
    omit?: ClientCompanyPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyPhoneInclude<ExtArgs> | null
    where?: ClientCompanyPhoneWhereInput
    orderBy?: ClientCompanyPhoneOrderByWithRelationInput | ClientCompanyPhoneOrderByWithRelationInput[]
    cursor?: ClientCompanyPhoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientCompanyPhoneScalarFieldEnum | ClientCompanyPhoneScalarFieldEnum[]
  }

  /**
   * ClientCompany.emails
   */
  export type ClientCompany$emailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyEmail
     */
    select?: ClientCompanyEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyEmail
     */
    omit?: ClientCompanyEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyEmailInclude<ExtArgs> | null
    where?: ClientCompanyEmailWhereInput
    orderBy?: ClientCompanyEmailOrderByWithRelationInput | ClientCompanyEmailOrderByWithRelationInput[]
    cursor?: ClientCompanyEmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientCompanyEmailScalarFieldEnum | ClientCompanyEmailScalarFieldEnum[]
  }

  /**
   * ClientCompany.addresses
   */
  export type ClientCompany$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyAddress
     */
    select?: ClientCompanyAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyAddress
     */
    omit?: ClientCompanyAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyAddressInclude<ExtArgs> | null
    where?: ClientCompanyAddressWhereInput
    orderBy?: ClientCompanyAddressOrderByWithRelationInput | ClientCompanyAddressOrderByWithRelationInput[]
    cursor?: ClientCompanyAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientCompanyAddressScalarFieldEnum | ClientCompanyAddressScalarFieldEnum[]
  }

  /**
   * ClientCompany.billings
   */
  export type ClientCompany$billingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing
     */
    select?: BillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing
     */
    omit?: BillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInclude<ExtArgs> | null
    where?: BillingWhereInput
    orderBy?: BillingOrderByWithRelationInput | BillingOrderByWithRelationInput[]
    cursor?: BillingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillingScalarFieldEnum | BillingScalarFieldEnum[]
  }

  /**
   * ClientCompany without action
   */
  export type ClientCompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompany
     */
    select?: ClientCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompany
     */
    omit?: ClientCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyInclude<ExtArgs> | null
  }


  /**
   * Model ClientCompanyPhone
   */

  export type AggregateClientCompanyPhone = {
    _count: ClientCompanyPhoneCountAggregateOutputType | null
    _min: ClientCompanyPhoneMinAggregateOutputType | null
    _max: ClientCompanyPhoneMaxAggregateOutputType | null
  }

  export type ClientCompanyPhoneMinAggregateOutputType = {
    id: string | null
    company_id: string | null
    phone_number: string | null
    type: string | null
    is_primary: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientCompanyPhoneMaxAggregateOutputType = {
    id: string | null
    company_id: string | null
    phone_number: string | null
    type: string | null
    is_primary: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientCompanyPhoneCountAggregateOutputType = {
    id: number
    company_id: number
    phone_number: number
    type: number
    is_primary: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ClientCompanyPhoneMinAggregateInputType = {
    id?: true
    company_id?: true
    phone_number?: true
    type?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientCompanyPhoneMaxAggregateInputType = {
    id?: true
    company_id?: true
    phone_number?: true
    type?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientCompanyPhoneCountAggregateInputType = {
    id?: true
    company_id?: true
    phone_number?: true
    type?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ClientCompanyPhoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientCompanyPhone to aggregate.
     */
    where?: ClientCompanyPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientCompanyPhones to fetch.
     */
    orderBy?: ClientCompanyPhoneOrderByWithRelationInput | ClientCompanyPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientCompanyPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientCompanyPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientCompanyPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientCompanyPhones
    **/
    _count?: true | ClientCompanyPhoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientCompanyPhoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientCompanyPhoneMaxAggregateInputType
  }

  export type GetClientCompanyPhoneAggregateType<T extends ClientCompanyPhoneAggregateArgs> = {
        [P in keyof T & keyof AggregateClientCompanyPhone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientCompanyPhone[P]>
      : GetScalarType<T[P], AggregateClientCompanyPhone[P]>
  }




  export type ClientCompanyPhoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientCompanyPhoneWhereInput
    orderBy?: ClientCompanyPhoneOrderByWithAggregationInput | ClientCompanyPhoneOrderByWithAggregationInput[]
    by: ClientCompanyPhoneScalarFieldEnum[] | ClientCompanyPhoneScalarFieldEnum
    having?: ClientCompanyPhoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCompanyPhoneCountAggregateInputType | true
    _min?: ClientCompanyPhoneMinAggregateInputType
    _max?: ClientCompanyPhoneMaxAggregateInputType
  }

  export type ClientCompanyPhoneGroupByOutputType = {
    id: string
    company_id: string
    phone_number: string
    type: string
    is_primary: boolean
    created_at: Date
    updated_at: Date
    _count: ClientCompanyPhoneCountAggregateOutputType | null
    _min: ClientCompanyPhoneMinAggregateOutputType | null
    _max: ClientCompanyPhoneMaxAggregateOutputType | null
  }

  type GetClientCompanyPhoneGroupByPayload<T extends ClientCompanyPhoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientCompanyPhoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientCompanyPhoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientCompanyPhoneGroupByOutputType[P]>
            : GetScalarType<T[P], ClientCompanyPhoneGroupByOutputType[P]>
        }
      >
    >


  export type ClientCompanyPhoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    phone_number?: boolean
    type?: boolean
    is_primary?: boolean
    created_at?: boolean
    updated_at?: boolean
    company?: boolean | ClientCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientCompanyPhone"]>



  export type ClientCompanyPhoneSelectScalar = {
    id?: boolean
    company_id?: boolean
    phone_number?: boolean
    type?: boolean
    is_primary?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ClientCompanyPhoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_id" | "phone_number" | "type" | "is_primary" | "created_at" | "updated_at", ExtArgs["result"]["clientCompanyPhone"]>
  export type ClientCompanyPhoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | ClientCompanyDefaultArgs<ExtArgs>
  }

  export type $ClientCompanyPhonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientCompanyPhone"
    objects: {
      company: Prisma.$ClientCompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      company_id: string
      phone_number: string
      type: string
      is_primary: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["clientCompanyPhone"]>
    composites: {}
  }

  type ClientCompanyPhoneGetPayload<S extends boolean | null | undefined | ClientCompanyPhoneDefaultArgs> = $Result.GetResult<Prisma.$ClientCompanyPhonePayload, S>

  type ClientCompanyPhoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientCompanyPhoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCompanyPhoneCountAggregateInputType | true
    }

  export interface ClientCompanyPhoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientCompanyPhone'], meta: { name: 'ClientCompanyPhone' } }
    /**
     * Find zero or one ClientCompanyPhone that matches the filter.
     * @param {ClientCompanyPhoneFindUniqueArgs} args - Arguments to find a ClientCompanyPhone
     * @example
     * // Get one ClientCompanyPhone
     * const clientCompanyPhone = await prisma.clientCompanyPhone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientCompanyPhoneFindUniqueArgs>(args: SelectSubset<T, ClientCompanyPhoneFindUniqueArgs<ExtArgs>>): Prisma__ClientCompanyPhoneClient<$Result.GetResult<Prisma.$ClientCompanyPhonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientCompanyPhone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientCompanyPhoneFindUniqueOrThrowArgs} args - Arguments to find a ClientCompanyPhone
     * @example
     * // Get one ClientCompanyPhone
     * const clientCompanyPhone = await prisma.clientCompanyPhone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientCompanyPhoneFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientCompanyPhoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientCompanyPhoneClient<$Result.GetResult<Prisma.$ClientCompanyPhonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientCompanyPhone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyPhoneFindFirstArgs} args - Arguments to find a ClientCompanyPhone
     * @example
     * // Get one ClientCompanyPhone
     * const clientCompanyPhone = await prisma.clientCompanyPhone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientCompanyPhoneFindFirstArgs>(args?: SelectSubset<T, ClientCompanyPhoneFindFirstArgs<ExtArgs>>): Prisma__ClientCompanyPhoneClient<$Result.GetResult<Prisma.$ClientCompanyPhonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientCompanyPhone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyPhoneFindFirstOrThrowArgs} args - Arguments to find a ClientCompanyPhone
     * @example
     * // Get one ClientCompanyPhone
     * const clientCompanyPhone = await prisma.clientCompanyPhone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientCompanyPhoneFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientCompanyPhoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientCompanyPhoneClient<$Result.GetResult<Prisma.$ClientCompanyPhonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientCompanyPhones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyPhoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientCompanyPhones
     * const clientCompanyPhones = await prisma.clientCompanyPhone.findMany()
     * 
     * // Get first 10 ClientCompanyPhones
     * const clientCompanyPhones = await prisma.clientCompanyPhone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientCompanyPhoneWithIdOnly = await prisma.clientCompanyPhone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientCompanyPhoneFindManyArgs>(args?: SelectSubset<T, ClientCompanyPhoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientCompanyPhonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientCompanyPhone.
     * @param {ClientCompanyPhoneCreateArgs} args - Arguments to create a ClientCompanyPhone.
     * @example
     * // Create one ClientCompanyPhone
     * const ClientCompanyPhone = await prisma.clientCompanyPhone.create({
     *   data: {
     *     // ... data to create a ClientCompanyPhone
     *   }
     * })
     * 
     */
    create<T extends ClientCompanyPhoneCreateArgs>(args: SelectSubset<T, ClientCompanyPhoneCreateArgs<ExtArgs>>): Prisma__ClientCompanyPhoneClient<$Result.GetResult<Prisma.$ClientCompanyPhonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientCompanyPhones.
     * @param {ClientCompanyPhoneCreateManyArgs} args - Arguments to create many ClientCompanyPhones.
     * @example
     * // Create many ClientCompanyPhones
     * const clientCompanyPhone = await prisma.clientCompanyPhone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCompanyPhoneCreateManyArgs>(args?: SelectSubset<T, ClientCompanyPhoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientCompanyPhone.
     * @param {ClientCompanyPhoneDeleteArgs} args - Arguments to delete one ClientCompanyPhone.
     * @example
     * // Delete one ClientCompanyPhone
     * const ClientCompanyPhone = await prisma.clientCompanyPhone.delete({
     *   where: {
     *     // ... filter to delete one ClientCompanyPhone
     *   }
     * })
     * 
     */
    delete<T extends ClientCompanyPhoneDeleteArgs>(args: SelectSubset<T, ClientCompanyPhoneDeleteArgs<ExtArgs>>): Prisma__ClientCompanyPhoneClient<$Result.GetResult<Prisma.$ClientCompanyPhonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientCompanyPhone.
     * @param {ClientCompanyPhoneUpdateArgs} args - Arguments to update one ClientCompanyPhone.
     * @example
     * // Update one ClientCompanyPhone
     * const clientCompanyPhone = await prisma.clientCompanyPhone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientCompanyPhoneUpdateArgs>(args: SelectSubset<T, ClientCompanyPhoneUpdateArgs<ExtArgs>>): Prisma__ClientCompanyPhoneClient<$Result.GetResult<Prisma.$ClientCompanyPhonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientCompanyPhones.
     * @param {ClientCompanyPhoneDeleteManyArgs} args - Arguments to filter ClientCompanyPhones to delete.
     * @example
     * // Delete a few ClientCompanyPhones
     * const { count } = await prisma.clientCompanyPhone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientCompanyPhoneDeleteManyArgs>(args?: SelectSubset<T, ClientCompanyPhoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientCompanyPhones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyPhoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientCompanyPhones
     * const clientCompanyPhone = await prisma.clientCompanyPhone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientCompanyPhoneUpdateManyArgs>(args: SelectSubset<T, ClientCompanyPhoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientCompanyPhone.
     * @param {ClientCompanyPhoneUpsertArgs} args - Arguments to update or create a ClientCompanyPhone.
     * @example
     * // Update or create a ClientCompanyPhone
     * const clientCompanyPhone = await prisma.clientCompanyPhone.upsert({
     *   create: {
     *     // ... data to create a ClientCompanyPhone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientCompanyPhone we want to update
     *   }
     * })
     */
    upsert<T extends ClientCompanyPhoneUpsertArgs>(args: SelectSubset<T, ClientCompanyPhoneUpsertArgs<ExtArgs>>): Prisma__ClientCompanyPhoneClient<$Result.GetResult<Prisma.$ClientCompanyPhonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientCompanyPhones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyPhoneCountArgs} args - Arguments to filter ClientCompanyPhones to count.
     * @example
     * // Count the number of ClientCompanyPhones
     * const count = await prisma.clientCompanyPhone.count({
     *   where: {
     *     // ... the filter for the ClientCompanyPhones we want to count
     *   }
     * })
    **/
    count<T extends ClientCompanyPhoneCountArgs>(
      args?: Subset<T, ClientCompanyPhoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCompanyPhoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientCompanyPhone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyPhoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientCompanyPhoneAggregateArgs>(args: Subset<T, ClientCompanyPhoneAggregateArgs>): Prisma.PrismaPromise<GetClientCompanyPhoneAggregateType<T>>

    /**
     * Group by ClientCompanyPhone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyPhoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientCompanyPhoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientCompanyPhoneGroupByArgs['orderBy'] }
        : { orderBy?: ClientCompanyPhoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientCompanyPhoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientCompanyPhoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientCompanyPhone model
   */
  readonly fields: ClientCompanyPhoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientCompanyPhone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientCompanyPhoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends ClientCompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientCompanyDefaultArgs<ExtArgs>>): Prisma__ClientCompanyClient<$Result.GetResult<Prisma.$ClientCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientCompanyPhone model
   */
  interface ClientCompanyPhoneFieldRefs {
    readonly id: FieldRef<"ClientCompanyPhone", 'String'>
    readonly company_id: FieldRef<"ClientCompanyPhone", 'String'>
    readonly phone_number: FieldRef<"ClientCompanyPhone", 'String'>
    readonly type: FieldRef<"ClientCompanyPhone", 'String'>
    readonly is_primary: FieldRef<"ClientCompanyPhone", 'Boolean'>
    readonly created_at: FieldRef<"ClientCompanyPhone", 'DateTime'>
    readonly updated_at: FieldRef<"ClientCompanyPhone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientCompanyPhone findUnique
   */
  export type ClientCompanyPhoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyPhone
     */
    select?: ClientCompanyPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyPhone
     */
    omit?: ClientCompanyPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyPhoneInclude<ExtArgs> | null
    /**
     * Filter, which ClientCompanyPhone to fetch.
     */
    where: ClientCompanyPhoneWhereUniqueInput
  }

  /**
   * ClientCompanyPhone findUniqueOrThrow
   */
  export type ClientCompanyPhoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyPhone
     */
    select?: ClientCompanyPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyPhone
     */
    omit?: ClientCompanyPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyPhoneInclude<ExtArgs> | null
    /**
     * Filter, which ClientCompanyPhone to fetch.
     */
    where: ClientCompanyPhoneWhereUniqueInput
  }

  /**
   * ClientCompanyPhone findFirst
   */
  export type ClientCompanyPhoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyPhone
     */
    select?: ClientCompanyPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyPhone
     */
    omit?: ClientCompanyPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyPhoneInclude<ExtArgs> | null
    /**
     * Filter, which ClientCompanyPhone to fetch.
     */
    where?: ClientCompanyPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientCompanyPhones to fetch.
     */
    orderBy?: ClientCompanyPhoneOrderByWithRelationInput | ClientCompanyPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientCompanyPhones.
     */
    cursor?: ClientCompanyPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientCompanyPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientCompanyPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientCompanyPhones.
     */
    distinct?: ClientCompanyPhoneScalarFieldEnum | ClientCompanyPhoneScalarFieldEnum[]
  }

  /**
   * ClientCompanyPhone findFirstOrThrow
   */
  export type ClientCompanyPhoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyPhone
     */
    select?: ClientCompanyPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyPhone
     */
    omit?: ClientCompanyPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyPhoneInclude<ExtArgs> | null
    /**
     * Filter, which ClientCompanyPhone to fetch.
     */
    where?: ClientCompanyPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientCompanyPhones to fetch.
     */
    orderBy?: ClientCompanyPhoneOrderByWithRelationInput | ClientCompanyPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientCompanyPhones.
     */
    cursor?: ClientCompanyPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientCompanyPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientCompanyPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientCompanyPhones.
     */
    distinct?: ClientCompanyPhoneScalarFieldEnum | ClientCompanyPhoneScalarFieldEnum[]
  }

  /**
   * ClientCompanyPhone findMany
   */
  export type ClientCompanyPhoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyPhone
     */
    select?: ClientCompanyPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyPhone
     */
    omit?: ClientCompanyPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyPhoneInclude<ExtArgs> | null
    /**
     * Filter, which ClientCompanyPhones to fetch.
     */
    where?: ClientCompanyPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientCompanyPhones to fetch.
     */
    orderBy?: ClientCompanyPhoneOrderByWithRelationInput | ClientCompanyPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientCompanyPhones.
     */
    cursor?: ClientCompanyPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientCompanyPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientCompanyPhones.
     */
    skip?: number
    distinct?: ClientCompanyPhoneScalarFieldEnum | ClientCompanyPhoneScalarFieldEnum[]
  }

  /**
   * ClientCompanyPhone create
   */
  export type ClientCompanyPhoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyPhone
     */
    select?: ClientCompanyPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyPhone
     */
    omit?: ClientCompanyPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyPhoneInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientCompanyPhone.
     */
    data: XOR<ClientCompanyPhoneCreateInput, ClientCompanyPhoneUncheckedCreateInput>
  }

  /**
   * ClientCompanyPhone createMany
   */
  export type ClientCompanyPhoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientCompanyPhones.
     */
    data: ClientCompanyPhoneCreateManyInput | ClientCompanyPhoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientCompanyPhone update
   */
  export type ClientCompanyPhoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyPhone
     */
    select?: ClientCompanyPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyPhone
     */
    omit?: ClientCompanyPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyPhoneInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientCompanyPhone.
     */
    data: XOR<ClientCompanyPhoneUpdateInput, ClientCompanyPhoneUncheckedUpdateInput>
    /**
     * Choose, which ClientCompanyPhone to update.
     */
    where: ClientCompanyPhoneWhereUniqueInput
  }

  /**
   * ClientCompanyPhone updateMany
   */
  export type ClientCompanyPhoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientCompanyPhones.
     */
    data: XOR<ClientCompanyPhoneUpdateManyMutationInput, ClientCompanyPhoneUncheckedUpdateManyInput>
    /**
     * Filter which ClientCompanyPhones to update
     */
    where?: ClientCompanyPhoneWhereInput
    /**
     * Limit how many ClientCompanyPhones to update.
     */
    limit?: number
  }

  /**
   * ClientCompanyPhone upsert
   */
  export type ClientCompanyPhoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyPhone
     */
    select?: ClientCompanyPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyPhone
     */
    omit?: ClientCompanyPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyPhoneInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientCompanyPhone to update in case it exists.
     */
    where: ClientCompanyPhoneWhereUniqueInput
    /**
     * In case the ClientCompanyPhone found by the `where` argument doesn't exist, create a new ClientCompanyPhone with this data.
     */
    create: XOR<ClientCompanyPhoneCreateInput, ClientCompanyPhoneUncheckedCreateInput>
    /**
     * In case the ClientCompanyPhone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientCompanyPhoneUpdateInput, ClientCompanyPhoneUncheckedUpdateInput>
  }

  /**
   * ClientCompanyPhone delete
   */
  export type ClientCompanyPhoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyPhone
     */
    select?: ClientCompanyPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyPhone
     */
    omit?: ClientCompanyPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyPhoneInclude<ExtArgs> | null
    /**
     * Filter which ClientCompanyPhone to delete.
     */
    where: ClientCompanyPhoneWhereUniqueInput
  }

  /**
   * ClientCompanyPhone deleteMany
   */
  export type ClientCompanyPhoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientCompanyPhones to delete
     */
    where?: ClientCompanyPhoneWhereInput
    /**
     * Limit how many ClientCompanyPhones to delete.
     */
    limit?: number
  }

  /**
   * ClientCompanyPhone without action
   */
  export type ClientCompanyPhoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyPhone
     */
    select?: ClientCompanyPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyPhone
     */
    omit?: ClientCompanyPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyPhoneInclude<ExtArgs> | null
  }


  /**
   * Model ClientCompanyEmail
   */

  export type AggregateClientCompanyEmail = {
    _count: ClientCompanyEmailCountAggregateOutputType | null
    _min: ClientCompanyEmailMinAggregateOutputType | null
    _max: ClientCompanyEmailMaxAggregateOutputType | null
  }

  export type ClientCompanyEmailMinAggregateOutputType = {
    id: string | null
    company_id: string | null
    email: string | null
    type: string | null
    is_primary: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientCompanyEmailMaxAggregateOutputType = {
    id: string | null
    company_id: string | null
    email: string | null
    type: string | null
    is_primary: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientCompanyEmailCountAggregateOutputType = {
    id: number
    company_id: number
    email: number
    type: number
    is_primary: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ClientCompanyEmailMinAggregateInputType = {
    id?: true
    company_id?: true
    email?: true
    type?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientCompanyEmailMaxAggregateInputType = {
    id?: true
    company_id?: true
    email?: true
    type?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientCompanyEmailCountAggregateInputType = {
    id?: true
    company_id?: true
    email?: true
    type?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ClientCompanyEmailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientCompanyEmail to aggregate.
     */
    where?: ClientCompanyEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientCompanyEmails to fetch.
     */
    orderBy?: ClientCompanyEmailOrderByWithRelationInput | ClientCompanyEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientCompanyEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientCompanyEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientCompanyEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientCompanyEmails
    **/
    _count?: true | ClientCompanyEmailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientCompanyEmailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientCompanyEmailMaxAggregateInputType
  }

  export type GetClientCompanyEmailAggregateType<T extends ClientCompanyEmailAggregateArgs> = {
        [P in keyof T & keyof AggregateClientCompanyEmail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientCompanyEmail[P]>
      : GetScalarType<T[P], AggregateClientCompanyEmail[P]>
  }




  export type ClientCompanyEmailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientCompanyEmailWhereInput
    orderBy?: ClientCompanyEmailOrderByWithAggregationInput | ClientCompanyEmailOrderByWithAggregationInput[]
    by: ClientCompanyEmailScalarFieldEnum[] | ClientCompanyEmailScalarFieldEnum
    having?: ClientCompanyEmailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCompanyEmailCountAggregateInputType | true
    _min?: ClientCompanyEmailMinAggregateInputType
    _max?: ClientCompanyEmailMaxAggregateInputType
  }

  export type ClientCompanyEmailGroupByOutputType = {
    id: string
    company_id: string
    email: string
    type: string
    is_primary: boolean
    created_at: Date
    updated_at: Date
    _count: ClientCompanyEmailCountAggregateOutputType | null
    _min: ClientCompanyEmailMinAggregateOutputType | null
    _max: ClientCompanyEmailMaxAggregateOutputType | null
  }

  type GetClientCompanyEmailGroupByPayload<T extends ClientCompanyEmailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientCompanyEmailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientCompanyEmailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientCompanyEmailGroupByOutputType[P]>
            : GetScalarType<T[P], ClientCompanyEmailGroupByOutputType[P]>
        }
      >
    >


  export type ClientCompanyEmailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    email?: boolean
    type?: boolean
    is_primary?: boolean
    created_at?: boolean
    updated_at?: boolean
    company?: boolean | ClientCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientCompanyEmail"]>



  export type ClientCompanyEmailSelectScalar = {
    id?: boolean
    company_id?: boolean
    email?: boolean
    type?: boolean
    is_primary?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ClientCompanyEmailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_id" | "email" | "type" | "is_primary" | "created_at" | "updated_at", ExtArgs["result"]["clientCompanyEmail"]>
  export type ClientCompanyEmailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | ClientCompanyDefaultArgs<ExtArgs>
  }

  export type $ClientCompanyEmailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientCompanyEmail"
    objects: {
      company: Prisma.$ClientCompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      company_id: string
      email: string
      type: string
      is_primary: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["clientCompanyEmail"]>
    composites: {}
  }

  type ClientCompanyEmailGetPayload<S extends boolean | null | undefined | ClientCompanyEmailDefaultArgs> = $Result.GetResult<Prisma.$ClientCompanyEmailPayload, S>

  type ClientCompanyEmailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientCompanyEmailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCompanyEmailCountAggregateInputType | true
    }

  export interface ClientCompanyEmailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientCompanyEmail'], meta: { name: 'ClientCompanyEmail' } }
    /**
     * Find zero or one ClientCompanyEmail that matches the filter.
     * @param {ClientCompanyEmailFindUniqueArgs} args - Arguments to find a ClientCompanyEmail
     * @example
     * // Get one ClientCompanyEmail
     * const clientCompanyEmail = await prisma.clientCompanyEmail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientCompanyEmailFindUniqueArgs>(args: SelectSubset<T, ClientCompanyEmailFindUniqueArgs<ExtArgs>>): Prisma__ClientCompanyEmailClient<$Result.GetResult<Prisma.$ClientCompanyEmailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientCompanyEmail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientCompanyEmailFindUniqueOrThrowArgs} args - Arguments to find a ClientCompanyEmail
     * @example
     * // Get one ClientCompanyEmail
     * const clientCompanyEmail = await prisma.clientCompanyEmail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientCompanyEmailFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientCompanyEmailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientCompanyEmailClient<$Result.GetResult<Prisma.$ClientCompanyEmailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientCompanyEmail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyEmailFindFirstArgs} args - Arguments to find a ClientCompanyEmail
     * @example
     * // Get one ClientCompanyEmail
     * const clientCompanyEmail = await prisma.clientCompanyEmail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientCompanyEmailFindFirstArgs>(args?: SelectSubset<T, ClientCompanyEmailFindFirstArgs<ExtArgs>>): Prisma__ClientCompanyEmailClient<$Result.GetResult<Prisma.$ClientCompanyEmailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientCompanyEmail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyEmailFindFirstOrThrowArgs} args - Arguments to find a ClientCompanyEmail
     * @example
     * // Get one ClientCompanyEmail
     * const clientCompanyEmail = await prisma.clientCompanyEmail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientCompanyEmailFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientCompanyEmailFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientCompanyEmailClient<$Result.GetResult<Prisma.$ClientCompanyEmailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientCompanyEmails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyEmailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientCompanyEmails
     * const clientCompanyEmails = await prisma.clientCompanyEmail.findMany()
     * 
     * // Get first 10 ClientCompanyEmails
     * const clientCompanyEmails = await prisma.clientCompanyEmail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientCompanyEmailWithIdOnly = await prisma.clientCompanyEmail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientCompanyEmailFindManyArgs>(args?: SelectSubset<T, ClientCompanyEmailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientCompanyEmailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientCompanyEmail.
     * @param {ClientCompanyEmailCreateArgs} args - Arguments to create a ClientCompanyEmail.
     * @example
     * // Create one ClientCompanyEmail
     * const ClientCompanyEmail = await prisma.clientCompanyEmail.create({
     *   data: {
     *     // ... data to create a ClientCompanyEmail
     *   }
     * })
     * 
     */
    create<T extends ClientCompanyEmailCreateArgs>(args: SelectSubset<T, ClientCompanyEmailCreateArgs<ExtArgs>>): Prisma__ClientCompanyEmailClient<$Result.GetResult<Prisma.$ClientCompanyEmailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientCompanyEmails.
     * @param {ClientCompanyEmailCreateManyArgs} args - Arguments to create many ClientCompanyEmails.
     * @example
     * // Create many ClientCompanyEmails
     * const clientCompanyEmail = await prisma.clientCompanyEmail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCompanyEmailCreateManyArgs>(args?: SelectSubset<T, ClientCompanyEmailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientCompanyEmail.
     * @param {ClientCompanyEmailDeleteArgs} args - Arguments to delete one ClientCompanyEmail.
     * @example
     * // Delete one ClientCompanyEmail
     * const ClientCompanyEmail = await prisma.clientCompanyEmail.delete({
     *   where: {
     *     // ... filter to delete one ClientCompanyEmail
     *   }
     * })
     * 
     */
    delete<T extends ClientCompanyEmailDeleteArgs>(args: SelectSubset<T, ClientCompanyEmailDeleteArgs<ExtArgs>>): Prisma__ClientCompanyEmailClient<$Result.GetResult<Prisma.$ClientCompanyEmailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientCompanyEmail.
     * @param {ClientCompanyEmailUpdateArgs} args - Arguments to update one ClientCompanyEmail.
     * @example
     * // Update one ClientCompanyEmail
     * const clientCompanyEmail = await prisma.clientCompanyEmail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientCompanyEmailUpdateArgs>(args: SelectSubset<T, ClientCompanyEmailUpdateArgs<ExtArgs>>): Prisma__ClientCompanyEmailClient<$Result.GetResult<Prisma.$ClientCompanyEmailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientCompanyEmails.
     * @param {ClientCompanyEmailDeleteManyArgs} args - Arguments to filter ClientCompanyEmails to delete.
     * @example
     * // Delete a few ClientCompanyEmails
     * const { count } = await prisma.clientCompanyEmail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientCompanyEmailDeleteManyArgs>(args?: SelectSubset<T, ClientCompanyEmailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientCompanyEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyEmailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientCompanyEmails
     * const clientCompanyEmail = await prisma.clientCompanyEmail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientCompanyEmailUpdateManyArgs>(args: SelectSubset<T, ClientCompanyEmailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientCompanyEmail.
     * @param {ClientCompanyEmailUpsertArgs} args - Arguments to update or create a ClientCompanyEmail.
     * @example
     * // Update or create a ClientCompanyEmail
     * const clientCompanyEmail = await prisma.clientCompanyEmail.upsert({
     *   create: {
     *     // ... data to create a ClientCompanyEmail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientCompanyEmail we want to update
     *   }
     * })
     */
    upsert<T extends ClientCompanyEmailUpsertArgs>(args: SelectSubset<T, ClientCompanyEmailUpsertArgs<ExtArgs>>): Prisma__ClientCompanyEmailClient<$Result.GetResult<Prisma.$ClientCompanyEmailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientCompanyEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyEmailCountArgs} args - Arguments to filter ClientCompanyEmails to count.
     * @example
     * // Count the number of ClientCompanyEmails
     * const count = await prisma.clientCompanyEmail.count({
     *   where: {
     *     // ... the filter for the ClientCompanyEmails we want to count
     *   }
     * })
    **/
    count<T extends ClientCompanyEmailCountArgs>(
      args?: Subset<T, ClientCompanyEmailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCompanyEmailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientCompanyEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyEmailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientCompanyEmailAggregateArgs>(args: Subset<T, ClientCompanyEmailAggregateArgs>): Prisma.PrismaPromise<GetClientCompanyEmailAggregateType<T>>

    /**
     * Group by ClientCompanyEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyEmailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientCompanyEmailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientCompanyEmailGroupByArgs['orderBy'] }
        : { orderBy?: ClientCompanyEmailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientCompanyEmailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientCompanyEmailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientCompanyEmail model
   */
  readonly fields: ClientCompanyEmailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientCompanyEmail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientCompanyEmailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends ClientCompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientCompanyDefaultArgs<ExtArgs>>): Prisma__ClientCompanyClient<$Result.GetResult<Prisma.$ClientCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientCompanyEmail model
   */
  interface ClientCompanyEmailFieldRefs {
    readonly id: FieldRef<"ClientCompanyEmail", 'String'>
    readonly company_id: FieldRef<"ClientCompanyEmail", 'String'>
    readonly email: FieldRef<"ClientCompanyEmail", 'String'>
    readonly type: FieldRef<"ClientCompanyEmail", 'String'>
    readonly is_primary: FieldRef<"ClientCompanyEmail", 'Boolean'>
    readonly created_at: FieldRef<"ClientCompanyEmail", 'DateTime'>
    readonly updated_at: FieldRef<"ClientCompanyEmail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientCompanyEmail findUnique
   */
  export type ClientCompanyEmailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyEmail
     */
    select?: ClientCompanyEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyEmail
     */
    omit?: ClientCompanyEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyEmailInclude<ExtArgs> | null
    /**
     * Filter, which ClientCompanyEmail to fetch.
     */
    where: ClientCompanyEmailWhereUniqueInput
  }

  /**
   * ClientCompanyEmail findUniqueOrThrow
   */
  export type ClientCompanyEmailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyEmail
     */
    select?: ClientCompanyEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyEmail
     */
    omit?: ClientCompanyEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyEmailInclude<ExtArgs> | null
    /**
     * Filter, which ClientCompanyEmail to fetch.
     */
    where: ClientCompanyEmailWhereUniqueInput
  }

  /**
   * ClientCompanyEmail findFirst
   */
  export type ClientCompanyEmailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyEmail
     */
    select?: ClientCompanyEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyEmail
     */
    omit?: ClientCompanyEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyEmailInclude<ExtArgs> | null
    /**
     * Filter, which ClientCompanyEmail to fetch.
     */
    where?: ClientCompanyEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientCompanyEmails to fetch.
     */
    orderBy?: ClientCompanyEmailOrderByWithRelationInput | ClientCompanyEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientCompanyEmails.
     */
    cursor?: ClientCompanyEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientCompanyEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientCompanyEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientCompanyEmails.
     */
    distinct?: ClientCompanyEmailScalarFieldEnum | ClientCompanyEmailScalarFieldEnum[]
  }

  /**
   * ClientCompanyEmail findFirstOrThrow
   */
  export type ClientCompanyEmailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyEmail
     */
    select?: ClientCompanyEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyEmail
     */
    omit?: ClientCompanyEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyEmailInclude<ExtArgs> | null
    /**
     * Filter, which ClientCompanyEmail to fetch.
     */
    where?: ClientCompanyEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientCompanyEmails to fetch.
     */
    orderBy?: ClientCompanyEmailOrderByWithRelationInput | ClientCompanyEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientCompanyEmails.
     */
    cursor?: ClientCompanyEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientCompanyEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientCompanyEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientCompanyEmails.
     */
    distinct?: ClientCompanyEmailScalarFieldEnum | ClientCompanyEmailScalarFieldEnum[]
  }

  /**
   * ClientCompanyEmail findMany
   */
  export type ClientCompanyEmailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyEmail
     */
    select?: ClientCompanyEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyEmail
     */
    omit?: ClientCompanyEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyEmailInclude<ExtArgs> | null
    /**
     * Filter, which ClientCompanyEmails to fetch.
     */
    where?: ClientCompanyEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientCompanyEmails to fetch.
     */
    orderBy?: ClientCompanyEmailOrderByWithRelationInput | ClientCompanyEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientCompanyEmails.
     */
    cursor?: ClientCompanyEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientCompanyEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientCompanyEmails.
     */
    skip?: number
    distinct?: ClientCompanyEmailScalarFieldEnum | ClientCompanyEmailScalarFieldEnum[]
  }

  /**
   * ClientCompanyEmail create
   */
  export type ClientCompanyEmailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyEmail
     */
    select?: ClientCompanyEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyEmail
     */
    omit?: ClientCompanyEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyEmailInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientCompanyEmail.
     */
    data: XOR<ClientCompanyEmailCreateInput, ClientCompanyEmailUncheckedCreateInput>
  }

  /**
   * ClientCompanyEmail createMany
   */
  export type ClientCompanyEmailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientCompanyEmails.
     */
    data: ClientCompanyEmailCreateManyInput | ClientCompanyEmailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientCompanyEmail update
   */
  export type ClientCompanyEmailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyEmail
     */
    select?: ClientCompanyEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyEmail
     */
    omit?: ClientCompanyEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyEmailInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientCompanyEmail.
     */
    data: XOR<ClientCompanyEmailUpdateInput, ClientCompanyEmailUncheckedUpdateInput>
    /**
     * Choose, which ClientCompanyEmail to update.
     */
    where: ClientCompanyEmailWhereUniqueInput
  }

  /**
   * ClientCompanyEmail updateMany
   */
  export type ClientCompanyEmailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientCompanyEmails.
     */
    data: XOR<ClientCompanyEmailUpdateManyMutationInput, ClientCompanyEmailUncheckedUpdateManyInput>
    /**
     * Filter which ClientCompanyEmails to update
     */
    where?: ClientCompanyEmailWhereInput
    /**
     * Limit how many ClientCompanyEmails to update.
     */
    limit?: number
  }

  /**
   * ClientCompanyEmail upsert
   */
  export type ClientCompanyEmailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyEmail
     */
    select?: ClientCompanyEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyEmail
     */
    omit?: ClientCompanyEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyEmailInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientCompanyEmail to update in case it exists.
     */
    where: ClientCompanyEmailWhereUniqueInput
    /**
     * In case the ClientCompanyEmail found by the `where` argument doesn't exist, create a new ClientCompanyEmail with this data.
     */
    create: XOR<ClientCompanyEmailCreateInput, ClientCompanyEmailUncheckedCreateInput>
    /**
     * In case the ClientCompanyEmail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientCompanyEmailUpdateInput, ClientCompanyEmailUncheckedUpdateInput>
  }

  /**
   * ClientCompanyEmail delete
   */
  export type ClientCompanyEmailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyEmail
     */
    select?: ClientCompanyEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyEmail
     */
    omit?: ClientCompanyEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyEmailInclude<ExtArgs> | null
    /**
     * Filter which ClientCompanyEmail to delete.
     */
    where: ClientCompanyEmailWhereUniqueInput
  }

  /**
   * ClientCompanyEmail deleteMany
   */
  export type ClientCompanyEmailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientCompanyEmails to delete
     */
    where?: ClientCompanyEmailWhereInput
    /**
     * Limit how many ClientCompanyEmails to delete.
     */
    limit?: number
  }

  /**
   * ClientCompanyEmail without action
   */
  export type ClientCompanyEmailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyEmail
     */
    select?: ClientCompanyEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyEmail
     */
    omit?: ClientCompanyEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyEmailInclude<ExtArgs> | null
  }


  /**
   * Model ClientCompanyAddress
   */

  export type AggregateClientCompanyAddress = {
    _count: ClientCompanyAddressCountAggregateOutputType | null
    _min: ClientCompanyAddressMinAggregateOutputType | null
    _max: ClientCompanyAddressMaxAggregateOutputType | null
  }

  export type ClientCompanyAddressMinAggregateOutputType = {
    id: string | null
    company_id: string | null
    type: string | null
    street: string | null
    suite: string | null
    city: string | null
    state: string | null
    zip_code: string | null
    country: string | null
    is_primary: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientCompanyAddressMaxAggregateOutputType = {
    id: string | null
    company_id: string | null
    type: string | null
    street: string | null
    suite: string | null
    city: string | null
    state: string | null
    zip_code: string | null
    country: string | null
    is_primary: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientCompanyAddressCountAggregateOutputType = {
    id: number
    company_id: number
    type: number
    street: number
    suite: number
    city: number
    state: number
    zip_code: number
    country: number
    is_primary: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ClientCompanyAddressMinAggregateInputType = {
    id?: true
    company_id?: true
    type?: true
    street?: true
    suite?: true
    city?: true
    state?: true
    zip_code?: true
    country?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientCompanyAddressMaxAggregateInputType = {
    id?: true
    company_id?: true
    type?: true
    street?: true
    suite?: true
    city?: true
    state?: true
    zip_code?: true
    country?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientCompanyAddressCountAggregateInputType = {
    id?: true
    company_id?: true
    type?: true
    street?: true
    suite?: true
    city?: true
    state?: true
    zip_code?: true
    country?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ClientCompanyAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientCompanyAddress to aggregate.
     */
    where?: ClientCompanyAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientCompanyAddresses to fetch.
     */
    orderBy?: ClientCompanyAddressOrderByWithRelationInput | ClientCompanyAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientCompanyAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientCompanyAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientCompanyAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientCompanyAddresses
    **/
    _count?: true | ClientCompanyAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientCompanyAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientCompanyAddressMaxAggregateInputType
  }

  export type GetClientCompanyAddressAggregateType<T extends ClientCompanyAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateClientCompanyAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientCompanyAddress[P]>
      : GetScalarType<T[P], AggregateClientCompanyAddress[P]>
  }




  export type ClientCompanyAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientCompanyAddressWhereInput
    orderBy?: ClientCompanyAddressOrderByWithAggregationInput | ClientCompanyAddressOrderByWithAggregationInput[]
    by: ClientCompanyAddressScalarFieldEnum[] | ClientCompanyAddressScalarFieldEnum
    having?: ClientCompanyAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCompanyAddressCountAggregateInputType | true
    _min?: ClientCompanyAddressMinAggregateInputType
    _max?: ClientCompanyAddressMaxAggregateInputType
  }

  export type ClientCompanyAddressGroupByOutputType = {
    id: string
    company_id: string
    type: string
    street: string
    suite: string | null
    city: string
    state: string
    zip_code: string
    country: string
    is_primary: boolean
    created_at: Date
    updated_at: Date
    _count: ClientCompanyAddressCountAggregateOutputType | null
    _min: ClientCompanyAddressMinAggregateOutputType | null
    _max: ClientCompanyAddressMaxAggregateOutputType | null
  }

  type GetClientCompanyAddressGroupByPayload<T extends ClientCompanyAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientCompanyAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientCompanyAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientCompanyAddressGroupByOutputType[P]>
            : GetScalarType<T[P], ClientCompanyAddressGroupByOutputType[P]>
        }
      >
    >


  export type ClientCompanyAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    type?: boolean
    street?: boolean
    suite?: boolean
    city?: boolean
    state?: boolean
    zip_code?: boolean
    country?: boolean
    is_primary?: boolean
    created_at?: boolean
    updated_at?: boolean
    company?: boolean | ClientCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientCompanyAddress"]>



  export type ClientCompanyAddressSelectScalar = {
    id?: boolean
    company_id?: boolean
    type?: boolean
    street?: boolean
    suite?: boolean
    city?: boolean
    state?: boolean
    zip_code?: boolean
    country?: boolean
    is_primary?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ClientCompanyAddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_id" | "type" | "street" | "suite" | "city" | "state" | "zip_code" | "country" | "is_primary" | "created_at" | "updated_at", ExtArgs["result"]["clientCompanyAddress"]>
  export type ClientCompanyAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | ClientCompanyDefaultArgs<ExtArgs>
  }

  export type $ClientCompanyAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientCompanyAddress"
    objects: {
      company: Prisma.$ClientCompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      company_id: string
      type: string
      street: string
      suite: string | null
      city: string
      state: string
      zip_code: string
      country: string
      is_primary: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["clientCompanyAddress"]>
    composites: {}
  }

  type ClientCompanyAddressGetPayload<S extends boolean | null | undefined | ClientCompanyAddressDefaultArgs> = $Result.GetResult<Prisma.$ClientCompanyAddressPayload, S>

  type ClientCompanyAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientCompanyAddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCompanyAddressCountAggregateInputType | true
    }

  export interface ClientCompanyAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientCompanyAddress'], meta: { name: 'ClientCompanyAddress' } }
    /**
     * Find zero or one ClientCompanyAddress that matches the filter.
     * @param {ClientCompanyAddressFindUniqueArgs} args - Arguments to find a ClientCompanyAddress
     * @example
     * // Get one ClientCompanyAddress
     * const clientCompanyAddress = await prisma.clientCompanyAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientCompanyAddressFindUniqueArgs>(args: SelectSubset<T, ClientCompanyAddressFindUniqueArgs<ExtArgs>>): Prisma__ClientCompanyAddressClient<$Result.GetResult<Prisma.$ClientCompanyAddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientCompanyAddress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientCompanyAddressFindUniqueOrThrowArgs} args - Arguments to find a ClientCompanyAddress
     * @example
     * // Get one ClientCompanyAddress
     * const clientCompanyAddress = await prisma.clientCompanyAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientCompanyAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientCompanyAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientCompanyAddressClient<$Result.GetResult<Prisma.$ClientCompanyAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientCompanyAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyAddressFindFirstArgs} args - Arguments to find a ClientCompanyAddress
     * @example
     * // Get one ClientCompanyAddress
     * const clientCompanyAddress = await prisma.clientCompanyAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientCompanyAddressFindFirstArgs>(args?: SelectSubset<T, ClientCompanyAddressFindFirstArgs<ExtArgs>>): Prisma__ClientCompanyAddressClient<$Result.GetResult<Prisma.$ClientCompanyAddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientCompanyAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyAddressFindFirstOrThrowArgs} args - Arguments to find a ClientCompanyAddress
     * @example
     * // Get one ClientCompanyAddress
     * const clientCompanyAddress = await prisma.clientCompanyAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientCompanyAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientCompanyAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientCompanyAddressClient<$Result.GetResult<Prisma.$ClientCompanyAddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientCompanyAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientCompanyAddresses
     * const clientCompanyAddresses = await prisma.clientCompanyAddress.findMany()
     * 
     * // Get first 10 ClientCompanyAddresses
     * const clientCompanyAddresses = await prisma.clientCompanyAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientCompanyAddressWithIdOnly = await prisma.clientCompanyAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientCompanyAddressFindManyArgs>(args?: SelectSubset<T, ClientCompanyAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientCompanyAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientCompanyAddress.
     * @param {ClientCompanyAddressCreateArgs} args - Arguments to create a ClientCompanyAddress.
     * @example
     * // Create one ClientCompanyAddress
     * const ClientCompanyAddress = await prisma.clientCompanyAddress.create({
     *   data: {
     *     // ... data to create a ClientCompanyAddress
     *   }
     * })
     * 
     */
    create<T extends ClientCompanyAddressCreateArgs>(args: SelectSubset<T, ClientCompanyAddressCreateArgs<ExtArgs>>): Prisma__ClientCompanyAddressClient<$Result.GetResult<Prisma.$ClientCompanyAddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientCompanyAddresses.
     * @param {ClientCompanyAddressCreateManyArgs} args - Arguments to create many ClientCompanyAddresses.
     * @example
     * // Create many ClientCompanyAddresses
     * const clientCompanyAddress = await prisma.clientCompanyAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCompanyAddressCreateManyArgs>(args?: SelectSubset<T, ClientCompanyAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientCompanyAddress.
     * @param {ClientCompanyAddressDeleteArgs} args - Arguments to delete one ClientCompanyAddress.
     * @example
     * // Delete one ClientCompanyAddress
     * const ClientCompanyAddress = await prisma.clientCompanyAddress.delete({
     *   where: {
     *     // ... filter to delete one ClientCompanyAddress
     *   }
     * })
     * 
     */
    delete<T extends ClientCompanyAddressDeleteArgs>(args: SelectSubset<T, ClientCompanyAddressDeleteArgs<ExtArgs>>): Prisma__ClientCompanyAddressClient<$Result.GetResult<Prisma.$ClientCompanyAddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientCompanyAddress.
     * @param {ClientCompanyAddressUpdateArgs} args - Arguments to update one ClientCompanyAddress.
     * @example
     * // Update one ClientCompanyAddress
     * const clientCompanyAddress = await prisma.clientCompanyAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientCompanyAddressUpdateArgs>(args: SelectSubset<T, ClientCompanyAddressUpdateArgs<ExtArgs>>): Prisma__ClientCompanyAddressClient<$Result.GetResult<Prisma.$ClientCompanyAddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientCompanyAddresses.
     * @param {ClientCompanyAddressDeleteManyArgs} args - Arguments to filter ClientCompanyAddresses to delete.
     * @example
     * // Delete a few ClientCompanyAddresses
     * const { count } = await prisma.clientCompanyAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientCompanyAddressDeleteManyArgs>(args?: SelectSubset<T, ClientCompanyAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientCompanyAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientCompanyAddresses
     * const clientCompanyAddress = await prisma.clientCompanyAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientCompanyAddressUpdateManyArgs>(args: SelectSubset<T, ClientCompanyAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientCompanyAddress.
     * @param {ClientCompanyAddressUpsertArgs} args - Arguments to update or create a ClientCompanyAddress.
     * @example
     * // Update or create a ClientCompanyAddress
     * const clientCompanyAddress = await prisma.clientCompanyAddress.upsert({
     *   create: {
     *     // ... data to create a ClientCompanyAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientCompanyAddress we want to update
     *   }
     * })
     */
    upsert<T extends ClientCompanyAddressUpsertArgs>(args: SelectSubset<T, ClientCompanyAddressUpsertArgs<ExtArgs>>): Prisma__ClientCompanyAddressClient<$Result.GetResult<Prisma.$ClientCompanyAddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientCompanyAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyAddressCountArgs} args - Arguments to filter ClientCompanyAddresses to count.
     * @example
     * // Count the number of ClientCompanyAddresses
     * const count = await prisma.clientCompanyAddress.count({
     *   where: {
     *     // ... the filter for the ClientCompanyAddresses we want to count
     *   }
     * })
    **/
    count<T extends ClientCompanyAddressCountArgs>(
      args?: Subset<T, ClientCompanyAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCompanyAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientCompanyAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientCompanyAddressAggregateArgs>(args: Subset<T, ClientCompanyAddressAggregateArgs>): Prisma.PrismaPromise<GetClientCompanyAddressAggregateType<T>>

    /**
     * Group by ClientCompanyAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCompanyAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientCompanyAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientCompanyAddressGroupByArgs['orderBy'] }
        : { orderBy?: ClientCompanyAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientCompanyAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientCompanyAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientCompanyAddress model
   */
  readonly fields: ClientCompanyAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientCompanyAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientCompanyAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends ClientCompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientCompanyDefaultArgs<ExtArgs>>): Prisma__ClientCompanyClient<$Result.GetResult<Prisma.$ClientCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientCompanyAddress model
   */
  interface ClientCompanyAddressFieldRefs {
    readonly id: FieldRef<"ClientCompanyAddress", 'String'>
    readonly company_id: FieldRef<"ClientCompanyAddress", 'String'>
    readonly type: FieldRef<"ClientCompanyAddress", 'String'>
    readonly street: FieldRef<"ClientCompanyAddress", 'String'>
    readonly suite: FieldRef<"ClientCompanyAddress", 'String'>
    readonly city: FieldRef<"ClientCompanyAddress", 'String'>
    readonly state: FieldRef<"ClientCompanyAddress", 'String'>
    readonly zip_code: FieldRef<"ClientCompanyAddress", 'String'>
    readonly country: FieldRef<"ClientCompanyAddress", 'String'>
    readonly is_primary: FieldRef<"ClientCompanyAddress", 'Boolean'>
    readonly created_at: FieldRef<"ClientCompanyAddress", 'DateTime'>
    readonly updated_at: FieldRef<"ClientCompanyAddress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientCompanyAddress findUnique
   */
  export type ClientCompanyAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyAddress
     */
    select?: ClientCompanyAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyAddress
     */
    omit?: ClientCompanyAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyAddressInclude<ExtArgs> | null
    /**
     * Filter, which ClientCompanyAddress to fetch.
     */
    where: ClientCompanyAddressWhereUniqueInput
  }

  /**
   * ClientCompanyAddress findUniqueOrThrow
   */
  export type ClientCompanyAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyAddress
     */
    select?: ClientCompanyAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyAddress
     */
    omit?: ClientCompanyAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyAddressInclude<ExtArgs> | null
    /**
     * Filter, which ClientCompanyAddress to fetch.
     */
    where: ClientCompanyAddressWhereUniqueInput
  }

  /**
   * ClientCompanyAddress findFirst
   */
  export type ClientCompanyAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyAddress
     */
    select?: ClientCompanyAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyAddress
     */
    omit?: ClientCompanyAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyAddressInclude<ExtArgs> | null
    /**
     * Filter, which ClientCompanyAddress to fetch.
     */
    where?: ClientCompanyAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientCompanyAddresses to fetch.
     */
    orderBy?: ClientCompanyAddressOrderByWithRelationInput | ClientCompanyAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientCompanyAddresses.
     */
    cursor?: ClientCompanyAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientCompanyAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientCompanyAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientCompanyAddresses.
     */
    distinct?: ClientCompanyAddressScalarFieldEnum | ClientCompanyAddressScalarFieldEnum[]
  }

  /**
   * ClientCompanyAddress findFirstOrThrow
   */
  export type ClientCompanyAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyAddress
     */
    select?: ClientCompanyAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyAddress
     */
    omit?: ClientCompanyAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyAddressInclude<ExtArgs> | null
    /**
     * Filter, which ClientCompanyAddress to fetch.
     */
    where?: ClientCompanyAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientCompanyAddresses to fetch.
     */
    orderBy?: ClientCompanyAddressOrderByWithRelationInput | ClientCompanyAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientCompanyAddresses.
     */
    cursor?: ClientCompanyAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientCompanyAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientCompanyAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientCompanyAddresses.
     */
    distinct?: ClientCompanyAddressScalarFieldEnum | ClientCompanyAddressScalarFieldEnum[]
  }

  /**
   * ClientCompanyAddress findMany
   */
  export type ClientCompanyAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyAddress
     */
    select?: ClientCompanyAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyAddress
     */
    omit?: ClientCompanyAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyAddressInclude<ExtArgs> | null
    /**
     * Filter, which ClientCompanyAddresses to fetch.
     */
    where?: ClientCompanyAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientCompanyAddresses to fetch.
     */
    orderBy?: ClientCompanyAddressOrderByWithRelationInput | ClientCompanyAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientCompanyAddresses.
     */
    cursor?: ClientCompanyAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientCompanyAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientCompanyAddresses.
     */
    skip?: number
    distinct?: ClientCompanyAddressScalarFieldEnum | ClientCompanyAddressScalarFieldEnum[]
  }

  /**
   * ClientCompanyAddress create
   */
  export type ClientCompanyAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyAddress
     */
    select?: ClientCompanyAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyAddress
     */
    omit?: ClientCompanyAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientCompanyAddress.
     */
    data: XOR<ClientCompanyAddressCreateInput, ClientCompanyAddressUncheckedCreateInput>
  }

  /**
   * ClientCompanyAddress createMany
   */
  export type ClientCompanyAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientCompanyAddresses.
     */
    data: ClientCompanyAddressCreateManyInput | ClientCompanyAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientCompanyAddress update
   */
  export type ClientCompanyAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyAddress
     */
    select?: ClientCompanyAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyAddress
     */
    omit?: ClientCompanyAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientCompanyAddress.
     */
    data: XOR<ClientCompanyAddressUpdateInput, ClientCompanyAddressUncheckedUpdateInput>
    /**
     * Choose, which ClientCompanyAddress to update.
     */
    where: ClientCompanyAddressWhereUniqueInput
  }

  /**
   * ClientCompanyAddress updateMany
   */
  export type ClientCompanyAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientCompanyAddresses.
     */
    data: XOR<ClientCompanyAddressUpdateManyMutationInput, ClientCompanyAddressUncheckedUpdateManyInput>
    /**
     * Filter which ClientCompanyAddresses to update
     */
    where?: ClientCompanyAddressWhereInput
    /**
     * Limit how many ClientCompanyAddresses to update.
     */
    limit?: number
  }

  /**
   * ClientCompanyAddress upsert
   */
  export type ClientCompanyAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyAddress
     */
    select?: ClientCompanyAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyAddress
     */
    omit?: ClientCompanyAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientCompanyAddress to update in case it exists.
     */
    where: ClientCompanyAddressWhereUniqueInput
    /**
     * In case the ClientCompanyAddress found by the `where` argument doesn't exist, create a new ClientCompanyAddress with this data.
     */
    create: XOR<ClientCompanyAddressCreateInput, ClientCompanyAddressUncheckedCreateInput>
    /**
     * In case the ClientCompanyAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientCompanyAddressUpdateInput, ClientCompanyAddressUncheckedUpdateInput>
  }

  /**
   * ClientCompanyAddress delete
   */
  export type ClientCompanyAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyAddress
     */
    select?: ClientCompanyAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyAddress
     */
    omit?: ClientCompanyAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyAddressInclude<ExtArgs> | null
    /**
     * Filter which ClientCompanyAddress to delete.
     */
    where: ClientCompanyAddressWhereUniqueInput
  }

  /**
   * ClientCompanyAddress deleteMany
   */
  export type ClientCompanyAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientCompanyAddresses to delete
     */
    where?: ClientCompanyAddressWhereInput
    /**
     * Limit how many ClientCompanyAddresses to delete.
     */
    limit?: number
  }

  /**
   * ClientCompanyAddress without action
   */
  export type ClientCompanyAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompanyAddress
     */
    select?: ClientCompanyAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompanyAddress
     */
    omit?: ClientCompanyAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyAddressInclude<ExtArgs> | null
  }


  /**
   * Model UnitOfMeasure
   */

  export type AggregateUnitOfMeasure = {
    _count: UnitOfMeasureCountAggregateOutputType | null
    _min: UnitOfMeasureMinAggregateOutputType | null
    _max: UnitOfMeasureMaxAggregateOutputType | null
  }

  export type UnitOfMeasureMinAggregateOutputType = {
    id: string | null
    account_id: string | null
    name: string | null
    symbol: string | null
    description: string | null
    is_default: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UnitOfMeasureMaxAggregateOutputType = {
    id: string | null
    account_id: string | null
    name: string | null
    symbol: string | null
    description: string | null
    is_default: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UnitOfMeasureCountAggregateOutputType = {
    id: number
    account_id: number
    name: number
    symbol: number
    description: number
    is_default: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UnitOfMeasureMinAggregateInputType = {
    id?: true
    account_id?: true
    name?: true
    symbol?: true
    description?: true
    is_default?: true
    created_at?: true
    updated_at?: true
  }

  export type UnitOfMeasureMaxAggregateInputType = {
    id?: true
    account_id?: true
    name?: true
    symbol?: true
    description?: true
    is_default?: true
    created_at?: true
    updated_at?: true
  }

  export type UnitOfMeasureCountAggregateInputType = {
    id?: true
    account_id?: true
    name?: true
    symbol?: true
    description?: true
    is_default?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UnitOfMeasureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitOfMeasure to aggregate.
     */
    where?: UnitOfMeasureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOfMeasures to fetch.
     */
    orderBy?: UnitOfMeasureOrderByWithRelationInput | UnitOfMeasureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitOfMeasureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOfMeasures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOfMeasures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitOfMeasures
    **/
    _count?: true | UnitOfMeasureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitOfMeasureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitOfMeasureMaxAggregateInputType
  }

  export type GetUnitOfMeasureAggregateType<T extends UnitOfMeasureAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitOfMeasure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitOfMeasure[P]>
      : GetScalarType<T[P], AggregateUnitOfMeasure[P]>
  }




  export type UnitOfMeasureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitOfMeasureWhereInput
    orderBy?: UnitOfMeasureOrderByWithAggregationInput | UnitOfMeasureOrderByWithAggregationInput[]
    by: UnitOfMeasureScalarFieldEnum[] | UnitOfMeasureScalarFieldEnum
    having?: UnitOfMeasureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitOfMeasureCountAggregateInputType | true
    _min?: UnitOfMeasureMinAggregateInputType
    _max?: UnitOfMeasureMaxAggregateInputType
  }

  export type UnitOfMeasureGroupByOutputType = {
    id: string
    account_id: string
    name: string
    symbol: string
    description: string | null
    is_default: boolean
    created_at: Date
    updated_at: Date
    _count: UnitOfMeasureCountAggregateOutputType | null
    _min: UnitOfMeasureMinAggregateOutputType | null
    _max: UnitOfMeasureMaxAggregateOutputType | null
  }

  type GetUnitOfMeasureGroupByPayload<T extends UnitOfMeasureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitOfMeasureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitOfMeasureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitOfMeasureGroupByOutputType[P]>
            : GetScalarType<T[P], UnitOfMeasureGroupByOutputType[P]>
        }
      >
    >


  export type UnitOfMeasureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    name?: boolean
    symbol?: boolean
    description?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
    services?: boolean | UnitOfMeasure$servicesArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    _count?: boolean | UnitOfMeasureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitOfMeasure"]>



  export type UnitOfMeasureSelectScalar = {
    id?: boolean
    account_id?: boolean
    name?: boolean
    symbol?: boolean
    description?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UnitOfMeasureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "account_id" | "name" | "symbol" | "description" | "is_default" | "created_at" | "updated_at", ExtArgs["result"]["unitOfMeasure"]>
  export type UnitOfMeasureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | UnitOfMeasure$servicesArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    _count?: boolean | UnitOfMeasureCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UnitOfMeasurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitOfMeasure"
    objects: {
      services: Prisma.$ServicePayload<ExtArgs>[]
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      account_id: string
      name: string
      symbol: string
      description: string | null
      is_default: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["unitOfMeasure"]>
    composites: {}
  }

  type UnitOfMeasureGetPayload<S extends boolean | null | undefined | UnitOfMeasureDefaultArgs> = $Result.GetResult<Prisma.$UnitOfMeasurePayload, S>

  type UnitOfMeasureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitOfMeasureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitOfMeasureCountAggregateInputType | true
    }

  export interface UnitOfMeasureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitOfMeasure'], meta: { name: 'UnitOfMeasure' } }
    /**
     * Find zero or one UnitOfMeasure that matches the filter.
     * @param {UnitOfMeasureFindUniqueArgs} args - Arguments to find a UnitOfMeasure
     * @example
     * // Get one UnitOfMeasure
     * const unitOfMeasure = await prisma.unitOfMeasure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitOfMeasureFindUniqueArgs>(args: SelectSubset<T, UnitOfMeasureFindUniqueArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitOfMeasure that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitOfMeasureFindUniqueOrThrowArgs} args - Arguments to find a UnitOfMeasure
     * @example
     * // Get one UnitOfMeasure
     * const unitOfMeasure = await prisma.unitOfMeasure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitOfMeasureFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitOfMeasureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitOfMeasure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasureFindFirstArgs} args - Arguments to find a UnitOfMeasure
     * @example
     * // Get one UnitOfMeasure
     * const unitOfMeasure = await prisma.unitOfMeasure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitOfMeasureFindFirstArgs>(args?: SelectSubset<T, UnitOfMeasureFindFirstArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitOfMeasure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasureFindFirstOrThrowArgs} args - Arguments to find a UnitOfMeasure
     * @example
     * // Get one UnitOfMeasure
     * const unitOfMeasure = await prisma.unitOfMeasure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitOfMeasureFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitOfMeasureFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitOfMeasures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitOfMeasures
     * const unitOfMeasures = await prisma.unitOfMeasure.findMany()
     * 
     * // Get first 10 UnitOfMeasures
     * const unitOfMeasures = await prisma.unitOfMeasure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitOfMeasureWithIdOnly = await prisma.unitOfMeasure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitOfMeasureFindManyArgs>(args?: SelectSubset<T, UnitOfMeasureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitOfMeasure.
     * @param {UnitOfMeasureCreateArgs} args - Arguments to create a UnitOfMeasure.
     * @example
     * // Create one UnitOfMeasure
     * const UnitOfMeasure = await prisma.unitOfMeasure.create({
     *   data: {
     *     // ... data to create a UnitOfMeasure
     *   }
     * })
     * 
     */
    create<T extends UnitOfMeasureCreateArgs>(args: SelectSubset<T, UnitOfMeasureCreateArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitOfMeasures.
     * @param {UnitOfMeasureCreateManyArgs} args - Arguments to create many UnitOfMeasures.
     * @example
     * // Create many UnitOfMeasures
     * const unitOfMeasure = await prisma.unitOfMeasure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitOfMeasureCreateManyArgs>(args?: SelectSubset<T, UnitOfMeasureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UnitOfMeasure.
     * @param {UnitOfMeasureDeleteArgs} args - Arguments to delete one UnitOfMeasure.
     * @example
     * // Delete one UnitOfMeasure
     * const UnitOfMeasure = await prisma.unitOfMeasure.delete({
     *   where: {
     *     // ... filter to delete one UnitOfMeasure
     *   }
     * })
     * 
     */
    delete<T extends UnitOfMeasureDeleteArgs>(args: SelectSubset<T, UnitOfMeasureDeleteArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitOfMeasure.
     * @param {UnitOfMeasureUpdateArgs} args - Arguments to update one UnitOfMeasure.
     * @example
     * // Update one UnitOfMeasure
     * const unitOfMeasure = await prisma.unitOfMeasure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitOfMeasureUpdateArgs>(args: SelectSubset<T, UnitOfMeasureUpdateArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitOfMeasures.
     * @param {UnitOfMeasureDeleteManyArgs} args - Arguments to filter UnitOfMeasures to delete.
     * @example
     * // Delete a few UnitOfMeasures
     * const { count } = await prisma.unitOfMeasure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitOfMeasureDeleteManyArgs>(args?: SelectSubset<T, UnitOfMeasureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitOfMeasures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitOfMeasures
     * const unitOfMeasure = await prisma.unitOfMeasure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitOfMeasureUpdateManyArgs>(args: SelectSubset<T, UnitOfMeasureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UnitOfMeasure.
     * @param {UnitOfMeasureUpsertArgs} args - Arguments to update or create a UnitOfMeasure.
     * @example
     * // Update or create a UnitOfMeasure
     * const unitOfMeasure = await prisma.unitOfMeasure.upsert({
     *   create: {
     *     // ... data to create a UnitOfMeasure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitOfMeasure we want to update
     *   }
     * })
     */
    upsert<T extends UnitOfMeasureUpsertArgs>(args: SelectSubset<T, UnitOfMeasureUpsertArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitOfMeasures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasureCountArgs} args - Arguments to filter UnitOfMeasures to count.
     * @example
     * // Count the number of UnitOfMeasures
     * const count = await prisma.unitOfMeasure.count({
     *   where: {
     *     // ... the filter for the UnitOfMeasures we want to count
     *   }
     * })
    **/
    count<T extends UnitOfMeasureCountArgs>(
      args?: Subset<T, UnitOfMeasureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitOfMeasureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitOfMeasure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitOfMeasureAggregateArgs>(args: Subset<T, UnitOfMeasureAggregateArgs>): Prisma.PrismaPromise<GetUnitOfMeasureAggregateType<T>>

    /**
     * Group by UnitOfMeasure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitOfMeasureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitOfMeasureGroupByArgs['orderBy'] }
        : { orderBy?: UnitOfMeasureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitOfMeasureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitOfMeasureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitOfMeasure model
   */
  readonly fields: UnitOfMeasureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitOfMeasure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitOfMeasureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    services<T extends UnitOfMeasure$servicesArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasure$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitOfMeasure model
   */
  interface UnitOfMeasureFieldRefs {
    readonly id: FieldRef<"UnitOfMeasure", 'String'>
    readonly account_id: FieldRef<"UnitOfMeasure", 'String'>
    readonly name: FieldRef<"UnitOfMeasure", 'String'>
    readonly symbol: FieldRef<"UnitOfMeasure", 'String'>
    readonly description: FieldRef<"UnitOfMeasure", 'String'>
    readonly is_default: FieldRef<"UnitOfMeasure", 'Boolean'>
    readonly created_at: FieldRef<"UnitOfMeasure", 'DateTime'>
    readonly updated_at: FieldRef<"UnitOfMeasure", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitOfMeasure findUnique
   */
  export type UnitOfMeasureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasure
     */
    select?: UnitOfMeasureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasure
     */
    omit?: UnitOfMeasureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasureInclude<ExtArgs> | null
    /**
     * Filter, which UnitOfMeasure to fetch.
     */
    where: UnitOfMeasureWhereUniqueInput
  }

  /**
   * UnitOfMeasure findUniqueOrThrow
   */
  export type UnitOfMeasureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasure
     */
    select?: UnitOfMeasureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasure
     */
    omit?: UnitOfMeasureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasureInclude<ExtArgs> | null
    /**
     * Filter, which UnitOfMeasure to fetch.
     */
    where: UnitOfMeasureWhereUniqueInput
  }

  /**
   * UnitOfMeasure findFirst
   */
  export type UnitOfMeasureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasure
     */
    select?: UnitOfMeasureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasure
     */
    omit?: UnitOfMeasureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasureInclude<ExtArgs> | null
    /**
     * Filter, which UnitOfMeasure to fetch.
     */
    where?: UnitOfMeasureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOfMeasures to fetch.
     */
    orderBy?: UnitOfMeasureOrderByWithRelationInput | UnitOfMeasureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitOfMeasures.
     */
    cursor?: UnitOfMeasureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOfMeasures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOfMeasures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitOfMeasures.
     */
    distinct?: UnitOfMeasureScalarFieldEnum | UnitOfMeasureScalarFieldEnum[]
  }

  /**
   * UnitOfMeasure findFirstOrThrow
   */
  export type UnitOfMeasureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasure
     */
    select?: UnitOfMeasureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasure
     */
    omit?: UnitOfMeasureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasureInclude<ExtArgs> | null
    /**
     * Filter, which UnitOfMeasure to fetch.
     */
    where?: UnitOfMeasureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOfMeasures to fetch.
     */
    orderBy?: UnitOfMeasureOrderByWithRelationInput | UnitOfMeasureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitOfMeasures.
     */
    cursor?: UnitOfMeasureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOfMeasures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOfMeasures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitOfMeasures.
     */
    distinct?: UnitOfMeasureScalarFieldEnum | UnitOfMeasureScalarFieldEnum[]
  }

  /**
   * UnitOfMeasure findMany
   */
  export type UnitOfMeasureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasure
     */
    select?: UnitOfMeasureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasure
     */
    omit?: UnitOfMeasureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasureInclude<ExtArgs> | null
    /**
     * Filter, which UnitOfMeasures to fetch.
     */
    where?: UnitOfMeasureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOfMeasures to fetch.
     */
    orderBy?: UnitOfMeasureOrderByWithRelationInput | UnitOfMeasureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitOfMeasures.
     */
    cursor?: UnitOfMeasureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOfMeasures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOfMeasures.
     */
    skip?: number
    distinct?: UnitOfMeasureScalarFieldEnum | UnitOfMeasureScalarFieldEnum[]
  }

  /**
   * UnitOfMeasure create
   */
  export type UnitOfMeasureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasure
     */
    select?: UnitOfMeasureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasure
     */
    omit?: UnitOfMeasureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasureInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitOfMeasure.
     */
    data: XOR<UnitOfMeasureCreateInput, UnitOfMeasureUncheckedCreateInput>
  }

  /**
   * UnitOfMeasure createMany
   */
  export type UnitOfMeasureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitOfMeasures.
     */
    data: UnitOfMeasureCreateManyInput | UnitOfMeasureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitOfMeasure update
   */
  export type UnitOfMeasureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasure
     */
    select?: UnitOfMeasureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasure
     */
    omit?: UnitOfMeasureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasureInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitOfMeasure.
     */
    data: XOR<UnitOfMeasureUpdateInput, UnitOfMeasureUncheckedUpdateInput>
    /**
     * Choose, which UnitOfMeasure to update.
     */
    where: UnitOfMeasureWhereUniqueInput
  }

  /**
   * UnitOfMeasure updateMany
   */
  export type UnitOfMeasureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitOfMeasures.
     */
    data: XOR<UnitOfMeasureUpdateManyMutationInput, UnitOfMeasureUncheckedUpdateManyInput>
    /**
     * Filter which UnitOfMeasures to update
     */
    where?: UnitOfMeasureWhereInput
    /**
     * Limit how many UnitOfMeasures to update.
     */
    limit?: number
  }

  /**
   * UnitOfMeasure upsert
   */
  export type UnitOfMeasureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasure
     */
    select?: UnitOfMeasureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasure
     */
    omit?: UnitOfMeasureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasureInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitOfMeasure to update in case it exists.
     */
    where: UnitOfMeasureWhereUniqueInput
    /**
     * In case the UnitOfMeasure found by the `where` argument doesn't exist, create a new UnitOfMeasure with this data.
     */
    create: XOR<UnitOfMeasureCreateInput, UnitOfMeasureUncheckedCreateInput>
    /**
     * In case the UnitOfMeasure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitOfMeasureUpdateInput, UnitOfMeasureUncheckedUpdateInput>
  }

  /**
   * UnitOfMeasure delete
   */
  export type UnitOfMeasureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasure
     */
    select?: UnitOfMeasureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasure
     */
    omit?: UnitOfMeasureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasureInclude<ExtArgs> | null
    /**
     * Filter which UnitOfMeasure to delete.
     */
    where: UnitOfMeasureWhereUniqueInput
  }

  /**
   * UnitOfMeasure deleteMany
   */
  export type UnitOfMeasureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitOfMeasures to delete
     */
    where?: UnitOfMeasureWhereInput
    /**
     * Limit how many UnitOfMeasures to delete.
     */
    limit?: number
  }

  /**
   * UnitOfMeasure.services
   */
  export type UnitOfMeasure$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * UnitOfMeasure without action
   */
  export type UnitOfMeasureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasure
     */
    select?: UnitOfMeasureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasure
     */
    omit?: UnitOfMeasureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasureInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type ServiceSumAggregateOutputType = {
    price: Decimal | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    account_id: string | null
    name: string | null
    description: string | null
    price: Decimal | null
    unit_of_measure_id: string | null
    is_discount: boolean | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    account_id: string | null
    name: string | null
    description: string | null
    price: Decimal | null
    unit_of_measure_id: string | null
    is_discount: boolean | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    account_id: number
    name: number
    description: number
    price: number
    unit_of_measure_id: number
    is_discount: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    price?: true
  }

  export type ServiceSumAggregateInputType = {
    price?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    account_id?: true
    name?: true
    description?: true
    price?: true
    unit_of_measure_id?: true
    is_discount?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    account_id?: true
    name?: true
    description?: true
    price?: true
    unit_of_measure_id?: true
    is_discount?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    account_id?: true
    name?: true
    description?: true
    price?: true
    unit_of_measure_id?: true
    is_discount?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    account_id: string
    name: string
    description: string | null
    price: Decimal
    unit_of_measure_id: string
    is_discount: boolean
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    unit_of_measure_id?: boolean
    is_discount?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    billing_items?: boolean | Service$billing_itemsArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    unit_of_measure?: boolean | UnitOfMeasureDefaultArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>



  export type ServiceSelectScalar = {
    id?: boolean
    account_id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    unit_of_measure_id?: boolean
    is_discount?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "account_id" | "name" | "description" | "price" | "unit_of_measure_id" | "is_discount" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billing_items?: boolean | Service$billing_itemsArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    unit_of_measure?: boolean | UnitOfMeasureDefaultArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      billing_items: Prisma.$BillingItemPayload<ExtArgs>[]
      account: Prisma.$AccountPayload<ExtArgs>
      unit_of_measure: Prisma.$UnitOfMeasurePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      account_id: string
      name: string
      description: string | null
      price: Prisma.Decimal
      unit_of_measure_id: string
      is_discount: boolean
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    billing_items<T extends Service$billing_itemsArgs<ExtArgs> = {}>(args?: Subset<T, Service$billing_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit_of_measure<T extends UnitOfMeasureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasureDefaultArgs<ExtArgs>>): Prisma__UnitOfMeasureClient<$Result.GetResult<Prisma.$UnitOfMeasurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly account_id: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly price: FieldRef<"Service", 'Decimal'>
    readonly unit_of_measure_id: FieldRef<"Service", 'String'>
    readonly is_discount: FieldRef<"Service", 'Boolean'>
    readonly is_active: FieldRef<"Service", 'Boolean'>
    readonly created_at: FieldRef<"Service", 'DateTime'>
    readonly updated_at: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.billing_items
   */
  export type Service$billing_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingItem
     */
    select?: BillingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingItem
     */
    omit?: BillingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingItemInclude<ExtArgs> | null
    where?: BillingItemWhereInput
    orderBy?: BillingItemOrderByWithRelationInput | BillingItemOrderByWithRelationInput[]
    cursor?: BillingItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillingItemScalarFieldEnum | BillingItemScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model Billing
   */

  export type AggregateBilling = {
    _count: BillingCountAggregateOutputType | null
    _avg: BillingAvgAggregateOutputType | null
    _sum: BillingSumAggregateOutputType | null
    _min: BillingMinAggregateOutputType | null
    _max: BillingMaxAggregateOutputType | null
  }

  export type BillingAvgAggregateOutputType = {
    invoice_sequence: number | null
    subtotal_amount: Decimal | null
    tax_amount: Decimal | null
    discount_amount: Decimal | null
    total_amount: Decimal | null
  }

  export type BillingSumAggregateOutputType = {
    invoice_sequence: number | null
    subtotal_amount: Decimal | null
    tax_amount: Decimal | null
    discount_amount: Decimal | null
    total_amount: Decimal | null
  }

  export type BillingMinAggregateOutputType = {
    id: string | null
    account_id: string | null
    client_id: string | null
    client_company_id: string | null
    billing_date: Date | null
    due_date: Date | null
    invoice_number: string | null
    invoice_prefix: string | null
    invoice_sequence: number | null
    billing_address: string | null
    subtotal_amount: Decimal | null
    tax_amount: Decimal | null
    discount_amount: Decimal | null
    total_amount: Decimal | null
    notes: string | null
    status: $Enums.BillingStatus | null
    cancellation_date: Date | null
    cancellation_reason: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type BillingMaxAggregateOutputType = {
    id: string | null
    account_id: string | null
    client_id: string | null
    client_company_id: string | null
    billing_date: Date | null
    due_date: Date | null
    invoice_number: string | null
    invoice_prefix: string | null
    invoice_sequence: number | null
    billing_address: string | null
    subtotal_amount: Decimal | null
    tax_amount: Decimal | null
    discount_amount: Decimal | null
    total_amount: Decimal | null
    notes: string | null
    status: $Enums.BillingStatus | null
    cancellation_date: Date | null
    cancellation_reason: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type BillingCountAggregateOutputType = {
    id: number
    account_id: number
    client_id: number
    client_company_id: number
    billing_date: number
    due_date: number
    invoice_number: number
    invoice_prefix: number
    invoice_sequence: number
    billing_address: number
    subtotal_amount: number
    tax_amount: number
    discount_amount: number
    total_amount: number
    notes: number
    status: number
    cancellation_date: number
    cancellation_reason: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    _all: number
  }


  export type BillingAvgAggregateInputType = {
    invoice_sequence?: true
    subtotal_amount?: true
    tax_amount?: true
    discount_amount?: true
    total_amount?: true
  }

  export type BillingSumAggregateInputType = {
    invoice_sequence?: true
    subtotal_amount?: true
    tax_amount?: true
    discount_amount?: true
    total_amount?: true
  }

  export type BillingMinAggregateInputType = {
    id?: true
    account_id?: true
    client_id?: true
    client_company_id?: true
    billing_date?: true
    due_date?: true
    invoice_number?: true
    invoice_prefix?: true
    invoice_sequence?: true
    billing_address?: true
    subtotal_amount?: true
    tax_amount?: true
    discount_amount?: true
    total_amount?: true
    notes?: true
    status?: true
    cancellation_date?: true
    cancellation_reason?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type BillingMaxAggregateInputType = {
    id?: true
    account_id?: true
    client_id?: true
    client_company_id?: true
    billing_date?: true
    due_date?: true
    invoice_number?: true
    invoice_prefix?: true
    invoice_sequence?: true
    billing_address?: true
    subtotal_amount?: true
    tax_amount?: true
    discount_amount?: true
    total_amount?: true
    notes?: true
    status?: true
    cancellation_date?: true
    cancellation_reason?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type BillingCountAggregateInputType = {
    id?: true
    account_id?: true
    client_id?: true
    client_company_id?: true
    billing_date?: true
    due_date?: true
    invoice_number?: true
    invoice_prefix?: true
    invoice_sequence?: true
    billing_address?: true
    subtotal_amount?: true
    tax_amount?: true
    discount_amount?: true
    total_amount?: true
    notes?: true
    status?: true
    cancellation_date?: true
    cancellation_reason?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type BillingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Billing to aggregate.
     */
    where?: BillingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Billings to fetch.
     */
    orderBy?: BillingOrderByWithRelationInput | BillingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Billings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Billings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Billings
    **/
    _count?: true | BillingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingMaxAggregateInputType
  }

  export type GetBillingAggregateType<T extends BillingAggregateArgs> = {
        [P in keyof T & keyof AggregateBilling]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBilling[P]>
      : GetScalarType<T[P], AggregateBilling[P]>
  }




  export type BillingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingWhereInput
    orderBy?: BillingOrderByWithAggregationInput | BillingOrderByWithAggregationInput[]
    by: BillingScalarFieldEnum[] | BillingScalarFieldEnum
    having?: BillingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingCountAggregateInputType | true
    _avg?: BillingAvgAggregateInputType
    _sum?: BillingSumAggregateInputType
    _min?: BillingMinAggregateInputType
    _max?: BillingMaxAggregateInputType
  }

  export type BillingGroupByOutputType = {
    id: string
    account_id: string
    client_id: string
    client_company_id: string | null
    billing_date: Date
    due_date: Date | null
    invoice_number: string
    invoice_prefix: string
    invoice_sequence: number
    billing_address: string
    subtotal_amount: Decimal
    tax_amount: Decimal
    discount_amount: Decimal
    total_amount: Decimal
    notes: string | null
    status: $Enums.BillingStatus
    cancellation_date: Date | null
    cancellation_reason: string | null
    created_at: Date
    updated_at: Date
    created_by: string | null
    updated_by: string | null
    _count: BillingCountAggregateOutputType | null
    _avg: BillingAvgAggregateOutputType | null
    _sum: BillingSumAggregateOutputType | null
    _min: BillingMinAggregateOutputType | null
    _max: BillingMaxAggregateOutputType | null
  }

  type GetBillingGroupByPayload<T extends BillingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingGroupByOutputType[P]>
            : GetScalarType<T[P], BillingGroupByOutputType[P]>
        }
      >
    >


  export type BillingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    client_id?: boolean
    client_company_id?: boolean
    billing_date?: boolean
    due_date?: boolean
    invoice_number?: boolean
    invoice_prefix?: boolean
    invoice_sequence?: boolean
    billing_address?: boolean
    subtotal_amount?: boolean
    tax_amount?: boolean
    discount_amount?: boolean
    total_amount?: boolean
    notes?: boolean
    status?: boolean
    cancellation_date?: boolean
    cancellation_reason?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    clientCompany?: boolean | Billing$clientCompanyArgs<ExtArgs>
    items?: boolean | Billing$itemsArgs<ExtArgs>
    _count?: boolean | BillingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billing"]>



  export type BillingSelectScalar = {
    id?: boolean
    account_id?: boolean
    client_id?: boolean
    client_company_id?: boolean
    billing_date?: boolean
    due_date?: boolean
    invoice_number?: boolean
    invoice_prefix?: boolean
    invoice_sequence?: boolean
    billing_address?: boolean
    subtotal_amount?: boolean
    tax_amount?: boolean
    discount_amount?: boolean
    total_amount?: boolean
    notes?: boolean
    status?: boolean
    cancellation_date?: boolean
    cancellation_reason?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
  }

  export type BillingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "account_id" | "client_id" | "client_company_id" | "billing_date" | "due_date" | "invoice_number" | "invoice_prefix" | "invoice_sequence" | "billing_address" | "subtotal_amount" | "tax_amount" | "discount_amount" | "total_amount" | "notes" | "status" | "cancellation_date" | "cancellation_reason" | "created_at" | "updated_at" | "created_by" | "updated_by", ExtArgs["result"]["billing"]>
  export type BillingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    clientCompany?: boolean | Billing$clientCompanyArgs<ExtArgs>
    items?: boolean | Billing$itemsArgs<ExtArgs>
    _count?: boolean | BillingCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BillingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Billing"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs>
      clientCompany: Prisma.$ClientCompanyPayload<ExtArgs> | null
      items: Prisma.$BillingItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      account_id: string
      client_id: string
      client_company_id: string | null
      billing_date: Date
      due_date: Date | null
      invoice_number: string
      invoice_prefix: string
      invoice_sequence: number
      billing_address: string
      subtotal_amount: Prisma.Decimal
      tax_amount: Prisma.Decimal
      discount_amount: Prisma.Decimal
      total_amount: Prisma.Decimal
      notes: string | null
      status: $Enums.BillingStatus
      cancellation_date: Date | null
      cancellation_reason: string | null
      created_at: Date
      updated_at: Date
      created_by: string | null
      updated_by: string | null
    }, ExtArgs["result"]["billing"]>
    composites: {}
  }

  type BillingGetPayload<S extends boolean | null | undefined | BillingDefaultArgs> = $Result.GetResult<Prisma.$BillingPayload, S>

  type BillingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillingCountAggregateInputType | true
    }

  export interface BillingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Billing'], meta: { name: 'Billing' } }
    /**
     * Find zero or one Billing that matches the filter.
     * @param {BillingFindUniqueArgs} args - Arguments to find a Billing
     * @example
     * // Get one Billing
     * const billing = await prisma.billing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingFindUniqueArgs>(args: SelectSubset<T, BillingFindUniqueArgs<ExtArgs>>): Prisma__BillingClient<$Result.GetResult<Prisma.$BillingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Billing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillingFindUniqueOrThrowArgs} args - Arguments to find a Billing
     * @example
     * // Get one Billing
     * const billing = await prisma.billing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingFindUniqueOrThrowArgs>(args: SelectSubset<T, BillingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillingClient<$Result.GetResult<Prisma.$BillingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Billing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingFindFirstArgs} args - Arguments to find a Billing
     * @example
     * // Get one Billing
     * const billing = await prisma.billing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingFindFirstArgs>(args?: SelectSubset<T, BillingFindFirstArgs<ExtArgs>>): Prisma__BillingClient<$Result.GetResult<Prisma.$BillingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Billing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingFindFirstOrThrowArgs} args - Arguments to find a Billing
     * @example
     * // Get one Billing
     * const billing = await prisma.billing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingFindFirstOrThrowArgs>(args?: SelectSubset<T, BillingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillingClient<$Result.GetResult<Prisma.$BillingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Billings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Billings
     * const billings = await prisma.billing.findMany()
     * 
     * // Get first 10 Billings
     * const billings = await prisma.billing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingWithIdOnly = await prisma.billing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillingFindManyArgs>(args?: SelectSubset<T, BillingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Billing.
     * @param {BillingCreateArgs} args - Arguments to create a Billing.
     * @example
     * // Create one Billing
     * const Billing = await prisma.billing.create({
     *   data: {
     *     // ... data to create a Billing
     *   }
     * })
     * 
     */
    create<T extends BillingCreateArgs>(args: SelectSubset<T, BillingCreateArgs<ExtArgs>>): Prisma__BillingClient<$Result.GetResult<Prisma.$BillingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Billings.
     * @param {BillingCreateManyArgs} args - Arguments to create many Billings.
     * @example
     * // Create many Billings
     * const billing = await prisma.billing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillingCreateManyArgs>(args?: SelectSubset<T, BillingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Billing.
     * @param {BillingDeleteArgs} args - Arguments to delete one Billing.
     * @example
     * // Delete one Billing
     * const Billing = await prisma.billing.delete({
     *   where: {
     *     // ... filter to delete one Billing
     *   }
     * })
     * 
     */
    delete<T extends BillingDeleteArgs>(args: SelectSubset<T, BillingDeleteArgs<ExtArgs>>): Prisma__BillingClient<$Result.GetResult<Prisma.$BillingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Billing.
     * @param {BillingUpdateArgs} args - Arguments to update one Billing.
     * @example
     * // Update one Billing
     * const billing = await prisma.billing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillingUpdateArgs>(args: SelectSubset<T, BillingUpdateArgs<ExtArgs>>): Prisma__BillingClient<$Result.GetResult<Prisma.$BillingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Billings.
     * @param {BillingDeleteManyArgs} args - Arguments to filter Billings to delete.
     * @example
     * // Delete a few Billings
     * const { count } = await prisma.billing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillingDeleteManyArgs>(args?: SelectSubset<T, BillingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Billings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Billings
     * const billing = await prisma.billing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillingUpdateManyArgs>(args: SelectSubset<T, BillingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Billing.
     * @param {BillingUpsertArgs} args - Arguments to update or create a Billing.
     * @example
     * // Update or create a Billing
     * const billing = await prisma.billing.upsert({
     *   create: {
     *     // ... data to create a Billing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Billing we want to update
     *   }
     * })
     */
    upsert<T extends BillingUpsertArgs>(args: SelectSubset<T, BillingUpsertArgs<ExtArgs>>): Prisma__BillingClient<$Result.GetResult<Prisma.$BillingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Billings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingCountArgs} args - Arguments to filter Billings to count.
     * @example
     * // Count the number of Billings
     * const count = await prisma.billing.count({
     *   where: {
     *     // ... the filter for the Billings we want to count
     *   }
     * })
    **/
    count<T extends BillingCountArgs>(
      args?: Subset<T, BillingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Billing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingAggregateArgs>(args: Subset<T, BillingAggregateArgs>): Prisma.PrismaPromise<GetBillingAggregateType<T>>

    /**
     * Group by Billing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingGroupByArgs['orderBy'] }
        : { orderBy?: BillingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Billing model
   */
  readonly fields: BillingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Billing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clientCompany<T extends Billing$clientCompanyArgs<ExtArgs> = {}>(args?: Subset<T, Billing$clientCompanyArgs<ExtArgs>>): Prisma__ClientCompanyClient<$Result.GetResult<Prisma.$ClientCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Billing$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Billing$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Billing model
   */
  interface BillingFieldRefs {
    readonly id: FieldRef<"Billing", 'String'>
    readonly account_id: FieldRef<"Billing", 'String'>
    readonly client_id: FieldRef<"Billing", 'String'>
    readonly client_company_id: FieldRef<"Billing", 'String'>
    readonly billing_date: FieldRef<"Billing", 'DateTime'>
    readonly due_date: FieldRef<"Billing", 'DateTime'>
    readonly invoice_number: FieldRef<"Billing", 'String'>
    readonly invoice_prefix: FieldRef<"Billing", 'String'>
    readonly invoice_sequence: FieldRef<"Billing", 'Int'>
    readonly billing_address: FieldRef<"Billing", 'String'>
    readonly subtotal_amount: FieldRef<"Billing", 'Decimal'>
    readonly tax_amount: FieldRef<"Billing", 'Decimal'>
    readonly discount_amount: FieldRef<"Billing", 'Decimal'>
    readonly total_amount: FieldRef<"Billing", 'Decimal'>
    readonly notes: FieldRef<"Billing", 'String'>
    readonly status: FieldRef<"Billing", 'BillingStatus'>
    readonly cancellation_date: FieldRef<"Billing", 'DateTime'>
    readonly cancellation_reason: FieldRef<"Billing", 'String'>
    readonly created_at: FieldRef<"Billing", 'DateTime'>
    readonly updated_at: FieldRef<"Billing", 'DateTime'>
    readonly created_by: FieldRef<"Billing", 'String'>
    readonly updated_by: FieldRef<"Billing", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Billing findUnique
   */
  export type BillingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing
     */
    select?: BillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing
     */
    omit?: BillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInclude<ExtArgs> | null
    /**
     * Filter, which Billing to fetch.
     */
    where: BillingWhereUniqueInput
  }

  /**
   * Billing findUniqueOrThrow
   */
  export type BillingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing
     */
    select?: BillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing
     */
    omit?: BillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInclude<ExtArgs> | null
    /**
     * Filter, which Billing to fetch.
     */
    where: BillingWhereUniqueInput
  }

  /**
   * Billing findFirst
   */
  export type BillingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing
     */
    select?: BillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing
     */
    omit?: BillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInclude<ExtArgs> | null
    /**
     * Filter, which Billing to fetch.
     */
    where?: BillingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Billings to fetch.
     */
    orderBy?: BillingOrderByWithRelationInput | BillingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Billings.
     */
    cursor?: BillingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Billings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Billings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Billings.
     */
    distinct?: BillingScalarFieldEnum | BillingScalarFieldEnum[]
  }

  /**
   * Billing findFirstOrThrow
   */
  export type BillingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing
     */
    select?: BillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing
     */
    omit?: BillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInclude<ExtArgs> | null
    /**
     * Filter, which Billing to fetch.
     */
    where?: BillingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Billings to fetch.
     */
    orderBy?: BillingOrderByWithRelationInput | BillingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Billings.
     */
    cursor?: BillingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Billings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Billings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Billings.
     */
    distinct?: BillingScalarFieldEnum | BillingScalarFieldEnum[]
  }

  /**
   * Billing findMany
   */
  export type BillingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing
     */
    select?: BillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing
     */
    omit?: BillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInclude<ExtArgs> | null
    /**
     * Filter, which Billings to fetch.
     */
    where?: BillingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Billings to fetch.
     */
    orderBy?: BillingOrderByWithRelationInput | BillingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Billings.
     */
    cursor?: BillingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Billings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Billings.
     */
    skip?: number
    distinct?: BillingScalarFieldEnum | BillingScalarFieldEnum[]
  }

  /**
   * Billing create
   */
  export type BillingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing
     */
    select?: BillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing
     */
    omit?: BillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInclude<ExtArgs> | null
    /**
     * The data needed to create a Billing.
     */
    data: XOR<BillingCreateInput, BillingUncheckedCreateInput>
  }

  /**
   * Billing createMany
   */
  export type BillingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Billings.
     */
    data: BillingCreateManyInput | BillingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Billing update
   */
  export type BillingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing
     */
    select?: BillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing
     */
    omit?: BillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInclude<ExtArgs> | null
    /**
     * The data needed to update a Billing.
     */
    data: XOR<BillingUpdateInput, BillingUncheckedUpdateInput>
    /**
     * Choose, which Billing to update.
     */
    where: BillingWhereUniqueInput
  }

  /**
   * Billing updateMany
   */
  export type BillingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Billings.
     */
    data: XOR<BillingUpdateManyMutationInput, BillingUncheckedUpdateManyInput>
    /**
     * Filter which Billings to update
     */
    where?: BillingWhereInput
    /**
     * Limit how many Billings to update.
     */
    limit?: number
  }

  /**
   * Billing upsert
   */
  export type BillingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing
     */
    select?: BillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing
     */
    omit?: BillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInclude<ExtArgs> | null
    /**
     * The filter to search for the Billing to update in case it exists.
     */
    where: BillingWhereUniqueInput
    /**
     * In case the Billing found by the `where` argument doesn't exist, create a new Billing with this data.
     */
    create: XOR<BillingCreateInput, BillingUncheckedCreateInput>
    /**
     * In case the Billing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingUpdateInput, BillingUncheckedUpdateInput>
  }

  /**
   * Billing delete
   */
  export type BillingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing
     */
    select?: BillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing
     */
    omit?: BillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInclude<ExtArgs> | null
    /**
     * Filter which Billing to delete.
     */
    where: BillingWhereUniqueInput
  }

  /**
   * Billing deleteMany
   */
  export type BillingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Billings to delete
     */
    where?: BillingWhereInput
    /**
     * Limit how many Billings to delete.
     */
    limit?: number
  }

  /**
   * Billing.clientCompany
   */
  export type Billing$clientCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCompany
     */
    select?: ClientCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientCompany
     */
    omit?: ClientCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCompanyInclude<ExtArgs> | null
    where?: ClientCompanyWhereInput
  }

  /**
   * Billing.items
   */
  export type Billing$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingItem
     */
    select?: BillingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingItem
     */
    omit?: BillingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingItemInclude<ExtArgs> | null
    where?: BillingItemWhereInput
    orderBy?: BillingItemOrderByWithRelationInput | BillingItemOrderByWithRelationInput[]
    cursor?: BillingItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillingItemScalarFieldEnum | BillingItemScalarFieldEnum[]
  }

  /**
   * Billing without action
   */
  export type BillingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing
     */
    select?: BillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing
     */
    omit?: BillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInclude<ExtArgs> | null
  }


  /**
   * Model BillingItem
   */

  export type AggregateBillingItem = {
    _count: BillingItemCountAggregateOutputType | null
    _avg: BillingItemAvgAggregateOutputType | null
    _sum: BillingItemSumAggregateOutputType | null
    _min: BillingItemMinAggregateOutputType | null
    _max: BillingItemMaxAggregateOutputType | null
  }

  export type BillingItemAvgAggregateOutputType = {
    quantity: Decimal | null
    unit_price: Decimal | null
    tax_percent: Decimal | null
    discount_percent: Decimal | null
    tax_amount: Decimal | null
    discount_amount: Decimal | null
    line_total: Decimal | null
  }

  export type BillingItemSumAggregateOutputType = {
    quantity: Decimal | null
    unit_price: Decimal | null
    tax_percent: Decimal | null
    discount_percent: Decimal | null
    tax_amount: Decimal | null
    discount_amount: Decimal | null
    line_total: Decimal | null
  }

  export type BillingItemMinAggregateOutputType = {
    id: string | null
    billing_id: string | null
    service_id: string | null
    description: string | null
    quantity: Decimal | null
    unit_price: Decimal | null
    tax_percent: Decimal | null
    discount_percent: Decimal | null
    tax_amount: Decimal | null
    discount_amount: Decimal | null
    line_total: Decimal | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type BillingItemMaxAggregateOutputType = {
    id: string | null
    billing_id: string | null
    service_id: string | null
    description: string | null
    quantity: Decimal | null
    unit_price: Decimal | null
    tax_percent: Decimal | null
    discount_percent: Decimal | null
    tax_amount: Decimal | null
    discount_amount: Decimal | null
    line_total: Decimal | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type BillingItemCountAggregateOutputType = {
    id: number
    billing_id: number
    service_id: number
    description: number
    quantity: number
    unit_price: number
    tax_percent: number
    discount_percent: number
    tax_amount: number
    discount_amount: number
    line_total: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    _all: number
  }


  export type BillingItemAvgAggregateInputType = {
    quantity?: true
    unit_price?: true
    tax_percent?: true
    discount_percent?: true
    tax_amount?: true
    discount_amount?: true
    line_total?: true
  }

  export type BillingItemSumAggregateInputType = {
    quantity?: true
    unit_price?: true
    tax_percent?: true
    discount_percent?: true
    tax_amount?: true
    discount_amount?: true
    line_total?: true
  }

  export type BillingItemMinAggregateInputType = {
    id?: true
    billing_id?: true
    service_id?: true
    description?: true
    quantity?: true
    unit_price?: true
    tax_percent?: true
    discount_percent?: true
    tax_amount?: true
    discount_amount?: true
    line_total?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type BillingItemMaxAggregateInputType = {
    id?: true
    billing_id?: true
    service_id?: true
    description?: true
    quantity?: true
    unit_price?: true
    tax_percent?: true
    discount_percent?: true
    tax_amount?: true
    discount_amount?: true
    line_total?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type BillingItemCountAggregateInputType = {
    id?: true
    billing_id?: true
    service_id?: true
    description?: true
    quantity?: true
    unit_price?: true
    tax_percent?: true
    discount_percent?: true
    tax_amount?: true
    discount_amount?: true
    line_total?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type BillingItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingItem to aggregate.
     */
    where?: BillingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingItems to fetch.
     */
    orderBy?: BillingItemOrderByWithRelationInput | BillingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingItems
    **/
    _count?: true | BillingItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillingItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillingItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingItemMaxAggregateInputType
  }

  export type GetBillingItemAggregateType<T extends BillingItemAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingItem[P]>
      : GetScalarType<T[P], AggregateBillingItem[P]>
  }




  export type BillingItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingItemWhereInput
    orderBy?: BillingItemOrderByWithAggregationInput | BillingItemOrderByWithAggregationInput[]
    by: BillingItemScalarFieldEnum[] | BillingItemScalarFieldEnum
    having?: BillingItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingItemCountAggregateInputType | true
    _avg?: BillingItemAvgAggregateInputType
    _sum?: BillingItemSumAggregateInputType
    _min?: BillingItemMinAggregateInputType
    _max?: BillingItemMaxAggregateInputType
  }

  export type BillingItemGroupByOutputType = {
    id: string
    billing_id: string
    service_id: string
    description: string | null
    quantity: Decimal
    unit_price: Decimal
    tax_percent: Decimal
    discount_percent: Decimal
    tax_amount: Decimal
    discount_amount: Decimal
    line_total: Decimal
    created_at: Date
    updated_at: Date
    created_by: string | null
    updated_by: string | null
    _count: BillingItemCountAggregateOutputType | null
    _avg: BillingItemAvgAggregateOutputType | null
    _sum: BillingItemSumAggregateOutputType | null
    _min: BillingItemMinAggregateOutputType | null
    _max: BillingItemMaxAggregateOutputType | null
  }

  type GetBillingItemGroupByPayload<T extends BillingItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingItemGroupByOutputType[P]>
            : GetScalarType<T[P], BillingItemGroupByOutputType[P]>
        }
      >
    >


  export type BillingItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billing_id?: boolean
    service_id?: boolean
    description?: boolean
    quantity?: boolean
    unit_price?: boolean
    tax_percent?: boolean
    discount_percent?: boolean
    tax_amount?: boolean
    discount_amount?: boolean
    line_total?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    billing?: boolean | BillingDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingItem"]>



  export type BillingItemSelectScalar = {
    id?: boolean
    billing_id?: boolean
    service_id?: boolean
    description?: boolean
    quantity?: boolean
    unit_price?: boolean
    tax_percent?: boolean
    discount_percent?: boolean
    tax_amount?: boolean
    discount_amount?: boolean
    line_total?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
  }

  export type BillingItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "billing_id" | "service_id" | "description" | "quantity" | "unit_price" | "tax_percent" | "discount_percent" | "tax_amount" | "discount_amount" | "line_total" | "created_at" | "updated_at" | "created_by" | "updated_by", ExtArgs["result"]["billingItem"]>
  export type BillingItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billing?: boolean | BillingDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $BillingItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingItem"
    objects: {
      billing: Prisma.$BillingPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      billing_id: string
      service_id: string
      description: string | null
      quantity: Prisma.Decimal
      unit_price: Prisma.Decimal
      tax_percent: Prisma.Decimal
      discount_percent: Prisma.Decimal
      tax_amount: Prisma.Decimal
      discount_amount: Prisma.Decimal
      line_total: Prisma.Decimal
      created_at: Date
      updated_at: Date
      created_by: string | null
      updated_by: string | null
    }, ExtArgs["result"]["billingItem"]>
    composites: {}
  }

  type BillingItemGetPayload<S extends boolean | null | undefined | BillingItemDefaultArgs> = $Result.GetResult<Prisma.$BillingItemPayload, S>

  type BillingItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillingItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillingItemCountAggregateInputType | true
    }

  export interface BillingItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingItem'], meta: { name: 'BillingItem' } }
    /**
     * Find zero or one BillingItem that matches the filter.
     * @param {BillingItemFindUniqueArgs} args - Arguments to find a BillingItem
     * @example
     * // Get one BillingItem
     * const billingItem = await prisma.billingItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingItemFindUniqueArgs>(args: SelectSubset<T, BillingItemFindUniqueArgs<ExtArgs>>): Prisma__BillingItemClient<$Result.GetResult<Prisma.$BillingItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillingItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillingItemFindUniqueOrThrowArgs} args - Arguments to find a BillingItem
     * @example
     * // Get one BillingItem
     * const billingItem = await prisma.billingItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingItemFindUniqueOrThrowArgs>(args: SelectSubset<T, BillingItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillingItemClient<$Result.GetResult<Prisma.$BillingItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingItemFindFirstArgs} args - Arguments to find a BillingItem
     * @example
     * // Get one BillingItem
     * const billingItem = await prisma.billingItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingItemFindFirstArgs>(args?: SelectSubset<T, BillingItemFindFirstArgs<ExtArgs>>): Prisma__BillingItemClient<$Result.GetResult<Prisma.$BillingItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingItemFindFirstOrThrowArgs} args - Arguments to find a BillingItem
     * @example
     * // Get one BillingItem
     * const billingItem = await prisma.billingItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingItemFindFirstOrThrowArgs>(args?: SelectSubset<T, BillingItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillingItemClient<$Result.GetResult<Prisma.$BillingItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillingItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingItems
     * const billingItems = await prisma.billingItem.findMany()
     * 
     * // Get first 10 BillingItems
     * const billingItems = await prisma.billingItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingItemWithIdOnly = await prisma.billingItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillingItemFindManyArgs>(args?: SelectSubset<T, BillingItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillingItem.
     * @param {BillingItemCreateArgs} args - Arguments to create a BillingItem.
     * @example
     * // Create one BillingItem
     * const BillingItem = await prisma.billingItem.create({
     *   data: {
     *     // ... data to create a BillingItem
     *   }
     * })
     * 
     */
    create<T extends BillingItemCreateArgs>(args: SelectSubset<T, BillingItemCreateArgs<ExtArgs>>): Prisma__BillingItemClient<$Result.GetResult<Prisma.$BillingItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillingItems.
     * @param {BillingItemCreateManyArgs} args - Arguments to create many BillingItems.
     * @example
     * // Create many BillingItems
     * const billingItem = await prisma.billingItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillingItemCreateManyArgs>(args?: SelectSubset<T, BillingItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BillingItem.
     * @param {BillingItemDeleteArgs} args - Arguments to delete one BillingItem.
     * @example
     * // Delete one BillingItem
     * const BillingItem = await prisma.billingItem.delete({
     *   where: {
     *     // ... filter to delete one BillingItem
     *   }
     * })
     * 
     */
    delete<T extends BillingItemDeleteArgs>(args: SelectSubset<T, BillingItemDeleteArgs<ExtArgs>>): Prisma__BillingItemClient<$Result.GetResult<Prisma.$BillingItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillingItem.
     * @param {BillingItemUpdateArgs} args - Arguments to update one BillingItem.
     * @example
     * // Update one BillingItem
     * const billingItem = await prisma.billingItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillingItemUpdateArgs>(args: SelectSubset<T, BillingItemUpdateArgs<ExtArgs>>): Prisma__BillingItemClient<$Result.GetResult<Prisma.$BillingItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillingItems.
     * @param {BillingItemDeleteManyArgs} args - Arguments to filter BillingItems to delete.
     * @example
     * // Delete a few BillingItems
     * const { count } = await prisma.billingItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillingItemDeleteManyArgs>(args?: SelectSubset<T, BillingItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingItems
     * const billingItem = await prisma.billingItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillingItemUpdateManyArgs>(args: SelectSubset<T, BillingItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BillingItem.
     * @param {BillingItemUpsertArgs} args - Arguments to update or create a BillingItem.
     * @example
     * // Update or create a BillingItem
     * const billingItem = await prisma.billingItem.upsert({
     *   create: {
     *     // ... data to create a BillingItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingItem we want to update
     *   }
     * })
     */
    upsert<T extends BillingItemUpsertArgs>(args: SelectSubset<T, BillingItemUpsertArgs<ExtArgs>>): Prisma__BillingItemClient<$Result.GetResult<Prisma.$BillingItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingItemCountArgs} args - Arguments to filter BillingItems to count.
     * @example
     * // Count the number of BillingItems
     * const count = await prisma.billingItem.count({
     *   where: {
     *     // ... the filter for the BillingItems we want to count
     *   }
     * })
    **/
    count<T extends BillingItemCountArgs>(
      args?: Subset<T, BillingItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingItemAggregateArgs>(args: Subset<T, BillingItemAggregateArgs>): Prisma.PrismaPromise<GetBillingItemAggregateType<T>>

    /**
     * Group by BillingItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingItemGroupByArgs['orderBy'] }
        : { orderBy?: BillingItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingItem model
   */
  readonly fields: BillingItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    billing<T extends BillingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BillingDefaultArgs<ExtArgs>>): Prisma__BillingClient<$Result.GetResult<Prisma.$BillingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillingItem model
   */
  interface BillingItemFieldRefs {
    readonly id: FieldRef<"BillingItem", 'String'>
    readonly billing_id: FieldRef<"BillingItem", 'String'>
    readonly service_id: FieldRef<"BillingItem", 'String'>
    readonly description: FieldRef<"BillingItem", 'String'>
    readonly quantity: FieldRef<"BillingItem", 'Decimal'>
    readonly unit_price: FieldRef<"BillingItem", 'Decimal'>
    readonly tax_percent: FieldRef<"BillingItem", 'Decimal'>
    readonly discount_percent: FieldRef<"BillingItem", 'Decimal'>
    readonly tax_amount: FieldRef<"BillingItem", 'Decimal'>
    readonly discount_amount: FieldRef<"BillingItem", 'Decimal'>
    readonly line_total: FieldRef<"BillingItem", 'Decimal'>
    readonly created_at: FieldRef<"BillingItem", 'DateTime'>
    readonly updated_at: FieldRef<"BillingItem", 'DateTime'>
    readonly created_by: FieldRef<"BillingItem", 'String'>
    readonly updated_by: FieldRef<"BillingItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BillingItem findUnique
   */
  export type BillingItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingItem
     */
    select?: BillingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingItem
     */
    omit?: BillingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingItemInclude<ExtArgs> | null
    /**
     * Filter, which BillingItem to fetch.
     */
    where: BillingItemWhereUniqueInput
  }

  /**
   * BillingItem findUniqueOrThrow
   */
  export type BillingItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingItem
     */
    select?: BillingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingItem
     */
    omit?: BillingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingItemInclude<ExtArgs> | null
    /**
     * Filter, which BillingItem to fetch.
     */
    where: BillingItemWhereUniqueInput
  }

  /**
   * BillingItem findFirst
   */
  export type BillingItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingItem
     */
    select?: BillingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingItem
     */
    omit?: BillingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingItemInclude<ExtArgs> | null
    /**
     * Filter, which BillingItem to fetch.
     */
    where?: BillingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingItems to fetch.
     */
    orderBy?: BillingItemOrderByWithRelationInput | BillingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingItems.
     */
    cursor?: BillingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingItems.
     */
    distinct?: BillingItemScalarFieldEnum | BillingItemScalarFieldEnum[]
  }

  /**
   * BillingItem findFirstOrThrow
   */
  export type BillingItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingItem
     */
    select?: BillingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingItem
     */
    omit?: BillingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingItemInclude<ExtArgs> | null
    /**
     * Filter, which BillingItem to fetch.
     */
    where?: BillingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingItems to fetch.
     */
    orderBy?: BillingItemOrderByWithRelationInput | BillingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingItems.
     */
    cursor?: BillingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingItems.
     */
    distinct?: BillingItemScalarFieldEnum | BillingItemScalarFieldEnum[]
  }

  /**
   * BillingItem findMany
   */
  export type BillingItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingItem
     */
    select?: BillingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingItem
     */
    omit?: BillingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingItemInclude<ExtArgs> | null
    /**
     * Filter, which BillingItems to fetch.
     */
    where?: BillingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingItems to fetch.
     */
    orderBy?: BillingItemOrderByWithRelationInput | BillingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingItems.
     */
    cursor?: BillingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingItems.
     */
    skip?: number
    distinct?: BillingItemScalarFieldEnum | BillingItemScalarFieldEnum[]
  }

  /**
   * BillingItem create
   */
  export type BillingItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingItem
     */
    select?: BillingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingItem
     */
    omit?: BillingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingItemInclude<ExtArgs> | null
    /**
     * The data needed to create a BillingItem.
     */
    data: XOR<BillingItemCreateInput, BillingItemUncheckedCreateInput>
  }

  /**
   * BillingItem createMany
   */
  export type BillingItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingItems.
     */
    data: BillingItemCreateManyInput | BillingItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingItem update
   */
  export type BillingItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingItem
     */
    select?: BillingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingItem
     */
    omit?: BillingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingItemInclude<ExtArgs> | null
    /**
     * The data needed to update a BillingItem.
     */
    data: XOR<BillingItemUpdateInput, BillingItemUncheckedUpdateInput>
    /**
     * Choose, which BillingItem to update.
     */
    where: BillingItemWhereUniqueInput
  }

  /**
   * BillingItem updateMany
   */
  export type BillingItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingItems.
     */
    data: XOR<BillingItemUpdateManyMutationInput, BillingItemUncheckedUpdateManyInput>
    /**
     * Filter which BillingItems to update
     */
    where?: BillingItemWhereInput
    /**
     * Limit how many BillingItems to update.
     */
    limit?: number
  }

  /**
   * BillingItem upsert
   */
  export type BillingItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingItem
     */
    select?: BillingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingItem
     */
    omit?: BillingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingItemInclude<ExtArgs> | null
    /**
     * The filter to search for the BillingItem to update in case it exists.
     */
    where: BillingItemWhereUniqueInput
    /**
     * In case the BillingItem found by the `where` argument doesn't exist, create a new BillingItem with this data.
     */
    create: XOR<BillingItemCreateInput, BillingItemUncheckedCreateInput>
    /**
     * In case the BillingItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingItemUpdateInput, BillingItemUncheckedUpdateInput>
  }

  /**
   * BillingItem delete
   */
  export type BillingItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingItem
     */
    select?: BillingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingItem
     */
    omit?: BillingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingItemInclude<ExtArgs> | null
    /**
     * Filter which BillingItem to delete.
     */
    where: BillingItemWhereUniqueInput
  }

  /**
   * BillingItem deleteMany
   */
  export type BillingItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingItems to delete
     */
    where?: BillingItemWhereInput
    /**
     * Limit how many BillingItems to delete.
     */
    limit?: number
  }

  /**
   * BillingItem without action
   */
  export type BillingItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingItem
     */
    select?: BillingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingItem
     */
    omit?: BillingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingItemInclude<ExtArgs> | null
  }


  /**
   * Model BankAccount
   */

  export type AggregateBankAccount = {
    _count: BankAccountCountAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  export type BankAccountMinAggregateOutputType = {
    id: string | null
    account_id: string | null
    bank_name: string | null
    account_number: string | null
    routing_number: string | null
    account_type: string | null
    currency: string | null
    is_primary: boolean | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BankAccountMaxAggregateOutputType = {
    id: string | null
    account_id: string | null
    bank_name: string | null
    account_number: string | null
    routing_number: string | null
    account_type: string | null
    currency: string | null
    is_primary: boolean | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BankAccountCountAggregateOutputType = {
    id: number
    account_id: number
    bank_name: number
    account_number: number
    routing_number: number
    account_type: number
    currency: number
    is_primary: number
    description: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type BankAccountMinAggregateInputType = {
    id?: true
    account_id?: true
    bank_name?: true
    account_number?: true
    routing_number?: true
    account_type?: true
    currency?: true
    is_primary?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type BankAccountMaxAggregateInputType = {
    id?: true
    account_id?: true
    bank_name?: true
    account_number?: true
    routing_number?: true
    account_type?: true
    currency?: true
    is_primary?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type BankAccountCountAggregateInputType = {
    id?: true
    account_id?: true
    bank_name?: true
    account_number?: true
    routing_number?: true
    account_type?: true
    currency?: true
    is_primary?: true
    description?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type BankAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccount to aggregate.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankAccounts
    **/
    _count?: true | BankAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankAccountMaxAggregateInputType
  }

  export type GetBankAccountAggregateType<T extends BankAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateBankAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankAccount[P]>
      : GetScalarType<T[P], AggregateBankAccount[P]>
  }




  export type BankAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankAccountWhereInput
    orderBy?: BankAccountOrderByWithAggregationInput | BankAccountOrderByWithAggregationInput[]
    by: BankAccountScalarFieldEnum[] | BankAccountScalarFieldEnum
    having?: BankAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankAccountCountAggregateInputType | true
    _min?: BankAccountMinAggregateInputType
    _max?: BankAccountMaxAggregateInputType
  }

  export type BankAccountGroupByOutputType = {
    id: string
    account_id: string
    bank_name: string
    account_number: string
    routing_number: string | null
    account_type: string | null
    currency: string | null
    is_primary: boolean
    description: string | null
    created_at: Date
    updated_at: Date
    _count: BankAccountCountAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  type GetBankAccountGroupByPayload<T extends BankAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
            : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
        }
      >
    >


  export type BankAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    bank_name?: boolean
    account_number?: boolean
    routing_number?: boolean
    account_type?: boolean
    currency?: boolean
    is_primary?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankAccount"]>



  export type BankAccountSelectScalar = {
    id?: boolean
    account_id?: boolean
    bank_name?: boolean
    account_number?: boolean
    routing_number?: boolean
    account_type?: boolean
    currency?: boolean
    is_primary?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type BankAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "account_id" | "bank_name" | "account_number" | "routing_number" | "account_type" | "currency" | "is_primary" | "description" | "created_at" | "updated_at", ExtArgs["result"]["bankAccount"]>
  export type BankAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $BankAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankAccount"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      account_id: string
      bank_name: string
      account_number: string
      routing_number: string | null
      account_type: string | null
      currency: string | null
      is_primary: boolean
      description: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["bankAccount"]>
    composites: {}
  }

  type BankAccountGetPayload<S extends boolean | null | undefined | BankAccountDefaultArgs> = $Result.GetResult<Prisma.$BankAccountPayload, S>

  type BankAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BankAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BankAccountCountAggregateInputType | true
    }

  export interface BankAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankAccount'], meta: { name: 'BankAccount' } }
    /**
     * Find zero or one BankAccount that matches the filter.
     * @param {BankAccountFindUniqueArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankAccountFindUniqueArgs>(args: SelectSubset<T, BankAccountFindUniqueArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BankAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BankAccountFindUniqueOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, BankAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankAccountFindFirstArgs>(args?: SelectSubset<T, BankAccountFindFirstArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, BankAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BankAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany()
     * 
     * // Get first 10 BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankAccountFindManyArgs>(args?: SelectSubset<T, BankAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BankAccount.
     * @param {BankAccountCreateArgs} args - Arguments to create a BankAccount.
     * @example
     * // Create one BankAccount
     * const BankAccount = await prisma.bankAccount.create({
     *   data: {
     *     // ... data to create a BankAccount
     *   }
     * })
     * 
     */
    create<T extends BankAccountCreateArgs>(args: SelectSubset<T, BankAccountCreateArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BankAccounts.
     * @param {BankAccountCreateManyArgs} args - Arguments to create many BankAccounts.
     * @example
     * // Create many BankAccounts
     * const bankAccount = await prisma.bankAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankAccountCreateManyArgs>(args?: SelectSubset<T, BankAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BankAccount.
     * @param {BankAccountDeleteArgs} args - Arguments to delete one BankAccount.
     * @example
     * // Delete one BankAccount
     * const BankAccount = await prisma.bankAccount.delete({
     *   where: {
     *     // ... filter to delete one BankAccount
     *   }
     * })
     * 
     */
    delete<T extends BankAccountDeleteArgs>(args: SelectSubset<T, BankAccountDeleteArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BankAccount.
     * @param {BankAccountUpdateArgs} args - Arguments to update one BankAccount.
     * @example
     * // Update one BankAccount
     * const bankAccount = await prisma.bankAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankAccountUpdateArgs>(args: SelectSubset<T, BankAccountUpdateArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BankAccounts.
     * @param {BankAccountDeleteManyArgs} args - Arguments to filter BankAccounts to delete.
     * @example
     * // Delete a few BankAccounts
     * const { count } = await prisma.bankAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankAccountDeleteManyArgs>(args?: SelectSubset<T, BankAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankAccounts
     * const bankAccount = await prisma.bankAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankAccountUpdateManyArgs>(args: SelectSubset<T, BankAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BankAccount.
     * @param {BankAccountUpsertArgs} args - Arguments to update or create a BankAccount.
     * @example
     * // Update or create a BankAccount
     * const bankAccount = await prisma.bankAccount.upsert({
     *   create: {
     *     // ... data to create a BankAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankAccount we want to update
     *   }
     * })
     */
    upsert<T extends BankAccountUpsertArgs>(args: SelectSubset<T, BankAccountUpsertArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountCountArgs} args - Arguments to filter BankAccounts to count.
     * @example
     * // Count the number of BankAccounts
     * const count = await prisma.bankAccount.count({
     *   where: {
     *     // ... the filter for the BankAccounts we want to count
     *   }
     * })
    **/
    count<T extends BankAccountCountArgs>(
      args?: Subset<T, BankAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankAccountAggregateArgs>(args: Subset<T, BankAccountAggregateArgs>): Prisma.PrismaPromise<GetBankAccountAggregateType<T>>

    /**
     * Group by BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankAccountGroupByArgs['orderBy'] }
        : { orderBy?: BankAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankAccount model
   */
  readonly fields: BankAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankAccount model
   */
  interface BankAccountFieldRefs {
    readonly id: FieldRef<"BankAccount", 'String'>
    readonly account_id: FieldRef<"BankAccount", 'String'>
    readonly bank_name: FieldRef<"BankAccount", 'String'>
    readonly account_number: FieldRef<"BankAccount", 'String'>
    readonly routing_number: FieldRef<"BankAccount", 'String'>
    readonly account_type: FieldRef<"BankAccount", 'String'>
    readonly currency: FieldRef<"BankAccount", 'String'>
    readonly is_primary: FieldRef<"BankAccount", 'Boolean'>
    readonly description: FieldRef<"BankAccount", 'String'>
    readonly created_at: FieldRef<"BankAccount", 'DateTime'>
    readonly updated_at: FieldRef<"BankAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BankAccount findUnique
   */
  export type BankAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount findUniqueOrThrow
   */
  export type BankAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount findFirst
   */
  export type BankAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount findFirstOrThrow
   */
  export type BankAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount findMany
   */
  export type BankAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccounts to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount create
   */
  export type BankAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a BankAccount.
     */
    data: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
  }

  /**
   * BankAccount createMany
   */
  export type BankAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankAccounts.
     */
    data: BankAccountCreateManyInput | BankAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankAccount update
   */
  export type BankAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a BankAccount.
     */
    data: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
    /**
     * Choose, which BankAccount to update.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount updateMany
   */
  export type BankAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankAccounts.
     */
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyInput>
    /**
     * Filter which BankAccounts to update
     */
    where?: BankAccountWhereInput
    /**
     * Limit how many BankAccounts to update.
     */
    limit?: number
  }

  /**
   * BankAccount upsert
   */
  export type BankAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the BankAccount to update in case it exists.
     */
    where: BankAccountWhereUniqueInput
    /**
     * In case the BankAccount found by the `where` argument doesn't exist, create a new BankAccount with this data.
     */
    create: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
    /**
     * In case the BankAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
  }

  /**
   * BankAccount delete
   */
  export type BankAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter which BankAccount to delete.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount deleteMany
   */
  export type BankAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccounts to delete
     */
    where?: BankAccountWhereInput
    /**
     * Limit how many BankAccounts to delete.
     */
    limit?: number
  }

  /**
   * BankAccount without action
   */
  export type BankAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
  }


  /**
   * Model PDFTemplate
   */

  export type AggregatePDFTemplate = {
    _count: PDFTemplateCountAggregateOutputType | null
    _min: PDFTemplateMinAggregateOutputType | null
    _max: PDFTemplateMaxAggregateOutputType | null
  }

  export type PDFTemplateMinAggregateOutputType = {
    id: string | null
    account_id: string | null
    name: string | null
    description: string | null
    is_default: boolean | null
    primary_color: string | null
    secondary_color: string | null
    font_family: string | null
    show_logo: boolean | null
    show_watermark: boolean | null
    show_qr_code: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type PDFTemplateMaxAggregateOutputType = {
    id: string | null
    account_id: string | null
    name: string | null
    description: string | null
    is_default: boolean | null
    primary_color: string | null
    secondary_color: string | null
    font_family: string | null
    show_logo: boolean | null
    show_watermark: boolean | null
    show_qr_code: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type PDFTemplateCountAggregateOutputType = {
    id: number
    account_id: number
    name: number
    description: number
    is_default: number
    primary_color: number
    secondary_color: number
    font_family: number
    show_logo: number
    show_watermark: number
    show_qr_code: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    _all: number
  }


  export type PDFTemplateMinAggregateInputType = {
    id?: true
    account_id?: true
    name?: true
    description?: true
    is_default?: true
    primary_color?: true
    secondary_color?: true
    font_family?: true
    show_logo?: true
    show_watermark?: true
    show_qr_code?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type PDFTemplateMaxAggregateInputType = {
    id?: true
    account_id?: true
    name?: true
    description?: true
    is_default?: true
    primary_color?: true
    secondary_color?: true
    font_family?: true
    show_logo?: true
    show_watermark?: true
    show_qr_code?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type PDFTemplateCountAggregateInputType = {
    id?: true
    account_id?: true
    name?: true
    description?: true
    is_default?: true
    primary_color?: true
    secondary_color?: true
    font_family?: true
    show_logo?: true
    show_watermark?: true
    show_qr_code?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type PDFTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PDFTemplate to aggregate.
     */
    where?: PDFTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PDFTemplates to fetch.
     */
    orderBy?: PDFTemplateOrderByWithRelationInput | PDFTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PDFTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PDFTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PDFTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PDFTemplates
    **/
    _count?: true | PDFTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PDFTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PDFTemplateMaxAggregateInputType
  }

  export type GetPDFTemplateAggregateType<T extends PDFTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregatePDFTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePDFTemplate[P]>
      : GetScalarType<T[P], AggregatePDFTemplate[P]>
  }




  export type PDFTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PDFTemplateWhereInput
    orderBy?: PDFTemplateOrderByWithAggregationInput | PDFTemplateOrderByWithAggregationInput[]
    by: PDFTemplateScalarFieldEnum[] | PDFTemplateScalarFieldEnum
    having?: PDFTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PDFTemplateCountAggregateInputType | true
    _min?: PDFTemplateMinAggregateInputType
    _max?: PDFTemplateMaxAggregateInputType
  }

  export type PDFTemplateGroupByOutputType = {
    id: string
    account_id: string
    name: string
    description: string | null
    is_default: boolean
    primary_color: string
    secondary_color: string
    font_family: string
    show_logo: boolean
    show_watermark: boolean
    show_qr_code: boolean
    created_at: Date
    updated_at: Date
    created_by: string | null
    updated_by: string | null
    _count: PDFTemplateCountAggregateOutputType | null
    _min: PDFTemplateMinAggregateOutputType | null
    _max: PDFTemplateMaxAggregateOutputType | null
  }

  type GetPDFTemplateGroupByPayload<T extends PDFTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PDFTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PDFTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PDFTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], PDFTemplateGroupByOutputType[P]>
        }
      >
    >


  export type PDFTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    name?: boolean
    description?: boolean
    is_default?: boolean
    primary_color?: boolean
    secondary_color?: boolean
    font_family?: boolean
    show_logo?: boolean
    show_watermark?: boolean
    show_qr_code?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pDFTemplate"]>



  export type PDFTemplateSelectScalar = {
    id?: boolean
    account_id?: boolean
    name?: boolean
    description?: boolean
    is_default?: boolean
    primary_color?: boolean
    secondary_color?: boolean
    font_family?: boolean
    show_logo?: boolean
    show_watermark?: boolean
    show_qr_code?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
  }

  export type PDFTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "account_id" | "name" | "description" | "is_default" | "primary_color" | "secondary_color" | "font_family" | "show_logo" | "show_watermark" | "show_qr_code" | "created_at" | "updated_at" | "created_by" | "updated_by", ExtArgs["result"]["pDFTemplate"]>
  export type PDFTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $PDFTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PDFTemplate"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      account_id: string
      name: string
      description: string | null
      is_default: boolean
      primary_color: string
      secondary_color: string
      font_family: string
      show_logo: boolean
      show_watermark: boolean
      show_qr_code: boolean
      created_at: Date
      updated_at: Date
      created_by: string | null
      updated_by: string | null
    }, ExtArgs["result"]["pDFTemplate"]>
    composites: {}
  }

  type PDFTemplateGetPayload<S extends boolean | null | undefined | PDFTemplateDefaultArgs> = $Result.GetResult<Prisma.$PDFTemplatePayload, S>

  type PDFTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PDFTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PDFTemplateCountAggregateInputType | true
    }

  export interface PDFTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PDFTemplate'], meta: { name: 'PDFTemplate' } }
    /**
     * Find zero or one PDFTemplate that matches the filter.
     * @param {PDFTemplateFindUniqueArgs} args - Arguments to find a PDFTemplate
     * @example
     * // Get one PDFTemplate
     * const pDFTemplate = await prisma.pDFTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PDFTemplateFindUniqueArgs>(args: SelectSubset<T, PDFTemplateFindUniqueArgs<ExtArgs>>): Prisma__PDFTemplateClient<$Result.GetResult<Prisma.$PDFTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PDFTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PDFTemplateFindUniqueOrThrowArgs} args - Arguments to find a PDFTemplate
     * @example
     * // Get one PDFTemplate
     * const pDFTemplate = await prisma.pDFTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PDFTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, PDFTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PDFTemplateClient<$Result.GetResult<Prisma.$PDFTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PDFTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PDFTemplateFindFirstArgs} args - Arguments to find a PDFTemplate
     * @example
     * // Get one PDFTemplate
     * const pDFTemplate = await prisma.pDFTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PDFTemplateFindFirstArgs>(args?: SelectSubset<T, PDFTemplateFindFirstArgs<ExtArgs>>): Prisma__PDFTemplateClient<$Result.GetResult<Prisma.$PDFTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PDFTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PDFTemplateFindFirstOrThrowArgs} args - Arguments to find a PDFTemplate
     * @example
     * // Get one PDFTemplate
     * const pDFTemplate = await prisma.pDFTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PDFTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, PDFTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__PDFTemplateClient<$Result.GetResult<Prisma.$PDFTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PDFTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PDFTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PDFTemplates
     * const pDFTemplates = await prisma.pDFTemplate.findMany()
     * 
     * // Get first 10 PDFTemplates
     * const pDFTemplates = await prisma.pDFTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pDFTemplateWithIdOnly = await prisma.pDFTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PDFTemplateFindManyArgs>(args?: SelectSubset<T, PDFTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PDFTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PDFTemplate.
     * @param {PDFTemplateCreateArgs} args - Arguments to create a PDFTemplate.
     * @example
     * // Create one PDFTemplate
     * const PDFTemplate = await prisma.pDFTemplate.create({
     *   data: {
     *     // ... data to create a PDFTemplate
     *   }
     * })
     * 
     */
    create<T extends PDFTemplateCreateArgs>(args: SelectSubset<T, PDFTemplateCreateArgs<ExtArgs>>): Prisma__PDFTemplateClient<$Result.GetResult<Prisma.$PDFTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PDFTemplates.
     * @param {PDFTemplateCreateManyArgs} args - Arguments to create many PDFTemplates.
     * @example
     * // Create many PDFTemplates
     * const pDFTemplate = await prisma.pDFTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PDFTemplateCreateManyArgs>(args?: SelectSubset<T, PDFTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PDFTemplate.
     * @param {PDFTemplateDeleteArgs} args - Arguments to delete one PDFTemplate.
     * @example
     * // Delete one PDFTemplate
     * const PDFTemplate = await prisma.pDFTemplate.delete({
     *   where: {
     *     // ... filter to delete one PDFTemplate
     *   }
     * })
     * 
     */
    delete<T extends PDFTemplateDeleteArgs>(args: SelectSubset<T, PDFTemplateDeleteArgs<ExtArgs>>): Prisma__PDFTemplateClient<$Result.GetResult<Prisma.$PDFTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PDFTemplate.
     * @param {PDFTemplateUpdateArgs} args - Arguments to update one PDFTemplate.
     * @example
     * // Update one PDFTemplate
     * const pDFTemplate = await prisma.pDFTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PDFTemplateUpdateArgs>(args: SelectSubset<T, PDFTemplateUpdateArgs<ExtArgs>>): Prisma__PDFTemplateClient<$Result.GetResult<Prisma.$PDFTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PDFTemplates.
     * @param {PDFTemplateDeleteManyArgs} args - Arguments to filter PDFTemplates to delete.
     * @example
     * // Delete a few PDFTemplates
     * const { count } = await prisma.pDFTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PDFTemplateDeleteManyArgs>(args?: SelectSubset<T, PDFTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PDFTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PDFTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PDFTemplates
     * const pDFTemplate = await prisma.pDFTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PDFTemplateUpdateManyArgs>(args: SelectSubset<T, PDFTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PDFTemplate.
     * @param {PDFTemplateUpsertArgs} args - Arguments to update or create a PDFTemplate.
     * @example
     * // Update or create a PDFTemplate
     * const pDFTemplate = await prisma.pDFTemplate.upsert({
     *   create: {
     *     // ... data to create a PDFTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PDFTemplate we want to update
     *   }
     * })
     */
    upsert<T extends PDFTemplateUpsertArgs>(args: SelectSubset<T, PDFTemplateUpsertArgs<ExtArgs>>): Prisma__PDFTemplateClient<$Result.GetResult<Prisma.$PDFTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PDFTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PDFTemplateCountArgs} args - Arguments to filter PDFTemplates to count.
     * @example
     * // Count the number of PDFTemplates
     * const count = await prisma.pDFTemplate.count({
     *   where: {
     *     // ... the filter for the PDFTemplates we want to count
     *   }
     * })
    **/
    count<T extends PDFTemplateCountArgs>(
      args?: Subset<T, PDFTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PDFTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PDFTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PDFTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PDFTemplateAggregateArgs>(args: Subset<T, PDFTemplateAggregateArgs>): Prisma.PrismaPromise<GetPDFTemplateAggregateType<T>>

    /**
     * Group by PDFTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PDFTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PDFTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PDFTemplateGroupByArgs['orderBy'] }
        : { orderBy?: PDFTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PDFTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPDFTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PDFTemplate model
   */
  readonly fields: PDFTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PDFTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PDFTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PDFTemplate model
   */
  interface PDFTemplateFieldRefs {
    readonly id: FieldRef<"PDFTemplate", 'String'>
    readonly account_id: FieldRef<"PDFTemplate", 'String'>
    readonly name: FieldRef<"PDFTemplate", 'String'>
    readonly description: FieldRef<"PDFTemplate", 'String'>
    readonly is_default: FieldRef<"PDFTemplate", 'Boolean'>
    readonly primary_color: FieldRef<"PDFTemplate", 'String'>
    readonly secondary_color: FieldRef<"PDFTemplate", 'String'>
    readonly font_family: FieldRef<"PDFTemplate", 'String'>
    readonly show_logo: FieldRef<"PDFTemplate", 'Boolean'>
    readonly show_watermark: FieldRef<"PDFTemplate", 'Boolean'>
    readonly show_qr_code: FieldRef<"PDFTemplate", 'Boolean'>
    readonly created_at: FieldRef<"PDFTemplate", 'DateTime'>
    readonly updated_at: FieldRef<"PDFTemplate", 'DateTime'>
    readonly created_by: FieldRef<"PDFTemplate", 'String'>
    readonly updated_by: FieldRef<"PDFTemplate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PDFTemplate findUnique
   */
  export type PDFTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PDFTemplate
     */
    select?: PDFTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PDFTemplate
     */
    omit?: PDFTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PDFTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PDFTemplate to fetch.
     */
    where: PDFTemplateWhereUniqueInput
  }

  /**
   * PDFTemplate findUniqueOrThrow
   */
  export type PDFTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PDFTemplate
     */
    select?: PDFTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PDFTemplate
     */
    omit?: PDFTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PDFTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PDFTemplate to fetch.
     */
    where: PDFTemplateWhereUniqueInput
  }

  /**
   * PDFTemplate findFirst
   */
  export type PDFTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PDFTemplate
     */
    select?: PDFTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PDFTemplate
     */
    omit?: PDFTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PDFTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PDFTemplate to fetch.
     */
    where?: PDFTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PDFTemplates to fetch.
     */
    orderBy?: PDFTemplateOrderByWithRelationInput | PDFTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PDFTemplates.
     */
    cursor?: PDFTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PDFTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PDFTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PDFTemplates.
     */
    distinct?: PDFTemplateScalarFieldEnum | PDFTemplateScalarFieldEnum[]
  }

  /**
   * PDFTemplate findFirstOrThrow
   */
  export type PDFTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PDFTemplate
     */
    select?: PDFTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PDFTemplate
     */
    omit?: PDFTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PDFTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PDFTemplate to fetch.
     */
    where?: PDFTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PDFTemplates to fetch.
     */
    orderBy?: PDFTemplateOrderByWithRelationInput | PDFTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PDFTemplates.
     */
    cursor?: PDFTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PDFTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PDFTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PDFTemplates.
     */
    distinct?: PDFTemplateScalarFieldEnum | PDFTemplateScalarFieldEnum[]
  }

  /**
   * PDFTemplate findMany
   */
  export type PDFTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PDFTemplate
     */
    select?: PDFTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PDFTemplate
     */
    omit?: PDFTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PDFTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PDFTemplates to fetch.
     */
    where?: PDFTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PDFTemplates to fetch.
     */
    orderBy?: PDFTemplateOrderByWithRelationInput | PDFTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PDFTemplates.
     */
    cursor?: PDFTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PDFTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PDFTemplates.
     */
    skip?: number
    distinct?: PDFTemplateScalarFieldEnum | PDFTemplateScalarFieldEnum[]
  }

  /**
   * PDFTemplate create
   */
  export type PDFTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PDFTemplate
     */
    select?: PDFTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PDFTemplate
     */
    omit?: PDFTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PDFTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a PDFTemplate.
     */
    data: XOR<PDFTemplateCreateInput, PDFTemplateUncheckedCreateInput>
  }

  /**
   * PDFTemplate createMany
   */
  export type PDFTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PDFTemplates.
     */
    data: PDFTemplateCreateManyInput | PDFTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PDFTemplate update
   */
  export type PDFTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PDFTemplate
     */
    select?: PDFTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PDFTemplate
     */
    omit?: PDFTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PDFTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a PDFTemplate.
     */
    data: XOR<PDFTemplateUpdateInput, PDFTemplateUncheckedUpdateInput>
    /**
     * Choose, which PDFTemplate to update.
     */
    where: PDFTemplateWhereUniqueInput
  }

  /**
   * PDFTemplate updateMany
   */
  export type PDFTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PDFTemplates.
     */
    data: XOR<PDFTemplateUpdateManyMutationInput, PDFTemplateUncheckedUpdateManyInput>
    /**
     * Filter which PDFTemplates to update
     */
    where?: PDFTemplateWhereInput
    /**
     * Limit how many PDFTemplates to update.
     */
    limit?: number
  }

  /**
   * PDFTemplate upsert
   */
  export type PDFTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PDFTemplate
     */
    select?: PDFTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PDFTemplate
     */
    omit?: PDFTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PDFTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the PDFTemplate to update in case it exists.
     */
    where: PDFTemplateWhereUniqueInput
    /**
     * In case the PDFTemplate found by the `where` argument doesn't exist, create a new PDFTemplate with this data.
     */
    create: XOR<PDFTemplateCreateInput, PDFTemplateUncheckedCreateInput>
    /**
     * In case the PDFTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PDFTemplateUpdateInput, PDFTemplateUncheckedUpdateInput>
  }

  /**
   * PDFTemplate delete
   */
  export type PDFTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PDFTemplate
     */
    select?: PDFTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PDFTemplate
     */
    omit?: PDFTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PDFTemplateInclude<ExtArgs> | null
    /**
     * Filter which PDFTemplate to delete.
     */
    where: PDFTemplateWhereUniqueInput
  }

  /**
   * PDFTemplate deleteMany
   */
  export type PDFTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PDFTemplates to delete
     */
    where?: PDFTemplateWhereInput
    /**
     * Limit how many PDFTemplates to delete.
     */
    limit?: number
  }

  /**
   * PDFTemplate without action
   */
  export type PDFTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PDFTemplate
     */
    select?: PDFTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PDFTemplate
     */
    omit?: PDFTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PDFTemplateInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password_hash: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    emailVerified: Date | null
    image: string | null
    reset_token: string | null
    reset_token_expires: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password_hash: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    emailVerified: Date | null
    image: string | null
    reset_token: string | null
    reset_token_expires: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password_hash: number
    name: number
    created_at: number
    updated_at: number
    emailVerified: number
    image: number
    reset_token: number
    reset_token_expires: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    name?: true
    created_at?: true
    updated_at?: true
    emailVerified?: true
    image?: true
    reset_token?: true
    reset_token_expires?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    name?: true
    created_at?: true
    updated_at?: true
    emailVerified?: true
    image?: true
    reset_token?: true
    reset_token_expires?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    name?: true
    created_at?: true
    updated_at?: true
    emailVerified?: true
    image?: true
    reset_token?: true
    reset_token_expires?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password_hash: string
    name: string | null
    created_at: Date
    updated_at: Date
    emailVerified: Date | null
    image: string | null
    reset_token: string | null
    reset_token_expires: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    emailVerified?: boolean
    image?: boolean
    reset_token?: boolean
    reset_token_expires?: boolean
    profile?: boolean | User$profileArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    accountsAuth?: boolean | User$accountsAuthArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password_hash?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    emailVerified?: boolean
    image?: boolean
    reset_token?: boolean
    reset_token_expires?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password_hash" | "name" | "created_at" | "updated_at" | "emailVerified" | "image" | "reset_token" | "reset_token_expires", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | User$profileArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    accountsAuth?: boolean | User$accountsAuthArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      accounts: Prisma.$UserAccountPayload<ExtArgs>[]
      accountsAuth: Prisma.$AccountAuthPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password_hash: string
      name: string | null
      created_at: Date
      updated_at: Date
      emailVerified: Date | null
      image: string | null
      reset_token: string | null
      reset_token_expires: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accountsAuth<T extends User$accountsAuthArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsAuthArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountAuthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password_hash: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly reset_token: FieldRef<"User", 'String'>
    readonly reset_token_expires: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    where?: UserAccountWhereInput
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    cursor?: UserAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAccountScalarFieldEnum | UserAccountScalarFieldEnum[]
  }

  /**
   * User.accountsAuth
   */
  export type User$accountsAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountAuth
     */
    select?: AccountAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountAuth
     */
    omit?: AccountAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountAuthInclude<ExtArgs> | null
    where?: AccountAuthWhereInput
    orderBy?: AccountAuthOrderByWithRelationInput | AccountAuthOrderByWithRelationInput[]
    cursor?: AccountAuthWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountAuthScalarFieldEnum | AccountAuthScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    legal_name: 'legal_name',
    created_at: 'created_at',
    created_by: 'created_by',
    updated_at: 'updated_at',
    updated_by: 'updated_by',
    parent_account_id: 'parent_account_id'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const AccountGeneralInfoScalarFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    type: 'type',
    status: 'status',
    dba_name: 'dba_name',
    entity_type: 'entity_type',
    ein: 'ein',
    duns_number: 'duns_number',
    incorporation_date: 'incorporation_date',
    incorporation_state: 'incorporation_state',
    industry: 'industry',
    currency: 'currency',
    payment_terms: 'payment_terms',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AccountGeneralInfoScalarFieldEnum = (typeof AccountGeneralInfoScalarFieldEnum)[keyof typeof AccountGeneralInfoScalarFieldEnum]


  export const AccountContactInfoScalarFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    address_street: 'address_street',
    address_suite: 'address_suite',
    address_city: 'address_city',
    address_state: 'address_state',
    address_zip: 'address_zip',
    address_country: 'address_country',
    phone: 'phone',
    fax: 'fax',
    email: 'email',
    website: 'website',
    mailing_address_street: 'mailing_address_street',
    mailing_address_suite: 'mailing_address_suite',
    mailing_address_city: 'mailing_address_city',
    mailing_address_state: 'mailing_address_state',
    mailing_address_zip: 'mailing_address_zip',
    mailing_address_country: 'mailing_address_country',
    contact_name: 'contact_name',
    contact_title: 'contact_title',
    contact_phone: 'contact_phone',
    contact_email: 'contact_email',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AccountContactInfoScalarFieldEnum = (typeof AccountContactInfoScalarFieldEnum)[keyof typeof AccountContactInfoScalarFieldEnum]


  export const AccountComplianceScalarFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    license_numbers: 'license_numbers',
    insurance_info: 'insurance_info',
    invoice_prefix: 'invoice_prefix',
    logo_url: 'logo_url',
    notes: 'notes',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AccountComplianceScalarFieldEnum = (typeof AccountComplianceScalarFieldEnum)[keyof typeof AccountComplianceScalarFieldEnum]


  export const UserAccountScalarFieldEnum: {
    user_id: 'user_id',
    account_id: 'account_id',
    role: 'role',
    created_at: 'created_at'
  };

  export type UserAccountScalarFieldEnum = (typeof UserAccountScalarFieldEnum)[keyof typeof UserAccountScalarFieldEnum]


  export const AccountAuthScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountAuthScalarFieldEnum = (typeof AccountAuthScalarFieldEnum)[keyof typeof AccountAuthScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    displayName: 'displayName',
    bio: 'bio',
    jobTitle: 'jobTitle',
    company: 'company',
    address1: 'address1',
    address2: 'address2',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    country: 'country',
    language: 'language',
    timezone: 'timezone',
    website: 'website',
    linkedin: 'linkedin',
    twitter: 'twitter',
    facebook: 'facebook',
    instagram: 'instagram',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const ProfileEmailScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    email: 'email',
    type: 'type',
    isPrimary: 'isPrimary',
    isVerified: 'isVerified',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProfileEmailScalarFieldEnum = (typeof ProfileEmailScalarFieldEnum)[keyof typeof ProfileEmailScalarFieldEnum]


  export const ProfilePhoneScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    phoneNumber: 'phoneNumber',
    type: 'type',
    isPrimary: 'isPrimary',
    isVerified: 'isVerified',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProfilePhoneScalarFieldEnum = (typeof ProfilePhoneScalarFieldEnum)[keyof typeof ProfilePhoneScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    client_type: 'client_type',
    name: 'name',
    company_name: 'company_name',
    tax_id: 'tax_id',
    website: 'website',
    notes: 'notes',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const ClientPhoneScalarFieldEnum: {
    id: 'id',
    client_id: 'client_id',
    phone_number: 'phone_number',
    type: 'type',
    is_primary: 'is_primary',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ClientPhoneScalarFieldEnum = (typeof ClientPhoneScalarFieldEnum)[keyof typeof ClientPhoneScalarFieldEnum]


  export const ClientEmailScalarFieldEnum: {
    id: 'id',
    client_id: 'client_id',
    email: 'email',
    type: 'type',
    is_primary: 'is_primary',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ClientEmailScalarFieldEnum = (typeof ClientEmailScalarFieldEnum)[keyof typeof ClientEmailScalarFieldEnum]


  export const ClientAddressScalarFieldEnum: {
    id: 'id',
    client_id: 'client_id',
    type: 'type',
    street: 'street',
    suite: 'suite',
    city: 'city',
    state: 'state',
    zip_code: 'zip_code',
    country: 'country',
    is_primary: 'is_primary',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ClientAddressScalarFieldEnum = (typeof ClientAddressScalarFieldEnum)[keyof typeof ClientAddressScalarFieldEnum]


  export const ClientCompanyScalarFieldEnum: {
    id: 'id',
    client_id: 'client_id',
    name: 'name',
    tax_id: 'tax_id',
    website: 'website',
    notes: 'notes',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ClientCompanyScalarFieldEnum = (typeof ClientCompanyScalarFieldEnum)[keyof typeof ClientCompanyScalarFieldEnum]


  export const ClientCompanyPhoneScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    phone_number: 'phone_number',
    type: 'type',
    is_primary: 'is_primary',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ClientCompanyPhoneScalarFieldEnum = (typeof ClientCompanyPhoneScalarFieldEnum)[keyof typeof ClientCompanyPhoneScalarFieldEnum]


  export const ClientCompanyEmailScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    email: 'email',
    type: 'type',
    is_primary: 'is_primary',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ClientCompanyEmailScalarFieldEnum = (typeof ClientCompanyEmailScalarFieldEnum)[keyof typeof ClientCompanyEmailScalarFieldEnum]


  export const ClientCompanyAddressScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    type: 'type',
    street: 'street',
    suite: 'suite',
    city: 'city',
    state: 'state',
    zip_code: 'zip_code',
    country: 'country',
    is_primary: 'is_primary',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ClientCompanyAddressScalarFieldEnum = (typeof ClientCompanyAddressScalarFieldEnum)[keyof typeof ClientCompanyAddressScalarFieldEnum]


  export const UnitOfMeasureScalarFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    name: 'name',
    symbol: 'symbol',
    description: 'description',
    is_default: 'is_default',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UnitOfMeasureScalarFieldEnum = (typeof UnitOfMeasureScalarFieldEnum)[keyof typeof UnitOfMeasureScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    name: 'name',
    description: 'description',
    price: 'price',
    unit_of_measure_id: 'unit_of_measure_id',
    is_discount: 'is_discount',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const BillingScalarFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    client_id: 'client_id',
    client_company_id: 'client_company_id',
    billing_date: 'billing_date',
    due_date: 'due_date',
    invoice_number: 'invoice_number',
    invoice_prefix: 'invoice_prefix',
    invoice_sequence: 'invoice_sequence',
    billing_address: 'billing_address',
    subtotal_amount: 'subtotal_amount',
    tax_amount: 'tax_amount',
    discount_amount: 'discount_amount',
    total_amount: 'total_amount',
    notes: 'notes',
    status: 'status',
    cancellation_date: 'cancellation_date',
    cancellation_reason: 'cancellation_reason',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type BillingScalarFieldEnum = (typeof BillingScalarFieldEnum)[keyof typeof BillingScalarFieldEnum]


  export const BillingItemScalarFieldEnum: {
    id: 'id',
    billing_id: 'billing_id',
    service_id: 'service_id',
    description: 'description',
    quantity: 'quantity',
    unit_price: 'unit_price',
    tax_percent: 'tax_percent',
    discount_percent: 'discount_percent',
    tax_amount: 'tax_amount',
    discount_amount: 'discount_amount',
    line_total: 'line_total',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type BillingItemScalarFieldEnum = (typeof BillingItemScalarFieldEnum)[keyof typeof BillingItemScalarFieldEnum]


  export const BankAccountScalarFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    bank_name: 'bank_name',
    account_number: 'account_number',
    routing_number: 'routing_number',
    account_type: 'account_type',
    currency: 'currency',
    is_primary: 'is_primary',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type BankAccountScalarFieldEnum = (typeof BankAccountScalarFieldEnum)[keyof typeof BankAccountScalarFieldEnum]


  export const PDFTemplateScalarFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    name: 'name',
    description: 'description',
    is_default: 'is_default',
    primary_color: 'primary_color',
    secondary_color: 'secondary_color',
    font_family: 'font_family',
    show_logo: 'show_logo',
    show_watermark: 'show_watermark',
    show_qr_code: 'show_qr_code',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type PDFTemplateScalarFieldEnum = (typeof PDFTemplateScalarFieldEnum)[keyof typeof PDFTemplateScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password_hash: 'password_hash',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at',
    emailVerified: 'emailVerified',
    image: 'image',
    reset_token: 'reset_token',
    reset_token_expires: 'reset_token_expires'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const AccountOrderByRelevanceFieldEnum: {
    id: 'id',
    legal_name: 'legal_name',
    created_by: 'created_by',
    updated_by: 'updated_by',
    parent_account_id: 'parent_account_id'
  };

  export type AccountOrderByRelevanceFieldEnum = (typeof AccountOrderByRelevanceFieldEnum)[keyof typeof AccountOrderByRelevanceFieldEnum]


  export const AccountGeneralInfoOrderByRelevanceFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    dba_name: 'dba_name',
    ein: 'ein',
    duns_number: 'duns_number',
    incorporation_state: 'incorporation_state',
    industry: 'industry',
    currency: 'currency',
    payment_terms: 'payment_terms'
  };

  export type AccountGeneralInfoOrderByRelevanceFieldEnum = (typeof AccountGeneralInfoOrderByRelevanceFieldEnum)[keyof typeof AccountGeneralInfoOrderByRelevanceFieldEnum]


  export const AccountContactInfoOrderByRelevanceFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    address_street: 'address_street',
    address_suite: 'address_suite',
    address_city: 'address_city',
    address_state: 'address_state',
    address_zip: 'address_zip',
    address_country: 'address_country',
    phone: 'phone',
    fax: 'fax',
    email: 'email',
    website: 'website',
    mailing_address_street: 'mailing_address_street',
    mailing_address_suite: 'mailing_address_suite',
    mailing_address_city: 'mailing_address_city',
    mailing_address_state: 'mailing_address_state',
    mailing_address_zip: 'mailing_address_zip',
    mailing_address_country: 'mailing_address_country',
    contact_name: 'contact_name',
    contact_title: 'contact_title',
    contact_phone: 'contact_phone',
    contact_email: 'contact_email'
  };

  export type AccountContactInfoOrderByRelevanceFieldEnum = (typeof AccountContactInfoOrderByRelevanceFieldEnum)[keyof typeof AccountContactInfoOrderByRelevanceFieldEnum]


  export const AccountComplianceOrderByRelevanceFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    license_numbers: 'license_numbers',
    insurance_info: 'insurance_info',
    invoice_prefix: 'invoice_prefix',
    logo_url: 'logo_url',
    notes: 'notes'
  };

  export type AccountComplianceOrderByRelevanceFieldEnum = (typeof AccountComplianceOrderByRelevanceFieldEnum)[keyof typeof AccountComplianceOrderByRelevanceFieldEnum]


  export const UserAccountOrderByRelevanceFieldEnum: {
    user_id: 'user_id',
    account_id: 'account_id',
    role: 'role'
  };

  export type UserAccountOrderByRelevanceFieldEnum = (typeof UserAccountOrderByRelevanceFieldEnum)[keyof typeof UserAccountOrderByRelevanceFieldEnum]


  export const AccountAuthOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountAuthOrderByRelevanceFieldEnum = (typeof AccountAuthOrderByRelevanceFieldEnum)[keyof typeof AccountAuthOrderByRelevanceFieldEnum]


  export const SessionOrderByRelevanceFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId'
  };

  export type SessionOrderByRelevanceFieldEnum = (typeof SessionOrderByRelevanceFieldEnum)[keyof typeof SessionOrderByRelevanceFieldEnum]


  export const VerificationTokenOrderByRelevanceFieldEnum: {
    identifier: 'identifier',
    token: 'token'
  };

  export type VerificationTokenOrderByRelevanceFieldEnum = (typeof VerificationTokenOrderByRelevanceFieldEnum)[keyof typeof VerificationTokenOrderByRelevanceFieldEnum]


  export const ProfileOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    displayName: 'displayName',
    bio: 'bio',
    jobTitle: 'jobTitle',
    company: 'company',
    address1: 'address1',
    address2: 'address2',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    country: 'country',
    language: 'language',
    timezone: 'timezone',
    website: 'website',
    linkedin: 'linkedin',
    twitter: 'twitter',
    facebook: 'facebook',
    instagram: 'instagram'
  };

  export type ProfileOrderByRelevanceFieldEnum = (typeof ProfileOrderByRelevanceFieldEnum)[keyof typeof ProfileOrderByRelevanceFieldEnum]


  export const ProfileEmailOrderByRelevanceFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    email: 'email',
    type: 'type'
  };

  export type ProfileEmailOrderByRelevanceFieldEnum = (typeof ProfileEmailOrderByRelevanceFieldEnum)[keyof typeof ProfileEmailOrderByRelevanceFieldEnum]


  export const ProfilePhoneOrderByRelevanceFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    phoneNumber: 'phoneNumber',
    type: 'type'
  };

  export type ProfilePhoneOrderByRelevanceFieldEnum = (typeof ProfilePhoneOrderByRelevanceFieldEnum)[keyof typeof ProfilePhoneOrderByRelevanceFieldEnum]


  export const ClientOrderByRelevanceFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    name: 'name',
    company_name: 'company_name',
    tax_id: 'tax_id',
    website: 'website',
    notes: 'notes'
  };

  export type ClientOrderByRelevanceFieldEnum = (typeof ClientOrderByRelevanceFieldEnum)[keyof typeof ClientOrderByRelevanceFieldEnum]


  export const ClientPhoneOrderByRelevanceFieldEnum: {
    id: 'id',
    client_id: 'client_id',
    phone_number: 'phone_number',
    type: 'type'
  };

  export type ClientPhoneOrderByRelevanceFieldEnum = (typeof ClientPhoneOrderByRelevanceFieldEnum)[keyof typeof ClientPhoneOrderByRelevanceFieldEnum]


  export const ClientEmailOrderByRelevanceFieldEnum: {
    id: 'id',
    client_id: 'client_id',
    email: 'email',
    type: 'type'
  };

  export type ClientEmailOrderByRelevanceFieldEnum = (typeof ClientEmailOrderByRelevanceFieldEnum)[keyof typeof ClientEmailOrderByRelevanceFieldEnum]


  export const ClientAddressOrderByRelevanceFieldEnum: {
    id: 'id',
    client_id: 'client_id',
    type: 'type',
    street: 'street',
    suite: 'suite',
    city: 'city',
    state: 'state',
    zip_code: 'zip_code',
    country: 'country'
  };

  export type ClientAddressOrderByRelevanceFieldEnum = (typeof ClientAddressOrderByRelevanceFieldEnum)[keyof typeof ClientAddressOrderByRelevanceFieldEnum]


  export const ClientCompanyOrderByRelevanceFieldEnum: {
    id: 'id',
    client_id: 'client_id',
    name: 'name',
    tax_id: 'tax_id',
    website: 'website',
    notes: 'notes'
  };

  export type ClientCompanyOrderByRelevanceFieldEnum = (typeof ClientCompanyOrderByRelevanceFieldEnum)[keyof typeof ClientCompanyOrderByRelevanceFieldEnum]


  export const ClientCompanyPhoneOrderByRelevanceFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    phone_number: 'phone_number',
    type: 'type'
  };

  export type ClientCompanyPhoneOrderByRelevanceFieldEnum = (typeof ClientCompanyPhoneOrderByRelevanceFieldEnum)[keyof typeof ClientCompanyPhoneOrderByRelevanceFieldEnum]


  export const ClientCompanyEmailOrderByRelevanceFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    email: 'email',
    type: 'type'
  };

  export type ClientCompanyEmailOrderByRelevanceFieldEnum = (typeof ClientCompanyEmailOrderByRelevanceFieldEnum)[keyof typeof ClientCompanyEmailOrderByRelevanceFieldEnum]


  export const ClientCompanyAddressOrderByRelevanceFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    type: 'type',
    street: 'street',
    suite: 'suite',
    city: 'city',
    state: 'state',
    zip_code: 'zip_code',
    country: 'country'
  };

  export type ClientCompanyAddressOrderByRelevanceFieldEnum = (typeof ClientCompanyAddressOrderByRelevanceFieldEnum)[keyof typeof ClientCompanyAddressOrderByRelevanceFieldEnum]


  export const UnitOfMeasureOrderByRelevanceFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    name: 'name',
    symbol: 'symbol',
    description: 'description'
  };

  export type UnitOfMeasureOrderByRelevanceFieldEnum = (typeof UnitOfMeasureOrderByRelevanceFieldEnum)[keyof typeof UnitOfMeasureOrderByRelevanceFieldEnum]


  export const ServiceOrderByRelevanceFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    name: 'name',
    description: 'description',
    unit_of_measure_id: 'unit_of_measure_id'
  };

  export type ServiceOrderByRelevanceFieldEnum = (typeof ServiceOrderByRelevanceFieldEnum)[keyof typeof ServiceOrderByRelevanceFieldEnum]


  export const BillingOrderByRelevanceFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    client_id: 'client_id',
    client_company_id: 'client_company_id',
    invoice_number: 'invoice_number',
    invoice_prefix: 'invoice_prefix',
    billing_address: 'billing_address',
    notes: 'notes',
    cancellation_reason: 'cancellation_reason',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type BillingOrderByRelevanceFieldEnum = (typeof BillingOrderByRelevanceFieldEnum)[keyof typeof BillingOrderByRelevanceFieldEnum]


  export const BillingItemOrderByRelevanceFieldEnum: {
    id: 'id',
    billing_id: 'billing_id',
    service_id: 'service_id',
    description: 'description',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type BillingItemOrderByRelevanceFieldEnum = (typeof BillingItemOrderByRelevanceFieldEnum)[keyof typeof BillingItemOrderByRelevanceFieldEnum]


  export const BankAccountOrderByRelevanceFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    bank_name: 'bank_name',
    account_number: 'account_number',
    routing_number: 'routing_number',
    account_type: 'account_type',
    currency: 'currency',
    description: 'description'
  };

  export type BankAccountOrderByRelevanceFieldEnum = (typeof BankAccountOrderByRelevanceFieldEnum)[keyof typeof BankAccountOrderByRelevanceFieldEnum]


  export const PDFTemplateOrderByRelevanceFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    name: 'name',
    description: 'description',
    primary_color: 'primary_color',
    secondary_color: 'secondary_color',
    font_family: 'font_family',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type PDFTemplateOrderByRelevanceFieldEnum = (typeof PDFTemplateOrderByRelevanceFieldEnum)[keyof typeof PDFTemplateOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    password_hash: 'password_hash',
    name: 'name',
    image: 'image',
    reset_token: 'reset_token'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountStatus'
   */
  export type EnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus'>
    


  /**
   * Reference to a field of type 'EntityType'
   */
  export type EnumEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntityType'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ClientType'
   */
  export type EnumClientTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientType'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'BillingStatus'
   */
  export type EnumBillingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingStatus'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    legal_name?: StringFilter<"Account"> | string
    created_at?: DateTimeFilter<"Account"> | Date | string
    created_by?: StringNullableFilter<"Account"> | string | null
    updated_at?: DateTimeFilter<"Account"> | Date | string
    updated_by?: StringNullableFilter<"Account"> | string | null
    parent_account_id?: StringNullableFilter<"Account"> | string | null
    general_info?: XOR<AccountGeneralInfoNullableScalarRelationFilter, AccountGeneralInfoWhereInput> | null
    contact_info?: XOR<AccountContactInfoNullableScalarRelationFilter, AccountContactInfoWhereInput> | null
    compliance_info?: XOR<AccountComplianceNullableScalarRelationFilter, AccountComplianceWhereInput> | null
    bank_accounts?: BankAccountListRelationFilter
    billings?: BillingListRelationFilter
    clients?: ClientListRelationFilter
    services?: ServiceListRelationFilter
    units_of_measure?: UnitOfMeasureListRelationFilter
    pdf_templates?: PDFTemplateListRelationFilter
    users?: UserAccountListRelationFilter
    parent_account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    child_accounts?: AccountListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    legal_name?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    parent_account_id?: SortOrderInput | SortOrder
    general_info?: AccountGeneralInfoOrderByWithRelationInput
    contact_info?: AccountContactInfoOrderByWithRelationInput
    compliance_info?: AccountComplianceOrderByWithRelationInput
    bank_accounts?: BankAccountOrderByRelationAggregateInput
    billings?: BillingOrderByRelationAggregateInput
    clients?: ClientOrderByRelationAggregateInput
    services?: ServiceOrderByRelationAggregateInput
    units_of_measure?: UnitOfMeasureOrderByRelationAggregateInput
    pdf_templates?: PDFTemplateOrderByRelationAggregateInput
    users?: UserAccountOrderByRelationAggregateInput
    parent_account?: AccountOrderByWithRelationInput
    child_accounts?: AccountOrderByRelationAggregateInput
    _relevance?: AccountOrderByRelevanceInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    legal_name?: StringFilter<"Account"> | string
    created_at?: DateTimeFilter<"Account"> | Date | string
    created_by?: StringNullableFilter<"Account"> | string | null
    updated_at?: DateTimeFilter<"Account"> | Date | string
    updated_by?: StringNullableFilter<"Account"> | string | null
    parent_account_id?: StringNullableFilter<"Account"> | string | null
    general_info?: XOR<AccountGeneralInfoNullableScalarRelationFilter, AccountGeneralInfoWhereInput> | null
    contact_info?: XOR<AccountContactInfoNullableScalarRelationFilter, AccountContactInfoWhereInput> | null
    compliance_info?: XOR<AccountComplianceNullableScalarRelationFilter, AccountComplianceWhereInput> | null
    bank_accounts?: BankAccountListRelationFilter
    billings?: BillingListRelationFilter
    clients?: ClientListRelationFilter
    services?: ServiceListRelationFilter
    units_of_measure?: UnitOfMeasureListRelationFilter
    pdf_templates?: PDFTemplateListRelationFilter
    users?: UserAccountListRelationFilter
    parent_account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    child_accounts?: AccountListRelationFilter
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    legal_name?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    parent_account_id?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    legal_name?: StringWithAggregatesFilter<"Account"> | string
    created_at?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    created_by?: StringNullableWithAggregatesFilter<"Account"> | string | null
    updated_at?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updated_by?: StringNullableWithAggregatesFilter<"Account"> | string | null
    parent_account_id?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type AccountGeneralInfoWhereInput = {
    AND?: AccountGeneralInfoWhereInput | AccountGeneralInfoWhereInput[]
    OR?: AccountGeneralInfoWhereInput[]
    NOT?: AccountGeneralInfoWhereInput | AccountGeneralInfoWhereInput[]
    id?: StringFilter<"AccountGeneralInfo"> | string
    account_id?: StringFilter<"AccountGeneralInfo"> | string
    type?: EnumAccountTypeFilter<"AccountGeneralInfo"> | $Enums.AccountType
    status?: EnumAccountStatusFilter<"AccountGeneralInfo"> | $Enums.AccountStatus
    dba_name?: StringNullableFilter<"AccountGeneralInfo"> | string | null
    entity_type?: EnumEntityTypeNullableFilter<"AccountGeneralInfo"> | $Enums.EntityType | null
    ein?: StringNullableFilter<"AccountGeneralInfo"> | string | null
    duns_number?: StringNullableFilter<"AccountGeneralInfo"> | string | null
    incorporation_date?: DateTimeNullableFilter<"AccountGeneralInfo"> | Date | string | null
    incorporation_state?: StringNullableFilter<"AccountGeneralInfo"> | string | null
    industry?: StringNullableFilter<"AccountGeneralInfo"> | string | null
    currency?: StringNullableFilter<"AccountGeneralInfo"> | string | null
    payment_terms?: StringNullableFilter<"AccountGeneralInfo"> | string | null
    created_at?: DateTimeFilter<"AccountGeneralInfo"> | Date | string
    updated_at?: DateTimeFilter<"AccountGeneralInfo"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type AccountGeneralInfoOrderByWithRelationInput = {
    id?: SortOrder
    account_id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    dba_name?: SortOrderInput | SortOrder
    entity_type?: SortOrderInput | SortOrder
    ein?: SortOrderInput | SortOrder
    duns_number?: SortOrderInput | SortOrder
    incorporation_date?: SortOrderInput | SortOrder
    incorporation_state?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    payment_terms?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    account?: AccountOrderByWithRelationInput
    _relevance?: AccountGeneralInfoOrderByRelevanceInput
  }

  export type AccountGeneralInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    account_id?: string
    AND?: AccountGeneralInfoWhereInput | AccountGeneralInfoWhereInput[]
    OR?: AccountGeneralInfoWhereInput[]
    NOT?: AccountGeneralInfoWhereInput | AccountGeneralInfoWhereInput[]
    type?: EnumAccountTypeFilter<"AccountGeneralInfo"> | $Enums.AccountType
    status?: EnumAccountStatusFilter<"AccountGeneralInfo"> | $Enums.AccountStatus
    dba_name?: StringNullableFilter<"AccountGeneralInfo"> | string | null
    entity_type?: EnumEntityTypeNullableFilter<"AccountGeneralInfo"> | $Enums.EntityType | null
    ein?: StringNullableFilter<"AccountGeneralInfo"> | string | null
    duns_number?: StringNullableFilter<"AccountGeneralInfo"> | string | null
    incorporation_date?: DateTimeNullableFilter<"AccountGeneralInfo"> | Date | string | null
    incorporation_state?: StringNullableFilter<"AccountGeneralInfo"> | string | null
    industry?: StringNullableFilter<"AccountGeneralInfo"> | string | null
    currency?: StringNullableFilter<"AccountGeneralInfo"> | string | null
    payment_terms?: StringNullableFilter<"AccountGeneralInfo"> | string | null
    created_at?: DateTimeFilter<"AccountGeneralInfo"> | Date | string
    updated_at?: DateTimeFilter<"AccountGeneralInfo"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "id" | "account_id">

  export type AccountGeneralInfoOrderByWithAggregationInput = {
    id?: SortOrder
    account_id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    dba_name?: SortOrderInput | SortOrder
    entity_type?: SortOrderInput | SortOrder
    ein?: SortOrderInput | SortOrder
    duns_number?: SortOrderInput | SortOrder
    incorporation_date?: SortOrderInput | SortOrder
    incorporation_state?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    payment_terms?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AccountGeneralInfoCountOrderByAggregateInput
    _max?: AccountGeneralInfoMaxOrderByAggregateInput
    _min?: AccountGeneralInfoMinOrderByAggregateInput
  }

  export type AccountGeneralInfoScalarWhereWithAggregatesInput = {
    AND?: AccountGeneralInfoScalarWhereWithAggregatesInput | AccountGeneralInfoScalarWhereWithAggregatesInput[]
    OR?: AccountGeneralInfoScalarWhereWithAggregatesInput[]
    NOT?: AccountGeneralInfoScalarWhereWithAggregatesInput | AccountGeneralInfoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccountGeneralInfo"> | string
    account_id?: StringWithAggregatesFilter<"AccountGeneralInfo"> | string
    type?: EnumAccountTypeWithAggregatesFilter<"AccountGeneralInfo"> | $Enums.AccountType
    status?: EnumAccountStatusWithAggregatesFilter<"AccountGeneralInfo"> | $Enums.AccountStatus
    dba_name?: StringNullableWithAggregatesFilter<"AccountGeneralInfo"> | string | null
    entity_type?: EnumEntityTypeNullableWithAggregatesFilter<"AccountGeneralInfo"> | $Enums.EntityType | null
    ein?: StringNullableWithAggregatesFilter<"AccountGeneralInfo"> | string | null
    duns_number?: StringNullableWithAggregatesFilter<"AccountGeneralInfo"> | string | null
    incorporation_date?: DateTimeNullableWithAggregatesFilter<"AccountGeneralInfo"> | Date | string | null
    incorporation_state?: StringNullableWithAggregatesFilter<"AccountGeneralInfo"> | string | null
    industry?: StringNullableWithAggregatesFilter<"AccountGeneralInfo"> | string | null
    currency?: StringNullableWithAggregatesFilter<"AccountGeneralInfo"> | string | null
    payment_terms?: StringNullableWithAggregatesFilter<"AccountGeneralInfo"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"AccountGeneralInfo"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"AccountGeneralInfo"> | Date | string
  }

  export type AccountContactInfoWhereInput = {
    AND?: AccountContactInfoWhereInput | AccountContactInfoWhereInput[]
    OR?: AccountContactInfoWhereInput[]
    NOT?: AccountContactInfoWhereInput | AccountContactInfoWhereInput[]
    id?: StringFilter<"AccountContactInfo"> | string
    account_id?: StringFilter<"AccountContactInfo"> | string
    address_street?: StringNullableFilter<"AccountContactInfo"> | string | null
    address_suite?: StringNullableFilter<"AccountContactInfo"> | string | null
    address_city?: StringNullableFilter<"AccountContactInfo"> | string | null
    address_state?: StringNullableFilter<"AccountContactInfo"> | string | null
    address_zip?: StringNullableFilter<"AccountContactInfo"> | string | null
    address_country?: StringNullableFilter<"AccountContactInfo"> | string | null
    phone?: StringNullableFilter<"AccountContactInfo"> | string | null
    fax?: StringNullableFilter<"AccountContactInfo"> | string | null
    email?: StringNullableFilter<"AccountContactInfo"> | string | null
    website?: StringNullableFilter<"AccountContactInfo"> | string | null
    mailing_address_street?: StringNullableFilter<"AccountContactInfo"> | string | null
    mailing_address_suite?: StringNullableFilter<"AccountContactInfo"> | string | null
    mailing_address_city?: StringNullableFilter<"AccountContactInfo"> | string | null
    mailing_address_state?: StringNullableFilter<"AccountContactInfo"> | string | null
    mailing_address_zip?: StringNullableFilter<"AccountContactInfo"> | string | null
    mailing_address_country?: StringNullableFilter<"AccountContactInfo"> | string | null
    contact_name?: StringNullableFilter<"AccountContactInfo"> | string | null
    contact_title?: StringNullableFilter<"AccountContactInfo"> | string | null
    contact_phone?: StringNullableFilter<"AccountContactInfo"> | string | null
    contact_email?: StringNullableFilter<"AccountContactInfo"> | string | null
    created_at?: DateTimeFilter<"AccountContactInfo"> | Date | string
    updated_at?: DateTimeFilter<"AccountContactInfo"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type AccountContactInfoOrderByWithRelationInput = {
    id?: SortOrder
    account_id?: SortOrder
    address_street?: SortOrderInput | SortOrder
    address_suite?: SortOrderInput | SortOrder
    address_city?: SortOrderInput | SortOrder
    address_state?: SortOrderInput | SortOrder
    address_zip?: SortOrderInput | SortOrder
    address_country?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    fax?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    mailing_address_street?: SortOrderInput | SortOrder
    mailing_address_suite?: SortOrderInput | SortOrder
    mailing_address_city?: SortOrderInput | SortOrder
    mailing_address_state?: SortOrderInput | SortOrder
    mailing_address_zip?: SortOrderInput | SortOrder
    mailing_address_country?: SortOrderInput | SortOrder
    contact_name?: SortOrderInput | SortOrder
    contact_title?: SortOrderInput | SortOrder
    contact_phone?: SortOrderInput | SortOrder
    contact_email?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    account?: AccountOrderByWithRelationInput
    _relevance?: AccountContactInfoOrderByRelevanceInput
  }

  export type AccountContactInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    account_id?: string
    AND?: AccountContactInfoWhereInput | AccountContactInfoWhereInput[]
    OR?: AccountContactInfoWhereInput[]
    NOT?: AccountContactInfoWhereInput | AccountContactInfoWhereInput[]
    address_street?: StringNullableFilter<"AccountContactInfo"> | string | null
    address_suite?: StringNullableFilter<"AccountContactInfo"> | string | null
    address_city?: StringNullableFilter<"AccountContactInfo"> | string | null
    address_state?: StringNullableFilter<"AccountContactInfo"> | string | null
    address_zip?: StringNullableFilter<"AccountContactInfo"> | string | null
    address_country?: StringNullableFilter<"AccountContactInfo"> | string | null
    phone?: StringNullableFilter<"AccountContactInfo"> | string | null
    fax?: StringNullableFilter<"AccountContactInfo"> | string | null
    email?: StringNullableFilter<"AccountContactInfo"> | string | null
    website?: StringNullableFilter<"AccountContactInfo"> | string | null
    mailing_address_street?: StringNullableFilter<"AccountContactInfo"> | string | null
    mailing_address_suite?: StringNullableFilter<"AccountContactInfo"> | string | null
    mailing_address_city?: StringNullableFilter<"AccountContactInfo"> | string | null
    mailing_address_state?: StringNullableFilter<"AccountContactInfo"> | string | null
    mailing_address_zip?: StringNullableFilter<"AccountContactInfo"> | string | null
    mailing_address_country?: StringNullableFilter<"AccountContactInfo"> | string | null
    contact_name?: StringNullableFilter<"AccountContactInfo"> | string | null
    contact_title?: StringNullableFilter<"AccountContactInfo"> | string | null
    contact_phone?: StringNullableFilter<"AccountContactInfo"> | string | null
    contact_email?: StringNullableFilter<"AccountContactInfo"> | string | null
    created_at?: DateTimeFilter<"AccountContactInfo"> | Date | string
    updated_at?: DateTimeFilter<"AccountContactInfo"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "id" | "account_id">

  export type AccountContactInfoOrderByWithAggregationInput = {
    id?: SortOrder
    account_id?: SortOrder
    address_street?: SortOrderInput | SortOrder
    address_suite?: SortOrderInput | SortOrder
    address_city?: SortOrderInput | SortOrder
    address_state?: SortOrderInput | SortOrder
    address_zip?: SortOrderInput | SortOrder
    address_country?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    fax?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    mailing_address_street?: SortOrderInput | SortOrder
    mailing_address_suite?: SortOrderInput | SortOrder
    mailing_address_city?: SortOrderInput | SortOrder
    mailing_address_state?: SortOrderInput | SortOrder
    mailing_address_zip?: SortOrderInput | SortOrder
    mailing_address_country?: SortOrderInput | SortOrder
    contact_name?: SortOrderInput | SortOrder
    contact_title?: SortOrderInput | SortOrder
    contact_phone?: SortOrderInput | SortOrder
    contact_email?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AccountContactInfoCountOrderByAggregateInput
    _max?: AccountContactInfoMaxOrderByAggregateInput
    _min?: AccountContactInfoMinOrderByAggregateInput
  }

  export type AccountContactInfoScalarWhereWithAggregatesInput = {
    AND?: AccountContactInfoScalarWhereWithAggregatesInput | AccountContactInfoScalarWhereWithAggregatesInput[]
    OR?: AccountContactInfoScalarWhereWithAggregatesInput[]
    NOT?: AccountContactInfoScalarWhereWithAggregatesInput | AccountContactInfoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccountContactInfo"> | string
    account_id?: StringWithAggregatesFilter<"AccountContactInfo"> | string
    address_street?: StringNullableWithAggregatesFilter<"AccountContactInfo"> | string | null
    address_suite?: StringNullableWithAggregatesFilter<"AccountContactInfo"> | string | null
    address_city?: StringNullableWithAggregatesFilter<"AccountContactInfo"> | string | null
    address_state?: StringNullableWithAggregatesFilter<"AccountContactInfo"> | string | null
    address_zip?: StringNullableWithAggregatesFilter<"AccountContactInfo"> | string | null
    address_country?: StringNullableWithAggregatesFilter<"AccountContactInfo"> | string | null
    phone?: StringNullableWithAggregatesFilter<"AccountContactInfo"> | string | null
    fax?: StringNullableWithAggregatesFilter<"AccountContactInfo"> | string | null
    email?: StringNullableWithAggregatesFilter<"AccountContactInfo"> | string | null
    website?: StringNullableWithAggregatesFilter<"AccountContactInfo"> | string | null
    mailing_address_street?: StringNullableWithAggregatesFilter<"AccountContactInfo"> | string | null
    mailing_address_suite?: StringNullableWithAggregatesFilter<"AccountContactInfo"> | string | null
    mailing_address_city?: StringNullableWithAggregatesFilter<"AccountContactInfo"> | string | null
    mailing_address_state?: StringNullableWithAggregatesFilter<"AccountContactInfo"> | string | null
    mailing_address_zip?: StringNullableWithAggregatesFilter<"AccountContactInfo"> | string | null
    mailing_address_country?: StringNullableWithAggregatesFilter<"AccountContactInfo"> | string | null
    contact_name?: StringNullableWithAggregatesFilter<"AccountContactInfo"> | string | null
    contact_title?: StringNullableWithAggregatesFilter<"AccountContactInfo"> | string | null
    contact_phone?: StringNullableWithAggregatesFilter<"AccountContactInfo"> | string | null
    contact_email?: StringNullableWithAggregatesFilter<"AccountContactInfo"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"AccountContactInfo"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"AccountContactInfo"> | Date | string
  }

  export type AccountComplianceWhereInput = {
    AND?: AccountComplianceWhereInput | AccountComplianceWhereInput[]
    OR?: AccountComplianceWhereInput[]
    NOT?: AccountComplianceWhereInput | AccountComplianceWhereInput[]
    id?: StringFilter<"AccountCompliance"> | string
    account_id?: StringFilter<"AccountCompliance"> | string
    license_numbers?: StringNullableFilter<"AccountCompliance"> | string | null
    insurance_info?: StringNullableFilter<"AccountCompliance"> | string | null
    invoice_prefix?: StringNullableFilter<"AccountCompliance"> | string | null
    logo_url?: StringNullableFilter<"AccountCompliance"> | string | null
    notes?: StringNullableFilter<"AccountCompliance"> | string | null
    created_at?: DateTimeFilter<"AccountCompliance"> | Date | string
    updated_at?: DateTimeFilter<"AccountCompliance"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type AccountComplianceOrderByWithRelationInput = {
    id?: SortOrder
    account_id?: SortOrder
    license_numbers?: SortOrderInput | SortOrder
    insurance_info?: SortOrderInput | SortOrder
    invoice_prefix?: SortOrderInput | SortOrder
    logo_url?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    account?: AccountOrderByWithRelationInput
    _relevance?: AccountComplianceOrderByRelevanceInput
  }

  export type AccountComplianceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    account_id?: string
    AND?: AccountComplianceWhereInput | AccountComplianceWhereInput[]
    OR?: AccountComplianceWhereInput[]
    NOT?: AccountComplianceWhereInput | AccountComplianceWhereInput[]
    license_numbers?: StringNullableFilter<"AccountCompliance"> | string | null
    insurance_info?: StringNullableFilter<"AccountCompliance"> | string | null
    invoice_prefix?: StringNullableFilter<"AccountCompliance"> | string | null
    logo_url?: StringNullableFilter<"AccountCompliance"> | string | null
    notes?: StringNullableFilter<"AccountCompliance"> | string | null
    created_at?: DateTimeFilter<"AccountCompliance"> | Date | string
    updated_at?: DateTimeFilter<"AccountCompliance"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "id" | "account_id">

  export type AccountComplianceOrderByWithAggregationInput = {
    id?: SortOrder
    account_id?: SortOrder
    license_numbers?: SortOrderInput | SortOrder
    insurance_info?: SortOrderInput | SortOrder
    invoice_prefix?: SortOrderInput | SortOrder
    logo_url?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AccountComplianceCountOrderByAggregateInput
    _max?: AccountComplianceMaxOrderByAggregateInput
    _min?: AccountComplianceMinOrderByAggregateInput
  }

  export type AccountComplianceScalarWhereWithAggregatesInput = {
    AND?: AccountComplianceScalarWhereWithAggregatesInput | AccountComplianceScalarWhereWithAggregatesInput[]
    OR?: AccountComplianceScalarWhereWithAggregatesInput[]
    NOT?: AccountComplianceScalarWhereWithAggregatesInput | AccountComplianceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccountCompliance"> | string
    account_id?: StringWithAggregatesFilter<"AccountCompliance"> | string
    license_numbers?: StringNullableWithAggregatesFilter<"AccountCompliance"> | string | null
    insurance_info?: StringNullableWithAggregatesFilter<"AccountCompliance"> | string | null
    invoice_prefix?: StringNullableWithAggregatesFilter<"AccountCompliance"> | string | null
    logo_url?: StringNullableWithAggregatesFilter<"AccountCompliance"> | string | null
    notes?: StringNullableWithAggregatesFilter<"AccountCompliance"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"AccountCompliance"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"AccountCompliance"> | Date | string
  }

  export type UserAccountWhereInput = {
    AND?: UserAccountWhereInput | UserAccountWhereInput[]
    OR?: UserAccountWhereInput[]
    NOT?: UserAccountWhereInput | UserAccountWhereInput[]
    user_id?: StringFilter<"UserAccount"> | string
    account_id?: StringFilter<"UserAccount"> | string
    role?: StringFilter<"UserAccount"> | string
    created_at?: DateTimeFilter<"UserAccount"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserAccountOrderByWithRelationInput = {
    user_id?: SortOrder
    account_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    account?: AccountOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: UserAccountOrderByRelevanceInput
  }

  export type UserAccountWhereUniqueInput = Prisma.AtLeast<{
    user_id_account_id?: UserAccountUser_idAccount_idCompoundUniqueInput
    AND?: UserAccountWhereInput | UserAccountWhereInput[]
    OR?: UserAccountWhereInput[]
    NOT?: UserAccountWhereInput | UserAccountWhereInput[]
    user_id?: StringFilter<"UserAccount"> | string
    account_id?: StringFilter<"UserAccount"> | string
    role?: StringFilter<"UserAccount"> | string
    created_at?: DateTimeFilter<"UserAccount"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "user_id_account_id">

  export type UserAccountOrderByWithAggregationInput = {
    user_id?: SortOrder
    account_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    _count?: UserAccountCountOrderByAggregateInput
    _max?: UserAccountMaxOrderByAggregateInput
    _min?: UserAccountMinOrderByAggregateInput
  }

  export type UserAccountScalarWhereWithAggregatesInput = {
    AND?: UserAccountScalarWhereWithAggregatesInput | UserAccountScalarWhereWithAggregatesInput[]
    OR?: UserAccountScalarWhereWithAggregatesInput[]
    NOT?: UserAccountScalarWhereWithAggregatesInput | UserAccountScalarWhereWithAggregatesInput[]
    user_id?: StringWithAggregatesFilter<"UserAccount"> | string
    account_id?: StringWithAggregatesFilter<"UserAccount"> | string
    role?: StringWithAggregatesFilter<"UserAccount"> | string
    created_at?: DateTimeWithAggregatesFilter<"UserAccount"> | Date | string
  }

  export type AccountAuthWhereInput = {
    AND?: AccountAuthWhereInput | AccountAuthWhereInput[]
    OR?: AccountAuthWhereInput[]
    NOT?: AccountAuthWhereInput | AccountAuthWhereInput[]
    id?: StringFilter<"AccountAuth"> | string
    userId?: StringFilter<"AccountAuth"> | string
    type?: StringFilter<"AccountAuth"> | string
    provider?: StringFilter<"AccountAuth"> | string
    providerAccountId?: StringFilter<"AccountAuth"> | string
    refresh_token?: StringNullableFilter<"AccountAuth"> | string | null
    access_token?: StringNullableFilter<"AccountAuth"> | string | null
    expires_at?: IntNullableFilter<"AccountAuth"> | number | null
    token_type?: StringNullableFilter<"AccountAuth"> | string | null
    scope?: StringNullableFilter<"AccountAuth"> | string | null
    id_token?: StringNullableFilter<"AccountAuth"> | string | null
    session_state?: StringNullableFilter<"AccountAuth"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountAuthOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: AccountAuthOrderByRelevanceInput
  }

  export type AccountAuthWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountAuthProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountAuthWhereInput | AccountAuthWhereInput[]
    OR?: AccountAuthWhereInput[]
    NOT?: AccountAuthWhereInput | AccountAuthWhereInput[]
    userId?: StringFilter<"AccountAuth"> | string
    type?: StringFilter<"AccountAuth"> | string
    provider?: StringFilter<"AccountAuth"> | string
    providerAccountId?: StringFilter<"AccountAuth"> | string
    refresh_token?: StringNullableFilter<"AccountAuth"> | string | null
    access_token?: StringNullableFilter<"AccountAuth"> | string | null
    expires_at?: IntNullableFilter<"AccountAuth"> | number | null
    token_type?: StringNullableFilter<"AccountAuth"> | string | null
    scope?: StringNullableFilter<"AccountAuth"> | string | null
    id_token?: StringNullableFilter<"AccountAuth"> | string | null
    session_state?: StringNullableFilter<"AccountAuth"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountAuthOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountAuthCountOrderByAggregateInput
    _avg?: AccountAuthAvgOrderByAggregateInput
    _max?: AccountAuthMaxOrderByAggregateInput
    _min?: AccountAuthMinOrderByAggregateInput
    _sum?: AccountAuthSumOrderByAggregateInput
  }

  export type AccountAuthScalarWhereWithAggregatesInput = {
    AND?: AccountAuthScalarWhereWithAggregatesInput | AccountAuthScalarWhereWithAggregatesInput[]
    OR?: AccountAuthScalarWhereWithAggregatesInput[]
    NOT?: AccountAuthScalarWhereWithAggregatesInput | AccountAuthScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccountAuth"> | string
    userId?: StringWithAggregatesFilter<"AccountAuth"> | string
    type?: StringWithAggregatesFilter<"AccountAuth"> | string
    provider?: StringWithAggregatesFilter<"AccountAuth"> | string
    providerAccountId?: StringWithAggregatesFilter<"AccountAuth"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"AccountAuth"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"AccountAuth"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"AccountAuth"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"AccountAuth"> | string | null
    scope?: StringNullableWithAggregatesFilter<"AccountAuth"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"AccountAuth"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"AccountAuth"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: SessionOrderByRelevanceInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _relevance?: VerificationTokenOrderByRelevanceInput
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    userId?: StringFilter<"Profile"> | string
    firstName?: StringNullableFilter<"Profile"> | string | null
    lastName?: StringNullableFilter<"Profile"> | string | null
    displayName?: StringNullableFilter<"Profile"> | string | null
    bio?: StringNullableFilter<"Profile"> | string | null
    jobTitle?: StringNullableFilter<"Profile"> | string | null
    company?: StringNullableFilter<"Profile"> | string | null
    address1?: StringNullableFilter<"Profile"> | string | null
    address2?: StringNullableFilter<"Profile"> | string | null
    city?: StringNullableFilter<"Profile"> | string | null
    state?: StringNullableFilter<"Profile"> | string | null
    zipCode?: StringNullableFilter<"Profile"> | string | null
    country?: StringNullableFilter<"Profile"> | string | null
    language?: StringNullableFilter<"Profile"> | string | null
    timezone?: StringNullableFilter<"Profile"> | string | null
    website?: StringNullableFilter<"Profile"> | string | null
    linkedin?: StringNullableFilter<"Profile"> | string | null
    twitter?: StringNullableFilter<"Profile"> | string | null
    facebook?: StringNullableFilter<"Profile"> | string | null
    instagram?: StringNullableFilter<"Profile"> | string | null
    created_at?: DateTimeFilter<"Profile"> | Date | string
    updated_at?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    emails?: ProfileEmailListRelationFilter
    phones?: ProfilePhoneListRelationFilter
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    jobTitle?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    address1?: SortOrderInput | SortOrder
    address2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    emails?: ProfileEmailOrderByRelationAggregateInput
    phones?: ProfilePhoneOrderByRelationAggregateInput
    _relevance?: ProfileOrderByRelevanceInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    firstName?: StringNullableFilter<"Profile"> | string | null
    lastName?: StringNullableFilter<"Profile"> | string | null
    displayName?: StringNullableFilter<"Profile"> | string | null
    bio?: StringNullableFilter<"Profile"> | string | null
    jobTitle?: StringNullableFilter<"Profile"> | string | null
    company?: StringNullableFilter<"Profile"> | string | null
    address1?: StringNullableFilter<"Profile"> | string | null
    address2?: StringNullableFilter<"Profile"> | string | null
    city?: StringNullableFilter<"Profile"> | string | null
    state?: StringNullableFilter<"Profile"> | string | null
    zipCode?: StringNullableFilter<"Profile"> | string | null
    country?: StringNullableFilter<"Profile"> | string | null
    language?: StringNullableFilter<"Profile"> | string | null
    timezone?: StringNullableFilter<"Profile"> | string | null
    website?: StringNullableFilter<"Profile"> | string | null
    linkedin?: StringNullableFilter<"Profile"> | string | null
    twitter?: StringNullableFilter<"Profile"> | string | null
    facebook?: StringNullableFilter<"Profile"> | string | null
    instagram?: StringNullableFilter<"Profile"> | string | null
    created_at?: DateTimeFilter<"Profile"> | Date | string
    updated_at?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    emails?: ProfileEmailListRelationFilter
    phones?: ProfilePhoneListRelationFilter
  }, "id" | "userId">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    jobTitle?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    address1?: SortOrderInput | SortOrder
    address2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    userId?: StringWithAggregatesFilter<"Profile"> | string
    firstName?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    displayName?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    bio?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    jobTitle?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    company?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    address1?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    address2?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    city?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    state?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    zipCode?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    country?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    language?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    timezone?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    website?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    linkedin?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    twitter?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    facebook?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
  }

  export type ProfileEmailWhereInput = {
    AND?: ProfileEmailWhereInput | ProfileEmailWhereInput[]
    OR?: ProfileEmailWhereInput[]
    NOT?: ProfileEmailWhereInput | ProfileEmailWhereInput[]
    id?: StringFilter<"ProfileEmail"> | string
    profileId?: StringFilter<"ProfileEmail"> | string
    email?: StringFilter<"ProfileEmail"> | string
    type?: StringFilter<"ProfileEmail"> | string
    isPrimary?: BoolFilter<"ProfileEmail"> | boolean
    isVerified?: BoolFilter<"ProfileEmail"> | boolean
    created_at?: DateTimeFilter<"ProfileEmail"> | Date | string
    updated_at?: DateTimeFilter<"ProfileEmail"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type ProfileEmailOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    email?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    isVerified?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    _relevance?: ProfileEmailOrderByRelevanceInput
  }

  export type ProfileEmailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profileId_email?: ProfileEmailProfileIdEmailCompoundUniqueInput
    AND?: ProfileEmailWhereInput | ProfileEmailWhereInput[]
    OR?: ProfileEmailWhereInput[]
    NOT?: ProfileEmailWhereInput | ProfileEmailWhereInput[]
    profileId?: StringFilter<"ProfileEmail"> | string
    email?: StringFilter<"ProfileEmail"> | string
    type?: StringFilter<"ProfileEmail"> | string
    isPrimary?: BoolFilter<"ProfileEmail"> | boolean
    isVerified?: BoolFilter<"ProfileEmail"> | boolean
    created_at?: DateTimeFilter<"ProfileEmail"> | Date | string
    updated_at?: DateTimeFilter<"ProfileEmail"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id" | "profileId_email">

  export type ProfileEmailOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    email?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    isVerified?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProfileEmailCountOrderByAggregateInput
    _max?: ProfileEmailMaxOrderByAggregateInput
    _min?: ProfileEmailMinOrderByAggregateInput
  }

  export type ProfileEmailScalarWhereWithAggregatesInput = {
    AND?: ProfileEmailScalarWhereWithAggregatesInput | ProfileEmailScalarWhereWithAggregatesInput[]
    OR?: ProfileEmailScalarWhereWithAggregatesInput[]
    NOT?: ProfileEmailScalarWhereWithAggregatesInput | ProfileEmailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProfileEmail"> | string
    profileId?: StringWithAggregatesFilter<"ProfileEmail"> | string
    email?: StringWithAggregatesFilter<"ProfileEmail"> | string
    type?: StringWithAggregatesFilter<"ProfileEmail"> | string
    isPrimary?: BoolWithAggregatesFilter<"ProfileEmail"> | boolean
    isVerified?: BoolWithAggregatesFilter<"ProfileEmail"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"ProfileEmail"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ProfileEmail"> | Date | string
  }

  export type ProfilePhoneWhereInput = {
    AND?: ProfilePhoneWhereInput | ProfilePhoneWhereInput[]
    OR?: ProfilePhoneWhereInput[]
    NOT?: ProfilePhoneWhereInput | ProfilePhoneWhereInput[]
    id?: StringFilter<"ProfilePhone"> | string
    profileId?: StringFilter<"ProfilePhone"> | string
    phoneNumber?: StringFilter<"ProfilePhone"> | string
    type?: StringFilter<"ProfilePhone"> | string
    isPrimary?: BoolFilter<"ProfilePhone"> | boolean
    isVerified?: BoolFilter<"ProfilePhone"> | boolean
    created_at?: DateTimeFilter<"ProfilePhone"> | Date | string
    updated_at?: DateTimeFilter<"ProfilePhone"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type ProfilePhoneOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    phoneNumber?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    isVerified?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    _relevance?: ProfilePhoneOrderByRelevanceInput
  }

  export type ProfilePhoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profileId_phoneNumber?: ProfilePhoneProfileIdPhoneNumberCompoundUniqueInput
    AND?: ProfilePhoneWhereInput | ProfilePhoneWhereInput[]
    OR?: ProfilePhoneWhereInput[]
    NOT?: ProfilePhoneWhereInput | ProfilePhoneWhereInput[]
    profileId?: StringFilter<"ProfilePhone"> | string
    phoneNumber?: StringFilter<"ProfilePhone"> | string
    type?: StringFilter<"ProfilePhone"> | string
    isPrimary?: BoolFilter<"ProfilePhone"> | boolean
    isVerified?: BoolFilter<"ProfilePhone"> | boolean
    created_at?: DateTimeFilter<"ProfilePhone"> | Date | string
    updated_at?: DateTimeFilter<"ProfilePhone"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id" | "profileId_phoneNumber">

  export type ProfilePhoneOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    phoneNumber?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    isVerified?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProfilePhoneCountOrderByAggregateInput
    _max?: ProfilePhoneMaxOrderByAggregateInput
    _min?: ProfilePhoneMinOrderByAggregateInput
  }

  export type ProfilePhoneScalarWhereWithAggregatesInput = {
    AND?: ProfilePhoneScalarWhereWithAggregatesInput | ProfilePhoneScalarWhereWithAggregatesInput[]
    OR?: ProfilePhoneScalarWhereWithAggregatesInput[]
    NOT?: ProfilePhoneScalarWhereWithAggregatesInput | ProfilePhoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProfilePhone"> | string
    profileId?: StringWithAggregatesFilter<"ProfilePhone"> | string
    phoneNumber?: StringWithAggregatesFilter<"ProfilePhone"> | string
    type?: StringWithAggregatesFilter<"ProfilePhone"> | string
    isPrimary?: BoolWithAggregatesFilter<"ProfilePhone"> | boolean
    isVerified?: BoolWithAggregatesFilter<"ProfilePhone"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"ProfilePhone"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ProfilePhone"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    account_id?: StringFilter<"Client"> | string
    client_type?: EnumClientTypeFilter<"Client"> | $Enums.ClientType
    name?: StringFilter<"Client"> | string
    company_name?: StringNullableFilter<"Client"> | string | null
    tax_id?: StringNullableFilter<"Client"> | string | null
    website?: StringNullableFilter<"Client"> | string | null
    notes?: StringNullableFilter<"Client"> | string | null
    is_active?: BoolFilter<"Client"> | boolean
    created_at?: DateTimeFilter<"Client"> | Date | string
    updated_at?: DateTimeFilter<"Client"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    billings?: BillingListRelationFilter
    phones?: ClientPhoneListRelationFilter
    emails?: ClientEmailListRelationFilter
    addresses?: ClientAddressListRelationFilter
    ClientCompany?: ClientCompanyListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    account_id?: SortOrder
    client_type?: SortOrder
    name?: SortOrder
    company_name?: SortOrderInput | SortOrder
    tax_id?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    account?: AccountOrderByWithRelationInput
    billings?: BillingOrderByRelationAggregateInput
    phones?: ClientPhoneOrderByRelationAggregateInput
    emails?: ClientEmailOrderByRelationAggregateInput
    addresses?: ClientAddressOrderByRelationAggregateInput
    ClientCompany?: ClientCompanyOrderByRelationAggregateInput
    _relevance?: ClientOrderByRelevanceInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    account_id_name?: ClientAccount_idNameCompoundUniqueInput
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    account_id?: StringFilter<"Client"> | string
    client_type?: EnumClientTypeFilter<"Client"> | $Enums.ClientType
    name?: StringFilter<"Client"> | string
    company_name?: StringNullableFilter<"Client"> | string | null
    tax_id?: StringNullableFilter<"Client"> | string | null
    website?: StringNullableFilter<"Client"> | string | null
    notes?: StringNullableFilter<"Client"> | string | null
    is_active?: BoolFilter<"Client"> | boolean
    created_at?: DateTimeFilter<"Client"> | Date | string
    updated_at?: DateTimeFilter<"Client"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    billings?: BillingListRelationFilter
    phones?: ClientPhoneListRelationFilter
    emails?: ClientEmailListRelationFilter
    addresses?: ClientAddressListRelationFilter
    ClientCompany?: ClientCompanyListRelationFilter
  }, "id" | "account_id_name">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    account_id?: SortOrder
    client_type?: SortOrder
    name?: SortOrder
    company_name?: SortOrderInput | SortOrder
    tax_id?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    account_id?: StringWithAggregatesFilter<"Client"> | string
    client_type?: EnumClientTypeWithAggregatesFilter<"Client"> | $Enums.ClientType
    name?: StringWithAggregatesFilter<"Client"> | string
    company_name?: StringNullableWithAggregatesFilter<"Client"> | string | null
    tax_id?: StringNullableWithAggregatesFilter<"Client"> | string | null
    website?: StringNullableWithAggregatesFilter<"Client"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Client"> | string | null
    is_active?: BoolWithAggregatesFilter<"Client"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type ClientPhoneWhereInput = {
    AND?: ClientPhoneWhereInput | ClientPhoneWhereInput[]
    OR?: ClientPhoneWhereInput[]
    NOT?: ClientPhoneWhereInput | ClientPhoneWhereInput[]
    id?: StringFilter<"ClientPhone"> | string
    client_id?: StringFilter<"ClientPhone"> | string
    phone_number?: StringFilter<"ClientPhone"> | string
    type?: StringFilter<"ClientPhone"> | string
    is_primary?: BoolFilter<"ClientPhone"> | boolean
    created_at?: DateTimeFilter<"ClientPhone"> | Date | string
    updated_at?: DateTimeFilter<"ClientPhone"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type ClientPhoneOrderByWithRelationInput = {
    id?: SortOrder
    client_id?: SortOrder
    phone_number?: SortOrder
    type?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client?: ClientOrderByWithRelationInput
    _relevance?: ClientPhoneOrderByRelevanceInput
  }

  export type ClientPhoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    client_id_phone_number?: ClientPhoneClient_idPhone_numberCompoundUniqueInput
    AND?: ClientPhoneWhereInput | ClientPhoneWhereInput[]
    OR?: ClientPhoneWhereInput[]
    NOT?: ClientPhoneWhereInput | ClientPhoneWhereInput[]
    client_id?: StringFilter<"ClientPhone"> | string
    phone_number?: StringFilter<"ClientPhone"> | string
    type?: StringFilter<"ClientPhone"> | string
    is_primary?: BoolFilter<"ClientPhone"> | boolean
    created_at?: DateTimeFilter<"ClientPhone"> | Date | string
    updated_at?: DateTimeFilter<"ClientPhone"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id" | "client_id_phone_number">

  export type ClientPhoneOrderByWithAggregationInput = {
    id?: SortOrder
    client_id?: SortOrder
    phone_number?: SortOrder
    type?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ClientPhoneCountOrderByAggregateInput
    _max?: ClientPhoneMaxOrderByAggregateInput
    _min?: ClientPhoneMinOrderByAggregateInput
  }

  export type ClientPhoneScalarWhereWithAggregatesInput = {
    AND?: ClientPhoneScalarWhereWithAggregatesInput | ClientPhoneScalarWhereWithAggregatesInput[]
    OR?: ClientPhoneScalarWhereWithAggregatesInput[]
    NOT?: ClientPhoneScalarWhereWithAggregatesInput | ClientPhoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientPhone"> | string
    client_id?: StringWithAggregatesFilter<"ClientPhone"> | string
    phone_number?: StringWithAggregatesFilter<"ClientPhone"> | string
    type?: StringWithAggregatesFilter<"ClientPhone"> | string
    is_primary?: BoolWithAggregatesFilter<"ClientPhone"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"ClientPhone"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ClientPhone"> | Date | string
  }

  export type ClientEmailWhereInput = {
    AND?: ClientEmailWhereInput | ClientEmailWhereInput[]
    OR?: ClientEmailWhereInput[]
    NOT?: ClientEmailWhereInput | ClientEmailWhereInput[]
    id?: StringFilter<"ClientEmail"> | string
    client_id?: StringFilter<"ClientEmail"> | string
    email?: StringFilter<"ClientEmail"> | string
    type?: StringFilter<"ClientEmail"> | string
    is_primary?: BoolFilter<"ClientEmail"> | boolean
    created_at?: DateTimeFilter<"ClientEmail"> | Date | string
    updated_at?: DateTimeFilter<"ClientEmail"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type ClientEmailOrderByWithRelationInput = {
    id?: SortOrder
    client_id?: SortOrder
    email?: SortOrder
    type?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client?: ClientOrderByWithRelationInput
    _relevance?: ClientEmailOrderByRelevanceInput
  }

  export type ClientEmailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    client_id_email?: ClientEmailClient_idEmailCompoundUniqueInput
    AND?: ClientEmailWhereInput | ClientEmailWhereInput[]
    OR?: ClientEmailWhereInput[]
    NOT?: ClientEmailWhereInput | ClientEmailWhereInput[]
    client_id?: StringFilter<"ClientEmail"> | string
    email?: StringFilter<"ClientEmail"> | string
    type?: StringFilter<"ClientEmail"> | string
    is_primary?: BoolFilter<"ClientEmail"> | boolean
    created_at?: DateTimeFilter<"ClientEmail"> | Date | string
    updated_at?: DateTimeFilter<"ClientEmail"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id" | "client_id_email">

  export type ClientEmailOrderByWithAggregationInput = {
    id?: SortOrder
    client_id?: SortOrder
    email?: SortOrder
    type?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ClientEmailCountOrderByAggregateInput
    _max?: ClientEmailMaxOrderByAggregateInput
    _min?: ClientEmailMinOrderByAggregateInput
  }

  export type ClientEmailScalarWhereWithAggregatesInput = {
    AND?: ClientEmailScalarWhereWithAggregatesInput | ClientEmailScalarWhereWithAggregatesInput[]
    OR?: ClientEmailScalarWhereWithAggregatesInput[]
    NOT?: ClientEmailScalarWhereWithAggregatesInput | ClientEmailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientEmail"> | string
    client_id?: StringWithAggregatesFilter<"ClientEmail"> | string
    email?: StringWithAggregatesFilter<"ClientEmail"> | string
    type?: StringWithAggregatesFilter<"ClientEmail"> | string
    is_primary?: BoolWithAggregatesFilter<"ClientEmail"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"ClientEmail"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ClientEmail"> | Date | string
  }

  export type ClientAddressWhereInput = {
    AND?: ClientAddressWhereInput | ClientAddressWhereInput[]
    OR?: ClientAddressWhereInput[]
    NOT?: ClientAddressWhereInput | ClientAddressWhereInput[]
    id?: StringFilter<"ClientAddress"> | string
    client_id?: StringFilter<"ClientAddress"> | string
    type?: StringFilter<"ClientAddress"> | string
    street?: StringFilter<"ClientAddress"> | string
    suite?: StringNullableFilter<"ClientAddress"> | string | null
    city?: StringFilter<"ClientAddress"> | string
    state?: StringFilter<"ClientAddress"> | string
    zip_code?: StringFilter<"ClientAddress"> | string
    country?: StringFilter<"ClientAddress"> | string
    is_primary?: BoolFilter<"ClientAddress"> | boolean
    created_at?: DateTimeFilter<"ClientAddress"> | Date | string
    updated_at?: DateTimeFilter<"ClientAddress"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type ClientAddressOrderByWithRelationInput = {
    id?: SortOrder
    client_id?: SortOrder
    type?: SortOrder
    street?: SortOrder
    suite?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    zip_code?: SortOrder
    country?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client?: ClientOrderByWithRelationInput
    _relevance?: ClientAddressOrderByRelevanceInput
  }

  export type ClientAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientAddressWhereInput | ClientAddressWhereInput[]
    OR?: ClientAddressWhereInput[]
    NOT?: ClientAddressWhereInput | ClientAddressWhereInput[]
    client_id?: StringFilter<"ClientAddress"> | string
    type?: StringFilter<"ClientAddress"> | string
    street?: StringFilter<"ClientAddress"> | string
    suite?: StringNullableFilter<"ClientAddress"> | string | null
    city?: StringFilter<"ClientAddress"> | string
    state?: StringFilter<"ClientAddress"> | string
    zip_code?: StringFilter<"ClientAddress"> | string
    country?: StringFilter<"ClientAddress"> | string
    is_primary?: BoolFilter<"ClientAddress"> | boolean
    created_at?: DateTimeFilter<"ClientAddress"> | Date | string
    updated_at?: DateTimeFilter<"ClientAddress"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id">

  export type ClientAddressOrderByWithAggregationInput = {
    id?: SortOrder
    client_id?: SortOrder
    type?: SortOrder
    street?: SortOrder
    suite?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    zip_code?: SortOrder
    country?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ClientAddressCountOrderByAggregateInput
    _max?: ClientAddressMaxOrderByAggregateInput
    _min?: ClientAddressMinOrderByAggregateInput
  }

  export type ClientAddressScalarWhereWithAggregatesInput = {
    AND?: ClientAddressScalarWhereWithAggregatesInput | ClientAddressScalarWhereWithAggregatesInput[]
    OR?: ClientAddressScalarWhereWithAggregatesInput[]
    NOT?: ClientAddressScalarWhereWithAggregatesInput | ClientAddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientAddress"> | string
    client_id?: StringWithAggregatesFilter<"ClientAddress"> | string
    type?: StringWithAggregatesFilter<"ClientAddress"> | string
    street?: StringWithAggregatesFilter<"ClientAddress"> | string
    suite?: StringNullableWithAggregatesFilter<"ClientAddress"> | string | null
    city?: StringWithAggregatesFilter<"ClientAddress"> | string
    state?: StringWithAggregatesFilter<"ClientAddress"> | string
    zip_code?: StringWithAggregatesFilter<"ClientAddress"> | string
    country?: StringWithAggregatesFilter<"ClientAddress"> | string
    is_primary?: BoolWithAggregatesFilter<"ClientAddress"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"ClientAddress"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ClientAddress"> | Date | string
  }

  export type ClientCompanyWhereInput = {
    AND?: ClientCompanyWhereInput | ClientCompanyWhereInput[]
    OR?: ClientCompanyWhereInput[]
    NOT?: ClientCompanyWhereInput | ClientCompanyWhereInput[]
    id?: StringFilter<"ClientCompany"> | string
    client_id?: StringFilter<"ClientCompany"> | string
    name?: StringFilter<"ClientCompany"> | string
    tax_id?: StringNullableFilter<"ClientCompany"> | string | null
    website?: StringNullableFilter<"ClientCompany"> | string | null
    notes?: StringNullableFilter<"ClientCompany"> | string | null
    is_active?: BoolFilter<"ClientCompany"> | boolean
    created_at?: DateTimeFilter<"ClientCompany"> | Date | string
    updated_at?: DateTimeFilter<"ClientCompany"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    phones?: ClientCompanyPhoneListRelationFilter
    emails?: ClientCompanyEmailListRelationFilter
    addresses?: ClientCompanyAddressListRelationFilter
    billings?: BillingListRelationFilter
  }

  export type ClientCompanyOrderByWithRelationInput = {
    id?: SortOrder
    client_id?: SortOrder
    name?: SortOrder
    tax_id?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client?: ClientOrderByWithRelationInput
    phones?: ClientCompanyPhoneOrderByRelationAggregateInput
    emails?: ClientCompanyEmailOrderByRelationAggregateInput
    addresses?: ClientCompanyAddressOrderByRelationAggregateInput
    billings?: BillingOrderByRelationAggregateInput
    _relevance?: ClientCompanyOrderByRelevanceInput
  }

  export type ClientCompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    client_id_name?: ClientCompanyClient_idNameCompoundUniqueInput
    AND?: ClientCompanyWhereInput | ClientCompanyWhereInput[]
    OR?: ClientCompanyWhereInput[]
    NOT?: ClientCompanyWhereInput | ClientCompanyWhereInput[]
    client_id?: StringFilter<"ClientCompany"> | string
    name?: StringFilter<"ClientCompany"> | string
    tax_id?: StringNullableFilter<"ClientCompany"> | string | null
    website?: StringNullableFilter<"ClientCompany"> | string | null
    notes?: StringNullableFilter<"ClientCompany"> | string | null
    is_active?: BoolFilter<"ClientCompany"> | boolean
    created_at?: DateTimeFilter<"ClientCompany"> | Date | string
    updated_at?: DateTimeFilter<"ClientCompany"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    phones?: ClientCompanyPhoneListRelationFilter
    emails?: ClientCompanyEmailListRelationFilter
    addresses?: ClientCompanyAddressListRelationFilter
    billings?: BillingListRelationFilter
  }, "id" | "client_id_name">

  export type ClientCompanyOrderByWithAggregationInput = {
    id?: SortOrder
    client_id?: SortOrder
    name?: SortOrder
    tax_id?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ClientCompanyCountOrderByAggregateInput
    _max?: ClientCompanyMaxOrderByAggregateInput
    _min?: ClientCompanyMinOrderByAggregateInput
  }

  export type ClientCompanyScalarWhereWithAggregatesInput = {
    AND?: ClientCompanyScalarWhereWithAggregatesInput | ClientCompanyScalarWhereWithAggregatesInput[]
    OR?: ClientCompanyScalarWhereWithAggregatesInput[]
    NOT?: ClientCompanyScalarWhereWithAggregatesInput | ClientCompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientCompany"> | string
    client_id?: StringWithAggregatesFilter<"ClientCompany"> | string
    name?: StringWithAggregatesFilter<"ClientCompany"> | string
    tax_id?: StringNullableWithAggregatesFilter<"ClientCompany"> | string | null
    website?: StringNullableWithAggregatesFilter<"ClientCompany"> | string | null
    notes?: StringNullableWithAggregatesFilter<"ClientCompany"> | string | null
    is_active?: BoolWithAggregatesFilter<"ClientCompany"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"ClientCompany"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ClientCompany"> | Date | string
  }

  export type ClientCompanyPhoneWhereInput = {
    AND?: ClientCompanyPhoneWhereInput | ClientCompanyPhoneWhereInput[]
    OR?: ClientCompanyPhoneWhereInput[]
    NOT?: ClientCompanyPhoneWhereInput | ClientCompanyPhoneWhereInput[]
    id?: StringFilter<"ClientCompanyPhone"> | string
    company_id?: StringFilter<"ClientCompanyPhone"> | string
    phone_number?: StringFilter<"ClientCompanyPhone"> | string
    type?: StringFilter<"ClientCompanyPhone"> | string
    is_primary?: BoolFilter<"ClientCompanyPhone"> | boolean
    created_at?: DateTimeFilter<"ClientCompanyPhone"> | Date | string
    updated_at?: DateTimeFilter<"ClientCompanyPhone"> | Date | string
    company?: XOR<ClientCompanyScalarRelationFilter, ClientCompanyWhereInput>
  }

  export type ClientCompanyPhoneOrderByWithRelationInput = {
    id?: SortOrder
    company_id?: SortOrder
    phone_number?: SortOrder
    type?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    company?: ClientCompanyOrderByWithRelationInput
    _relevance?: ClientCompanyPhoneOrderByRelevanceInput
  }

  export type ClientCompanyPhoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientCompanyPhoneWhereInput | ClientCompanyPhoneWhereInput[]
    OR?: ClientCompanyPhoneWhereInput[]
    NOT?: ClientCompanyPhoneWhereInput | ClientCompanyPhoneWhereInput[]
    company_id?: StringFilter<"ClientCompanyPhone"> | string
    phone_number?: StringFilter<"ClientCompanyPhone"> | string
    type?: StringFilter<"ClientCompanyPhone"> | string
    is_primary?: BoolFilter<"ClientCompanyPhone"> | boolean
    created_at?: DateTimeFilter<"ClientCompanyPhone"> | Date | string
    updated_at?: DateTimeFilter<"ClientCompanyPhone"> | Date | string
    company?: XOR<ClientCompanyScalarRelationFilter, ClientCompanyWhereInput>
  }, "id">

  export type ClientCompanyPhoneOrderByWithAggregationInput = {
    id?: SortOrder
    company_id?: SortOrder
    phone_number?: SortOrder
    type?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ClientCompanyPhoneCountOrderByAggregateInput
    _max?: ClientCompanyPhoneMaxOrderByAggregateInput
    _min?: ClientCompanyPhoneMinOrderByAggregateInput
  }

  export type ClientCompanyPhoneScalarWhereWithAggregatesInput = {
    AND?: ClientCompanyPhoneScalarWhereWithAggregatesInput | ClientCompanyPhoneScalarWhereWithAggregatesInput[]
    OR?: ClientCompanyPhoneScalarWhereWithAggregatesInput[]
    NOT?: ClientCompanyPhoneScalarWhereWithAggregatesInput | ClientCompanyPhoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientCompanyPhone"> | string
    company_id?: StringWithAggregatesFilter<"ClientCompanyPhone"> | string
    phone_number?: StringWithAggregatesFilter<"ClientCompanyPhone"> | string
    type?: StringWithAggregatesFilter<"ClientCompanyPhone"> | string
    is_primary?: BoolWithAggregatesFilter<"ClientCompanyPhone"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"ClientCompanyPhone"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ClientCompanyPhone"> | Date | string
  }

  export type ClientCompanyEmailWhereInput = {
    AND?: ClientCompanyEmailWhereInput | ClientCompanyEmailWhereInput[]
    OR?: ClientCompanyEmailWhereInput[]
    NOT?: ClientCompanyEmailWhereInput | ClientCompanyEmailWhereInput[]
    id?: StringFilter<"ClientCompanyEmail"> | string
    company_id?: StringFilter<"ClientCompanyEmail"> | string
    email?: StringFilter<"ClientCompanyEmail"> | string
    type?: StringFilter<"ClientCompanyEmail"> | string
    is_primary?: BoolFilter<"ClientCompanyEmail"> | boolean
    created_at?: DateTimeFilter<"ClientCompanyEmail"> | Date | string
    updated_at?: DateTimeFilter<"ClientCompanyEmail"> | Date | string
    company?: XOR<ClientCompanyScalarRelationFilter, ClientCompanyWhereInput>
  }

  export type ClientCompanyEmailOrderByWithRelationInput = {
    id?: SortOrder
    company_id?: SortOrder
    email?: SortOrder
    type?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    company?: ClientCompanyOrderByWithRelationInput
    _relevance?: ClientCompanyEmailOrderByRelevanceInput
  }

  export type ClientCompanyEmailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientCompanyEmailWhereInput | ClientCompanyEmailWhereInput[]
    OR?: ClientCompanyEmailWhereInput[]
    NOT?: ClientCompanyEmailWhereInput | ClientCompanyEmailWhereInput[]
    company_id?: StringFilter<"ClientCompanyEmail"> | string
    email?: StringFilter<"ClientCompanyEmail"> | string
    type?: StringFilter<"ClientCompanyEmail"> | string
    is_primary?: BoolFilter<"ClientCompanyEmail"> | boolean
    created_at?: DateTimeFilter<"ClientCompanyEmail"> | Date | string
    updated_at?: DateTimeFilter<"ClientCompanyEmail"> | Date | string
    company?: XOR<ClientCompanyScalarRelationFilter, ClientCompanyWhereInput>
  }, "id">

  export type ClientCompanyEmailOrderByWithAggregationInput = {
    id?: SortOrder
    company_id?: SortOrder
    email?: SortOrder
    type?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ClientCompanyEmailCountOrderByAggregateInput
    _max?: ClientCompanyEmailMaxOrderByAggregateInput
    _min?: ClientCompanyEmailMinOrderByAggregateInput
  }

  export type ClientCompanyEmailScalarWhereWithAggregatesInput = {
    AND?: ClientCompanyEmailScalarWhereWithAggregatesInput | ClientCompanyEmailScalarWhereWithAggregatesInput[]
    OR?: ClientCompanyEmailScalarWhereWithAggregatesInput[]
    NOT?: ClientCompanyEmailScalarWhereWithAggregatesInput | ClientCompanyEmailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientCompanyEmail"> | string
    company_id?: StringWithAggregatesFilter<"ClientCompanyEmail"> | string
    email?: StringWithAggregatesFilter<"ClientCompanyEmail"> | string
    type?: StringWithAggregatesFilter<"ClientCompanyEmail"> | string
    is_primary?: BoolWithAggregatesFilter<"ClientCompanyEmail"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"ClientCompanyEmail"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ClientCompanyEmail"> | Date | string
  }

  export type ClientCompanyAddressWhereInput = {
    AND?: ClientCompanyAddressWhereInput | ClientCompanyAddressWhereInput[]
    OR?: ClientCompanyAddressWhereInput[]
    NOT?: ClientCompanyAddressWhereInput | ClientCompanyAddressWhereInput[]
    id?: StringFilter<"ClientCompanyAddress"> | string
    company_id?: StringFilter<"ClientCompanyAddress"> | string
    type?: StringFilter<"ClientCompanyAddress"> | string
    street?: StringFilter<"ClientCompanyAddress"> | string
    suite?: StringNullableFilter<"ClientCompanyAddress"> | string | null
    city?: StringFilter<"ClientCompanyAddress"> | string
    state?: StringFilter<"ClientCompanyAddress"> | string
    zip_code?: StringFilter<"ClientCompanyAddress"> | string
    country?: StringFilter<"ClientCompanyAddress"> | string
    is_primary?: BoolFilter<"ClientCompanyAddress"> | boolean
    created_at?: DateTimeFilter<"ClientCompanyAddress"> | Date | string
    updated_at?: DateTimeFilter<"ClientCompanyAddress"> | Date | string
    company?: XOR<ClientCompanyScalarRelationFilter, ClientCompanyWhereInput>
  }

  export type ClientCompanyAddressOrderByWithRelationInput = {
    id?: SortOrder
    company_id?: SortOrder
    type?: SortOrder
    street?: SortOrder
    suite?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    zip_code?: SortOrder
    country?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    company?: ClientCompanyOrderByWithRelationInput
    _relevance?: ClientCompanyAddressOrderByRelevanceInput
  }

  export type ClientCompanyAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientCompanyAddressWhereInput | ClientCompanyAddressWhereInput[]
    OR?: ClientCompanyAddressWhereInput[]
    NOT?: ClientCompanyAddressWhereInput | ClientCompanyAddressWhereInput[]
    company_id?: StringFilter<"ClientCompanyAddress"> | string
    type?: StringFilter<"ClientCompanyAddress"> | string
    street?: StringFilter<"ClientCompanyAddress"> | string
    suite?: StringNullableFilter<"ClientCompanyAddress"> | string | null
    city?: StringFilter<"ClientCompanyAddress"> | string
    state?: StringFilter<"ClientCompanyAddress"> | string
    zip_code?: StringFilter<"ClientCompanyAddress"> | string
    country?: StringFilter<"ClientCompanyAddress"> | string
    is_primary?: BoolFilter<"ClientCompanyAddress"> | boolean
    created_at?: DateTimeFilter<"ClientCompanyAddress"> | Date | string
    updated_at?: DateTimeFilter<"ClientCompanyAddress"> | Date | string
    company?: XOR<ClientCompanyScalarRelationFilter, ClientCompanyWhereInput>
  }, "id">

  export type ClientCompanyAddressOrderByWithAggregationInput = {
    id?: SortOrder
    company_id?: SortOrder
    type?: SortOrder
    street?: SortOrder
    suite?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    zip_code?: SortOrder
    country?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ClientCompanyAddressCountOrderByAggregateInput
    _max?: ClientCompanyAddressMaxOrderByAggregateInput
    _min?: ClientCompanyAddressMinOrderByAggregateInput
  }

  export type ClientCompanyAddressScalarWhereWithAggregatesInput = {
    AND?: ClientCompanyAddressScalarWhereWithAggregatesInput | ClientCompanyAddressScalarWhereWithAggregatesInput[]
    OR?: ClientCompanyAddressScalarWhereWithAggregatesInput[]
    NOT?: ClientCompanyAddressScalarWhereWithAggregatesInput | ClientCompanyAddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientCompanyAddress"> | string
    company_id?: StringWithAggregatesFilter<"ClientCompanyAddress"> | string
    type?: StringWithAggregatesFilter<"ClientCompanyAddress"> | string
    street?: StringWithAggregatesFilter<"ClientCompanyAddress"> | string
    suite?: StringNullableWithAggregatesFilter<"ClientCompanyAddress"> | string | null
    city?: StringWithAggregatesFilter<"ClientCompanyAddress"> | string
    state?: StringWithAggregatesFilter<"ClientCompanyAddress"> | string
    zip_code?: StringWithAggregatesFilter<"ClientCompanyAddress"> | string
    country?: StringWithAggregatesFilter<"ClientCompanyAddress"> | string
    is_primary?: BoolWithAggregatesFilter<"ClientCompanyAddress"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"ClientCompanyAddress"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ClientCompanyAddress"> | Date | string
  }

  export type UnitOfMeasureWhereInput = {
    AND?: UnitOfMeasureWhereInput | UnitOfMeasureWhereInput[]
    OR?: UnitOfMeasureWhereInput[]
    NOT?: UnitOfMeasureWhereInput | UnitOfMeasureWhereInput[]
    id?: StringFilter<"UnitOfMeasure"> | string
    account_id?: StringFilter<"UnitOfMeasure"> | string
    name?: StringFilter<"UnitOfMeasure"> | string
    symbol?: StringFilter<"UnitOfMeasure"> | string
    description?: StringNullableFilter<"UnitOfMeasure"> | string | null
    is_default?: BoolFilter<"UnitOfMeasure"> | boolean
    created_at?: DateTimeFilter<"UnitOfMeasure"> | Date | string
    updated_at?: DateTimeFilter<"UnitOfMeasure"> | Date | string
    services?: ServiceListRelationFilter
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type UnitOfMeasureOrderByWithRelationInput = {
    id?: SortOrder
    account_id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrderInput | SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    services?: ServiceOrderByRelationAggregateInput
    account?: AccountOrderByWithRelationInput
    _relevance?: UnitOfMeasureOrderByRelevanceInput
  }

  export type UnitOfMeasureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    account_id_name?: UnitOfMeasureAccount_idNameCompoundUniqueInput
    AND?: UnitOfMeasureWhereInput | UnitOfMeasureWhereInput[]
    OR?: UnitOfMeasureWhereInput[]
    NOT?: UnitOfMeasureWhereInput | UnitOfMeasureWhereInput[]
    account_id?: StringFilter<"UnitOfMeasure"> | string
    name?: StringFilter<"UnitOfMeasure"> | string
    symbol?: StringFilter<"UnitOfMeasure"> | string
    description?: StringNullableFilter<"UnitOfMeasure"> | string | null
    is_default?: BoolFilter<"UnitOfMeasure"> | boolean
    created_at?: DateTimeFilter<"UnitOfMeasure"> | Date | string
    updated_at?: DateTimeFilter<"UnitOfMeasure"> | Date | string
    services?: ServiceListRelationFilter
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "id" | "account_id_name">

  export type UnitOfMeasureOrderByWithAggregationInput = {
    id?: SortOrder
    account_id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrderInput | SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UnitOfMeasureCountOrderByAggregateInput
    _max?: UnitOfMeasureMaxOrderByAggregateInput
    _min?: UnitOfMeasureMinOrderByAggregateInput
  }

  export type UnitOfMeasureScalarWhereWithAggregatesInput = {
    AND?: UnitOfMeasureScalarWhereWithAggregatesInput | UnitOfMeasureScalarWhereWithAggregatesInput[]
    OR?: UnitOfMeasureScalarWhereWithAggregatesInput[]
    NOT?: UnitOfMeasureScalarWhereWithAggregatesInput | UnitOfMeasureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnitOfMeasure"> | string
    account_id?: StringWithAggregatesFilter<"UnitOfMeasure"> | string
    name?: StringWithAggregatesFilter<"UnitOfMeasure"> | string
    symbol?: StringWithAggregatesFilter<"UnitOfMeasure"> | string
    description?: StringNullableWithAggregatesFilter<"UnitOfMeasure"> | string | null
    is_default?: BoolWithAggregatesFilter<"UnitOfMeasure"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"UnitOfMeasure"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"UnitOfMeasure"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    account_id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    price?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    unit_of_measure_id?: StringFilter<"Service"> | string
    is_discount?: BoolFilter<"Service"> | boolean
    is_active?: BoolFilter<"Service"> | boolean
    created_at?: DateTimeFilter<"Service"> | Date | string
    updated_at?: DateTimeFilter<"Service"> | Date | string
    billing_items?: BillingItemListRelationFilter
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    unit_of_measure?: XOR<UnitOfMeasureScalarRelationFilter, UnitOfMeasureWhereInput>
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    account_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    unit_of_measure_id?: SortOrder
    is_discount?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    billing_items?: BillingItemOrderByRelationAggregateInput
    account?: AccountOrderByWithRelationInput
    unit_of_measure?: UnitOfMeasureOrderByWithRelationInput
    _relevance?: ServiceOrderByRelevanceInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    account_id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    price?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    unit_of_measure_id?: StringFilter<"Service"> | string
    is_discount?: BoolFilter<"Service"> | boolean
    is_active?: BoolFilter<"Service"> | boolean
    created_at?: DateTimeFilter<"Service"> | Date | string
    updated_at?: DateTimeFilter<"Service"> | Date | string
    billing_items?: BillingItemListRelationFilter
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    unit_of_measure?: XOR<UnitOfMeasureScalarRelationFilter, UnitOfMeasureWhereInput>
  }, "id">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    account_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    unit_of_measure_id?: SortOrder
    is_discount?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    account_id?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
    price?: DecimalWithAggregatesFilter<"Service"> | Decimal | DecimalJsLike | number | string
    unit_of_measure_id?: StringWithAggregatesFilter<"Service"> | string
    is_discount?: BoolWithAggregatesFilter<"Service"> | boolean
    is_active?: BoolWithAggregatesFilter<"Service"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type BillingWhereInput = {
    AND?: BillingWhereInput | BillingWhereInput[]
    OR?: BillingWhereInput[]
    NOT?: BillingWhereInput | BillingWhereInput[]
    id?: StringFilter<"Billing"> | string
    account_id?: StringFilter<"Billing"> | string
    client_id?: StringFilter<"Billing"> | string
    client_company_id?: StringNullableFilter<"Billing"> | string | null
    billing_date?: DateTimeFilter<"Billing"> | Date | string
    due_date?: DateTimeNullableFilter<"Billing"> | Date | string | null
    invoice_number?: StringFilter<"Billing"> | string
    invoice_prefix?: StringFilter<"Billing"> | string
    invoice_sequence?: IntFilter<"Billing"> | number
    billing_address?: StringFilter<"Billing"> | string
    subtotal_amount?: DecimalFilter<"Billing"> | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFilter<"Billing"> | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFilter<"Billing"> | Decimal | DecimalJsLike | number | string
    total_amount?: DecimalFilter<"Billing"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Billing"> | string | null
    status?: EnumBillingStatusFilter<"Billing"> | $Enums.BillingStatus
    cancellation_date?: DateTimeNullableFilter<"Billing"> | Date | string | null
    cancellation_reason?: StringNullableFilter<"Billing"> | string | null
    created_at?: DateTimeFilter<"Billing"> | Date | string
    updated_at?: DateTimeFilter<"Billing"> | Date | string
    created_by?: StringNullableFilter<"Billing"> | string | null
    updated_by?: StringNullableFilter<"Billing"> | string | null
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    clientCompany?: XOR<ClientCompanyNullableScalarRelationFilter, ClientCompanyWhereInput> | null
    items?: BillingItemListRelationFilter
  }

  export type BillingOrderByWithRelationInput = {
    id?: SortOrder
    account_id?: SortOrder
    client_id?: SortOrder
    client_company_id?: SortOrderInput | SortOrder
    billing_date?: SortOrder
    due_date?: SortOrderInput | SortOrder
    invoice_number?: SortOrder
    invoice_prefix?: SortOrder
    invoice_sequence?: SortOrder
    billing_address?: SortOrder
    subtotal_amount?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    total_amount?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    cancellation_date?: SortOrderInput | SortOrder
    cancellation_reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    account?: AccountOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    clientCompany?: ClientCompanyOrderByWithRelationInput
    items?: BillingItemOrderByRelationAggregateInput
    _relevance?: BillingOrderByRelevanceInput
  }

  export type BillingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    account_id_invoice_number?: BillingAccount_idInvoice_numberCompoundUniqueInput
    AND?: BillingWhereInput | BillingWhereInput[]
    OR?: BillingWhereInput[]
    NOT?: BillingWhereInput | BillingWhereInput[]
    account_id?: StringFilter<"Billing"> | string
    client_id?: StringFilter<"Billing"> | string
    client_company_id?: StringNullableFilter<"Billing"> | string | null
    billing_date?: DateTimeFilter<"Billing"> | Date | string
    due_date?: DateTimeNullableFilter<"Billing"> | Date | string | null
    invoice_number?: StringFilter<"Billing"> | string
    invoice_prefix?: StringFilter<"Billing"> | string
    invoice_sequence?: IntFilter<"Billing"> | number
    billing_address?: StringFilter<"Billing"> | string
    subtotal_amount?: DecimalFilter<"Billing"> | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFilter<"Billing"> | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFilter<"Billing"> | Decimal | DecimalJsLike | number | string
    total_amount?: DecimalFilter<"Billing"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Billing"> | string | null
    status?: EnumBillingStatusFilter<"Billing"> | $Enums.BillingStatus
    cancellation_date?: DateTimeNullableFilter<"Billing"> | Date | string | null
    cancellation_reason?: StringNullableFilter<"Billing"> | string | null
    created_at?: DateTimeFilter<"Billing"> | Date | string
    updated_at?: DateTimeFilter<"Billing"> | Date | string
    created_by?: StringNullableFilter<"Billing"> | string | null
    updated_by?: StringNullableFilter<"Billing"> | string | null
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    clientCompany?: XOR<ClientCompanyNullableScalarRelationFilter, ClientCompanyWhereInput> | null
    items?: BillingItemListRelationFilter
  }, "id" | "account_id_invoice_number">

  export type BillingOrderByWithAggregationInput = {
    id?: SortOrder
    account_id?: SortOrder
    client_id?: SortOrder
    client_company_id?: SortOrderInput | SortOrder
    billing_date?: SortOrder
    due_date?: SortOrderInput | SortOrder
    invoice_number?: SortOrder
    invoice_prefix?: SortOrder
    invoice_sequence?: SortOrder
    billing_address?: SortOrder
    subtotal_amount?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    total_amount?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    cancellation_date?: SortOrderInput | SortOrder
    cancellation_reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    _count?: BillingCountOrderByAggregateInput
    _avg?: BillingAvgOrderByAggregateInput
    _max?: BillingMaxOrderByAggregateInput
    _min?: BillingMinOrderByAggregateInput
    _sum?: BillingSumOrderByAggregateInput
  }

  export type BillingScalarWhereWithAggregatesInput = {
    AND?: BillingScalarWhereWithAggregatesInput | BillingScalarWhereWithAggregatesInput[]
    OR?: BillingScalarWhereWithAggregatesInput[]
    NOT?: BillingScalarWhereWithAggregatesInput | BillingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Billing"> | string
    account_id?: StringWithAggregatesFilter<"Billing"> | string
    client_id?: StringWithAggregatesFilter<"Billing"> | string
    client_company_id?: StringNullableWithAggregatesFilter<"Billing"> | string | null
    billing_date?: DateTimeWithAggregatesFilter<"Billing"> | Date | string
    due_date?: DateTimeNullableWithAggregatesFilter<"Billing"> | Date | string | null
    invoice_number?: StringWithAggregatesFilter<"Billing"> | string
    invoice_prefix?: StringWithAggregatesFilter<"Billing"> | string
    invoice_sequence?: IntWithAggregatesFilter<"Billing"> | number
    billing_address?: StringWithAggregatesFilter<"Billing"> | string
    subtotal_amount?: DecimalWithAggregatesFilter<"Billing"> | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalWithAggregatesFilter<"Billing"> | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalWithAggregatesFilter<"Billing"> | Decimal | DecimalJsLike | number | string
    total_amount?: DecimalWithAggregatesFilter<"Billing"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"Billing"> | string | null
    status?: EnumBillingStatusWithAggregatesFilter<"Billing"> | $Enums.BillingStatus
    cancellation_date?: DateTimeNullableWithAggregatesFilter<"Billing"> | Date | string | null
    cancellation_reason?: StringNullableWithAggregatesFilter<"Billing"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Billing"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Billing"> | Date | string
    created_by?: StringNullableWithAggregatesFilter<"Billing"> | string | null
    updated_by?: StringNullableWithAggregatesFilter<"Billing"> | string | null
  }

  export type BillingItemWhereInput = {
    AND?: BillingItemWhereInput | BillingItemWhereInput[]
    OR?: BillingItemWhereInput[]
    NOT?: BillingItemWhereInput | BillingItemWhereInput[]
    id?: StringFilter<"BillingItem"> | string
    billing_id?: StringFilter<"BillingItem"> | string
    service_id?: StringFilter<"BillingItem"> | string
    description?: StringNullableFilter<"BillingItem"> | string | null
    quantity?: DecimalFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    tax_percent?: DecimalFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    discount_percent?: DecimalFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    line_total?: DecimalFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"BillingItem"> | Date | string
    updated_at?: DateTimeFilter<"BillingItem"> | Date | string
    created_by?: StringNullableFilter<"BillingItem"> | string | null
    updated_by?: StringNullableFilter<"BillingItem"> | string | null
    billing?: XOR<BillingScalarRelationFilter, BillingWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type BillingItemOrderByWithRelationInput = {
    id?: SortOrder
    billing_id?: SortOrder
    service_id?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    tax_percent?: SortOrder
    discount_percent?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    line_total?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    billing?: BillingOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    _relevance?: BillingItemOrderByRelevanceInput
  }

  export type BillingItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillingItemWhereInput | BillingItemWhereInput[]
    OR?: BillingItemWhereInput[]
    NOT?: BillingItemWhereInput | BillingItemWhereInput[]
    billing_id?: StringFilter<"BillingItem"> | string
    service_id?: StringFilter<"BillingItem"> | string
    description?: StringNullableFilter<"BillingItem"> | string | null
    quantity?: DecimalFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    tax_percent?: DecimalFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    discount_percent?: DecimalFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    line_total?: DecimalFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"BillingItem"> | Date | string
    updated_at?: DateTimeFilter<"BillingItem"> | Date | string
    created_by?: StringNullableFilter<"BillingItem"> | string | null
    updated_by?: StringNullableFilter<"BillingItem"> | string | null
    billing?: XOR<BillingScalarRelationFilter, BillingWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "id">

  export type BillingItemOrderByWithAggregationInput = {
    id?: SortOrder
    billing_id?: SortOrder
    service_id?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    tax_percent?: SortOrder
    discount_percent?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    line_total?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    _count?: BillingItemCountOrderByAggregateInput
    _avg?: BillingItemAvgOrderByAggregateInput
    _max?: BillingItemMaxOrderByAggregateInput
    _min?: BillingItemMinOrderByAggregateInput
    _sum?: BillingItemSumOrderByAggregateInput
  }

  export type BillingItemScalarWhereWithAggregatesInput = {
    AND?: BillingItemScalarWhereWithAggregatesInput | BillingItemScalarWhereWithAggregatesInput[]
    OR?: BillingItemScalarWhereWithAggregatesInput[]
    NOT?: BillingItemScalarWhereWithAggregatesInput | BillingItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillingItem"> | string
    billing_id?: StringWithAggregatesFilter<"BillingItem"> | string
    service_id?: StringWithAggregatesFilter<"BillingItem"> | string
    description?: StringNullableWithAggregatesFilter<"BillingItem"> | string | null
    quantity?: DecimalWithAggregatesFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalWithAggregatesFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    tax_percent?: DecimalWithAggregatesFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    discount_percent?: DecimalWithAggregatesFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalWithAggregatesFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalWithAggregatesFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    line_total?: DecimalWithAggregatesFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeWithAggregatesFilter<"BillingItem"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"BillingItem"> | Date | string
    created_by?: StringNullableWithAggregatesFilter<"BillingItem"> | string | null
    updated_by?: StringNullableWithAggregatesFilter<"BillingItem"> | string | null
  }

  export type BankAccountWhereInput = {
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    id?: StringFilter<"BankAccount"> | string
    account_id?: StringFilter<"BankAccount"> | string
    bank_name?: StringFilter<"BankAccount"> | string
    account_number?: StringFilter<"BankAccount"> | string
    routing_number?: StringNullableFilter<"BankAccount"> | string | null
    account_type?: StringNullableFilter<"BankAccount"> | string | null
    currency?: StringNullableFilter<"BankAccount"> | string | null
    is_primary?: BoolFilter<"BankAccount"> | boolean
    description?: StringNullableFilter<"BankAccount"> | string | null
    created_at?: DateTimeFilter<"BankAccount"> | Date | string
    updated_at?: DateTimeFilter<"BankAccount"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type BankAccountOrderByWithRelationInput = {
    id?: SortOrder
    account_id?: SortOrder
    bank_name?: SortOrder
    account_number?: SortOrder
    routing_number?: SortOrderInput | SortOrder
    account_type?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    is_primary?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    account?: AccountOrderByWithRelationInput
    _relevance?: BankAccountOrderByRelevanceInput
  }

  export type BankAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    account_id?: StringFilter<"BankAccount"> | string
    bank_name?: StringFilter<"BankAccount"> | string
    account_number?: StringFilter<"BankAccount"> | string
    routing_number?: StringNullableFilter<"BankAccount"> | string | null
    account_type?: StringNullableFilter<"BankAccount"> | string | null
    currency?: StringNullableFilter<"BankAccount"> | string | null
    is_primary?: BoolFilter<"BankAccount"> | boolean
    description?: StringNullableFilter<"BankAccount"> | string | null
    created_at?: DateTimeFilter<"BankAccount"> | Date | string
    updated_at?: DateTimeFilter<"BankAccount"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "id">

  export type BankAccountOrderByWithAggregationInput = {
    id?: SortOrder
    account_id?: SortOrder
    bank_name?: SortOrder
    account_number?: SortOrder
    routing_number?: SortOrderInput | SortOrder
    account_type?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    is_primary?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: BankAccountCountOrderByAggregateInput
    _max?: BankAccountMaxOrderByAggregateInput
    _min?: BankAccountMinOrderByAggregateInput
  }

  export type BankAccountScalarWhereWithAggregatesInput = {
    AND?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    OR?: BankAccountScalarWhereWithAggregatesInput[]
    NOT?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BankAccount"> | string
    account_id?: StringWithAggregatesFilter<"BankAccount"> | string
    bank_name?: StringWithAggregatesFilter<"BankAccount"> | string
    account_number?: StringWithAggregatesFilter<"BankAccount"> | string
    routing_number?: StringNullableWithAggregatesFilter<"BankAccount"> | string | null
    account_type?: StringNullableWithAggregatesFilter<"BankAccount"> | string | null
    currency?: StringNullableWithAggregatesFilter<"BankAccount"> | string | null
    is_primary?: BoolWithAggregatesFilter<"BankAccount"> | boolean
    description?: StringNullableWithAggregatesFilter<"BankAccount"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"BankAccount"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"BankAccount"> | Date | string
  }

  export type PDFTemplateWhereInput = {
    AND?: PDFTemplateWhereInput | PDFTemplateWhereInput[]
    OR?: PDFTemplateWhereInput[]
    NOT?: PDFTemplateWhereInput | PDFTemplateWhereInput[]
    id?: StringFilter<"PDFTemplate"> | string
    account_id?: StringFilter<"PDFTemplate"> | string
    name?: StringFilter<"PDFTemplate"> | string
    description?: StringNullableFilter<"PDFTemplate"> | string | null
    is_default?: BoolFilter<"PDFTemplate"> | boolean
    primary_color?: StringFilter<"PDFTemplate"> | string
    secondary_color?: StringFilter<"PDFTemplate"> | string
    font_family?: StringFilter<"PDFTemplate"> | string
    show_logo?: BoolFilter<"PDFTemplate"> | boolean
    show_watermark?: BoolFilter<"PDFTemplate"> | boolean
    show_qr_code?: BoolFilter<"PDFTemplate"> | boolean
    created_at?: DateTimeFilter<"PDFTemplate"> | Date | string
    updated_at?: DateTimeFilter<"PDFTemplate"> | Date | string
    created_by?: StringNullableFilter<"PDFTemplate"> | string | null
    updated_by?: StringNullableFilter<"PDFTemplate"> | string | null
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type PDFTemplateOrderByWithRelationInput = {
    id?: SortOrder
    account_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    is_default?: SortOrder
    primary_color?: SortOrder
    secondary_color?: SortOrder
    font_family?: SortOrder
    show_logo?: SortOrder
    show_watermark?: SortOrder
    show_qr_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    account?: AccountOrderByWithRelationInput
    _relevance?: PDFTemplateOrderByRelevanceInput
  }

  export type PDFTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PDFTemplateWhereInput | PDFTemplateWhereInput[]
    OR?: PDFTemplateWhereInput[]
    NOT?: PDFTemplateWhereInput | PDFTemplateWhereInput[]
    account_id?: StringFilter<"PDFTemplate"> | string
    name?: StringFilter<"PDFTemplate"> | string
    description?: StringNullableFilter<"PDFTemplate"> | string | null
    is_default?: BoolFilter<"PDFTemplate"> | boolean
    primary_color?: StringFilter<"PDFTemplate"> | string
    secondary_color?: StringFilter<"PDFTemplate"> | string
    font_family?: StringFilter<"PDFTemplate"> | string
    show_logo?: BoolFilter<"PDFTemplate"> | boolean
    show_watermark?: BoolFilter<"PDFTemplate"> | boolean
    show_qr_code?: BoolFilter<"PDFTemplate"> | boolean
    created_at?: DateTimeFilter<"PDFTemplate"> | Date | string
    updated_at?: DateTimeFilter<"PDFTemplate"> | Date | string
    created_by?: StringNullableFilter<"PDFTemplate"> | string | null
    updated_by?: StringNullableFilter<"PDFTemplate"> | string | null
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "id">

  export type PDFTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    account_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    is_default?: SortOrder
    primary_color?: SortOrder
    secondary_color?: SortOrder
    font_family?: SortOrder
    show_logo?: SortOrder
    show_watermark?: SortOrder
    show_qr_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    _count?: PDFTemplateCountOrderByAggregateInput
    _max?: PDFTemplateMaxOrderByAggregateInput
    _min?: PDFTemplateMinOrderByAggregateInput
  }

  export type PDFTemplateScalarWhereWithAggregatesInput = {
    AND?: PDFTemplateScalarWhereWithAggregatesInput | PDFTemplateScalarWhereWithAggregatesInput[]
    OR?: PDFTemplateScalarWhereWithAggregatesInput[]
    NOT?: PDFTemplateScalarWhereWithAggregatesInput | PDFTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PDFTemplate"> | string
    account_id?: StringWithAggregatesFilter<"PDFTemplate"> | string
    name?: StringWithAggregatesFilter<"PDFTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"PDFTemplate"> | string | null
    is_default?: BoolWithAggregatesFilter<"PDFTemplate"> | boolean
    primary_color?: StringWithAggregatesFilter<"PDFTemplate"> | string
    secondary_color?: StringWithAggregatesFilter<"PDFTemplate"> | string
    font_family?: StringWithAggregatesFilter<"PDFTemplate"> | string
    show_logo?: BoolWithAggregatesFilter<"PDFTemplate"> | boolean
    show_watermark?: BoolWithAggregatesFilter<"PDFTemplate"> | boolean
    show_qr_code?: BoolWithAggregatesFilter<"PDFTemplate"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"PDFTemplate"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"PDFTemplate"> | Date | string
    created_by?: StringNullableWithAggregatesFilter<"PDFTemplate"> | string | null
    updated_by?: StringNullableWithAggregatesFilter<"PDFTemplate"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password_hash?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    reset_token?: StringNullableFilter<"User"> | string | null
    reset_token_expires?: DateTimeNullableFilter<"User"> | Date | string | null
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    accounts?: UserAccountListRelationFilter
    accountsAuth?: AccountAuthListRelationFilter
    sessions?: SessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    reset_token?: SortOrderInput | SortOrder
    reset_token_expires?: SortOrderInput | SortOrder
    profile?: ProfileOrderByWithRelationInput
    accounts?: UserAccountOrderByRelationAggregateInput
    accountsAuth?: AccountAuthOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password_hash?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    reset_token?: StringNullableFilter<"User"> | string | null
    reset_token_expires?: DateTimeNullableFilter<"User"> | Date | string | null
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    accounts?: UserAccountListRelationFilter
    accountsAuth?: AccountAuthListRelationFilter
    sessions?: SessionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    reset_token?: SortOrderInput | SortOrder
    reset_token_expires?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password_hash?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    reset_token?: StringNullableWithAggregatesFilter<"User"> | string | null
    reset_token_expires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type AccountCreateInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    general_info?: AccountGeneralInfoCreateNestedOneWithoutAccountInput
    contact_info?: AccountContactInfoCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountCreateNestedManyWithoutAccountInput
    billings?: BillingCreateNestedManyWithoutAccountInput
    clients?: ClientCreateNestedManyWithoutAccountInput
    services?: ServiceCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateCreateNestedManyWithoutAccountInput
    users?: UserAccountCreateNestedManyWithoutAccountInput
    parent_account?: AccountCreateNestedOneWithoutChild_accountsInput
    child_accounts?: AccountCreateNestedManyWithoutParent_accountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    parent_account_id?: string | null
    general_info?: AccountGeneralInfoUncheckedCreateNestedOneWithoutAccountInput
    contact_info?: AccountContactInfoUncheckedCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceUncheckedCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountUncheckedCreateNestedManyWithoutAccountInput
    billings?: BillingUncheckedCreateNestedManyWithoutAccountInput
    clients?: ClientUncheckedCreateNestedManyWithoutAccountInput
    services?: ServiceUncheckedCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureUncheckedCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateUncheckedCreateNestedManyWithoutAccountInput
    users?: UserAccountUncheckedCreateNestedManyWithoutAccountInput
    child_accounts?: AccountUncheckedCreateNestedManyWithoutParent_accountInput
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUpdateOneWithoutAccountNestedInput
    contact_info?: AccountContactInfoUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUpdateManyWithoutAccountNestedInput
    billings?: BillingUpdateManyWithoutAccountNestedInput
    clients?: ClientUpdateManyWithoutAccountNestedInput
    services?: ServiceUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUpdateManyWithoutAccountNestedInput
    users?: UserAccountUpdateManyWithoutAccountNestedInput
    parent_account?: AccountUpdateOneWithoutChild_accountsNestedInput
    child_accounts?: AccountUpdateManyWithoutParent_accountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    parent_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUncheckedUpdateOneWithoutAccountNestedInput
    contact_info?: AccountContactInfoUncheckedUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUncheckedUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUncheckedUpdateManyWithoutAccountNestedInput
    billings?: BillingUncheckedUpdateManyWithoutAccountNestedInput
    clients?: ClientUncheckedUpdateManyWithoutAccountNestedInput
    services?: ServiceUncheckedUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUncheckedUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUncheckedUpdateManyWithoutAccountNestedInput
    users?: UserAccountUncheckedUpdateManyWithoutAccountNestedInput
    child_accounts?: AccountUncheckedUpdateManyWithoutParent_accountNestedInput
  }

  export type AccountCreateManyInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    parent_account_id?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    parent_account_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountGeneralInfoCreateInput = {
    id?: string
    type: $Enums.AccountType
    status?: $Enums.AccountStatus
    dba_name?: string | null
    entity_type?: $Enums.EntityType | null
    ein?: string | null
    duns_number?: string | null
    incorporation_date?: Date | string | null
    incorporation_state?: string | null
    industry?: string | null
    currency?: string | null
    payment_terms?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    account: AccountCreateNestedOneWithoutGeneral_infoInput
  }

  export type AccountGeneralInfoUncheckedCreateInput = {
    id?: string
    account_id: string
    type: $Enums.AccountType
    status?: $Enums.AccountStatus
    dba_name?: string | null
    entity_type?: $Enums.EntityType | null
    ein?: string | null
    duns_number?: string | null
    incorporation_date?: Date | string | null
    incorporation_state?: string | null
    industry?: string | null
    currency?: string | null
    payment_terms?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountGeneralInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    dba_name?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    ein?: NullableStringFieldUpdateOperationsInput | string | null
    duns_number?: NullableStringFieldUpdateOperationsInput | string | null
    incorporation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incorporation_state?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutGeneral_infoNestedInput
  }

  export type AccountGeneralInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    dba_name?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    ein?: NullableStringFieldUpdateOperationsInput | string | null
    duns_number?: NullableStringFieldUpdateOperationsInput | string | null
    incorporation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incorporation_state?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountGeneralInfoCreateManyInput = {
    id?: string
    account_id: string
    type: $Enums.AccountType
    status?: $Enums.AccountStatus
    dba_name?: string | null
    entity_type?: $Enums.EntityType | null
    ein?: string | null
    duns_number?: string | null
    incorporation_date?: Date | string | null
    incorporation_state?: string | null
    industry?: string | null
    currency?: string | null
    payment_terms?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountGeneralInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    dba_name?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    ein?: NullableStringFieldUpdateOperationsInput | string | null
    duns_number?: NullableStringFieldUpdateOperationsInput | string | null
    incorporation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incorporation_state?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountGeneralInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    dba_name?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    ein?: NullableStringFieldUpdateOperationsInput | string | null
    duns_number?: NullableStringFieldUpdateOperationsInput | string | null
    incorporation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incorporation_state?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountContactInfoCreateInput = {
    id?: string
    address_street?: string | null
    address_suite?: string | null
    address_city?: string | null
    address_state?: string | null
    address_zip?: string | null
    address_country?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    website?: string | null
    mailing_address_street?: string | null
    mailing_address_suite?: string | null
    mailing_address_city?: string | null
    mailing_address_state?: string | null
    mailing_address_zip?: string | null
    mailing_address_country?: string | null
    contact_name?: string | null
    contact_title?: string | null
    contact_phone?: string | null
    contact_email?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    account: AccountCreateNestedOneWithoutContact_infoInput
  }

  export type AccountContactInfoUncheckedCreateInput = {
    id?: string
    account_id: string
    address_street?: string | null
    address_suite?: string | null
    address_city?: string | null
    address_state?: string | null
    address_zip?: string | null
    address_country?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    website?: string | null
    mailing_address_street?: string | null
    mailing_address_suite?: string | null
    mailing_address_city?: string | null
    mailing_address_state?: string | null
    mailing_address_zip?: string | null
    mailing_address_country?: string | null
    contact_name?: string | null
    contact_title?: string | null
    contact_phone?: string | null
    contact_email?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountContactInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_suite?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_state?: NullableStringFieldUpdateOperationsInput | string | null
    address_zip?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_street?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_suite?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_city?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_state?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_zip?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_country?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    contact_title?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutContact_infoNestedInput
  }

  export type AccountContactInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_suite?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_state?: NullableStringFieldUpdateOperationsInput | string | null
    address_zip?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_street?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_suite?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_city?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_state?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_zip?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_country?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    contact_title?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountContactInfoCreateManyInput = {
    id?: string
    account_id: string
    address_street?: string | null
    address_suite?: string | null
    address_city?: string | null
    address_state?: string | null
    address_zip?: string | null
    address_country?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    website?: string | null
    mailing_address_street?: string | null
    mailing_address_suite?: string | null
    mailing_address_city?: string | null
    mailing_address_state?: string | null
    mailing_address_zip?: string | null
    mailing_address_country?: string | null
    contact_name?: string | null
    contact_title?: string | null
    contact_phone?: string | null
    contact_email?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountContactInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_suite?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_state?: NullableStringFieldUpdateOperationsInput | string | null
    address_zip?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_street?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_suite?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_city?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_state?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_zip?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_country?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    contact_title?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountContactInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_suite?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_state?: NullableStringFieldUpdateOperationsInput | string | null
    address_zip?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_street?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_suite?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_city?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_state?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_zip?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_country?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    contact_title?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountComplianceCreateInput = {
    id?: string
    license_numbers?: string | null
    insurance_info?: string | null
    invoice_prefix?: string | null
    logo_url?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    account: AccountCreateNestedOneWithoutCompliance_infoInput
  }

  export type AccountComplianceUncheckedCreateInput = {
    id?: string
    account_id: string
    license_numbers?: string | null
    insurance_info?: string | null
    invoice_prefix?: string | null
    logo_url?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountComplianceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    license_numbers?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutCompliance_infoNestedInput
  }

  export type AccountComplianceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    license_numbers?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountComplianceCreateManyInput = {
    id?: string
    account_id: string
    license_numbers?: string | null
    insurance_info?: string | null
    invoice_prefix?: string | null
    logo_url?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountComplianceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    license_numbers?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountComplianceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    license_numbers?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccountCreateInput = {
    role: string
    created_at?: Date | string
    account: AccountCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type UserAccountUncheckedCreateInput = {
    user_id: string
    account_id: string
    role: string
    created_at?: Date | string
  }

  export type UserAccountUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type UserAccountUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccountCreateManyInput = {
    user_id: string
    account_id: string
    role: string
    created_at?: Date | string
  }

  export type UserAccountUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccountUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountAuthCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsAuthInput
  }

  export type AccountAuthUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountAuthUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsAuthNestedInput
  }

  export type AccountAuthUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountAuthCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountAuthUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountAuthUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    displayName?: string | null
    bio?: string | null
    jobTitle?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    language?: string | null
    timezone?: string | null
    website?: string | null
    linkedin?: string | null
    twitter?: string | null
    facebook?: string | null
    instagram?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
    emails?: ProfileEmailCreateNestedManyWithoutProfileInput
    phones?: ProfilePhoneCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    userId: string
    firstName?: string | null
    lastName?: string | null
    displayName?: string | null
    bio?: string | null
    jobTitle?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    language?: string | null
    timezone?: string | null
    website?: string | null
    linkedin?: string | null
    twitter?: string | null
    facebook?: string | null
    instagram?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    emails?: ProfileEmailUncheckedCreateNestedManyWithoutProfileInput
    phones?: ProfilePhoneUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    emails?: ProfileEmailUpdateManyWithoutProfileNestedInput
    phones?: ProfilePhoneUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    emails?: ProfileEmailUncheckedUpdateManyWithoutProfileNestedInput
    phones?: ProfilePhoneUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileCreateManyInput = {
    id?: string
    userId: string
    firstName?: string | null
    lastName?: string | null
    displayName?: string | null
    bio?: string | null
    jobTitle?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    language?: string | null
    timezone?: string | null
    website?: string | null
    linkedin?: string | null
    twitter?: string | null
    facebook?: string | null
    instagram?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileEmailCreateInput = {
    id?: string
    email: string
    type: string
    isPrimary?: boolean
    isVerified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    profile: ProfileCreateNestedOneWithoutEmailsInput
  }

  export type ProfileEmailUncheckedCreateInput = {
    id?: string
    profileId: string
    email: string
    type: string
    isPrimary?: boolean
    isVerified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProfileEmailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutEmailsNestedInput
  }

  export type ProfileEmailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileEmailCreateManyInput = {
    id?: string
    profileId: string
    email: string
    type: string
    isPrimary?: boolean
    isVerified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProfileEmailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileEmailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfilePhoneCreateInput = {
    id?: string
    phoneNumber: string
    type: string
    isPrimary?: boolean
    isVerified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    profile: ProfileCreateNestedOneWithoutPhonesInput
  }

  export type ProfilePhoneUncheckedCreateInput = {
    id?: string
    profileId: string
    phoneNumber: string
    type: string
    isPrimary?: boolean
    isVerified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProfilePhoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutPhonesNestedInput
  }

  export type ProfilePhoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfilePhoneCreateManyInput = {
    id?: string
    profileId: string
    phoneNumber: string
    type: string
    isPrimary?: boolean
    isVerified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProfilePhoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfilePhoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    id?: string
    client_type?: $Enums.ClientType
    name: string
    company_name?: string | null
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    account: AccountCreateNestedOneWithoutClientsInput
    billings?: BillingCreateNestedManyWithoutClientInput
    phones?: ClientPhoneCreateNestedManyWithoutClientInput
    emails?: ClientEmailCreateNestedManyWithoutClientInput
    addresses?: ClientAddressCreateNestedManyWithoutClientInput
    ClientCompany?: ClientCompanyCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    account_id: string
    client_type?: $Enums.ClientType
    name: string
    company_name?: string | null
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billings?: BillingUncheckedCreateNestedManyWithoutClientInput
    phones?: ClientPhoneUncheckedCreateNestedManyWithoutClientInput
    emails?: ClientEmailUncheckedCreateNestedManyWithoutClientInput
    addresses?: ClientAddressUncheckedCreateNestedManyWithoutClientInput
    ClientCompany?: ClientCompanyUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutClientsNestedInput
    billings?: BillingUpdateManyWithoutClientNestedInput
    phones?: ClientPhoneUpdateManyWithoutClientNestedInput
    emails?: ClientEmailUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUpdateManyWithoutClientNestedInput
    ClientCompany?: ClientCompanyUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billings?: BillingUncheckedUpdateManyWithoutClientNestedInput
    phones?: ClientPhoneUncheckedUpdateManyWithoutClientNestedInput
    emails?: ClientEmailUncheckedUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUncheckedUpdateManyWithoutClientNestedInput
    ClientCompany?: ClientCompanyUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    account_id: string
    client_type?: $Enums.ClientType
    name: string
    company_name?: string | null
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientPhoneCreateInput = {
    id?: string
    phone_number: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    client: ClientCreateNestedOneWithoutPhonesInput
  }

  export type ClientPhoneUncheckedCreateInput = {
    id?: string
    client_id: string
    phone_number: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientPhoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutPhonesNestedInput
  }

  export type ClientPhoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientPhoneCreateManyInput = {
    id?: string
    client_id: string
    phone_number: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientPhoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientPhoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientEmailCreateInput = {
    id?: string
    email: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    client: ClientCreateNestedOneWithoutEmailsInput
  }

  export type ClientEmailUncheckedCreateInput = {
    id?: string
    client_id: string
    email: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientEmailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutEmailsNestedInput
  }

  export type ClientEmailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientEmailCreateManyInput = {
    id?: string
    client_id: string
    email: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientEmailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientEmailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAddressCreateInput = {
    id?: string
    type: string
    street: string
    suite?: string | null
    city: string
    state: string
    zip_code: string
    country?: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    client: ClientCreateNestedOneWithoutAddressesInput
  }

  export type ClientAddressUncheckedCreateInput = {
    id?: string
    client_id: string
    type: string
    street: string
    suite?: string | null
    city: string
    state: string
    zip_code: string
    country?: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    suite?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutAddressesNestedInput
  }

  export type ClientAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    suite?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAddressCreateManyInput = {
    id?: string
    client_id: string
    type: string
    street: string
    suite?: string | null
    city: string
    state: string
    zip_code: string
    country?: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    suite?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    suite?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyCreateInput = {
    id?: string
    name: string
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    client: ClientCreateNestedOneWithoutClientCompanyInput
    phones?: ClientCompanyPhoneCreateNestedManyWithoutCompanyInput
    emails?: ClientCompanyEmailCreateNestedManyWithoutCompanyInput
    addresses?: ClientCompanyAddressCreateNestedManyWithoutCompanyInput
    billings?: BillingCreateNestedManyWithoutClientCompanyInput
  }

  export type ClientCompanyUncheckedCreateInput = {
    id?: string
    client_id: string
    name: string
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    phones?: ClientCompanyPhoneUncheckedCreateNestedManyWithoutCompanyInput
    emails?: ClientCompanyEmailUncheckedCreateNestedManyWithoutCompanyInput
    addresses?: ClientCompanyAddressUncheckedCreateNestedManyWithoutCompanyInput
    billings?: BillingUncheckedCreateNestedManyWithoutClientCompanyInput
  }

  export type ClientCompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutClientCompanyNestedInput
    phones?: ClientCompanyPhoneUpdateManyWithoutCompanyNestedInput
    emails?: ClientCompanyEmailUpdateManyWithoutCompanyNestedInput
    addresses?: ClientCompanyAddressUpdateManyWithoutCompanyNestedInput
    billings?: BillingUpdateManyWithoutClientCompanyNestedInput
  }

  export type ClientCompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: ClientCompanyPhoneUncheckedUpdateManyWithoutCompanyNestedInput
    emails?: ClientCompanyEmailUncheckedUpdateManyWithoutCompanyNestedInput
    addresses?: ClientCompanyAddressUncheckedUpdateManyWithoutCompanyNestedInput
    billings?: BillingUncheckedUpdateManyWithoutClientCompanyNestedInput
  }

  export type ClientCompanyCreateManyInput = {
    id?: string
    client_id: string
    name: string
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientCompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyPhoneCreateInput = {
    id?: string
    phone_number: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    company: ClientCompanyCreateNestedOneWithoutPhonesInput
  }

  export type ClientCompanyPhoneUncheckedCreateInput = {
    id?: string
    company_id: string
    phone_number: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientCompanyPhoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: ClientCompanyUpdateOneRequiredWithoutPhonesNestedInput
  }

  export type ClientCompanyPhoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyPhoneCreateManyInput = {
    id?: string
    company_id: string
    phone_number: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientCompanyPhoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyPhoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyEmailCreateInput = {
    id?: string
    email: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    company: ClientCompanyCreateNestedOneWithoutEmailsInput
  }

  export type ClientCompanyEmailUncheckedCreateInput = {
    id?: string
    company_id: string
    email: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientCompanyEmailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: ClientCompanyUpdateOneRequiredWithoutEmailsNestedInput
  }

  export type ClientCompanyEmailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyEmailCreateManyInput = {
    id?: string
    company_id: string
    email: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientCompanyEmailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyEmailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyAddressCreateInput = {
    id?: string
    type: string
    street: string
    suite?: string | null
    city: string
    state: string
    zip_code: string
    country: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    company: ClientCompanyCreateNestedOneWithoutAddressesInput
  }

  export type ClientCompanyAddressUncheckedCreateInput = {
    id?: string
    company_id: string
    type: string
    street: string
    suite?: string | null
    city: string
    state: string
    zip_code: string
    country: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientCompanyAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    suite?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: ClientCompanyUpdateOneRequiredWithoutAddressesNestedInput
  }

  export type ClientCompanyAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    suite?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyAddressCreateManyInput = {
    id?: string
    company_id: string
    type: string
    street: string
    suite?: string | null
    city: string
    state: string
    zip_code: string
    country: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientCompanyAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    suite?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    suite?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitOfMeasureCreateInput = {
    id?: string
    name: string
    symbol: string
    description?: string | null
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    services?: ServiceCreateNestedManyWithoutUnit_of_measureInput
    account: AccountCreateNestedOneWithoutUnits_of_measureInput
  }

  export type UnitOfMeasureUncheckedCreateInput = {
    id?: string
    account_id: string
    name: string
    symbol: string
    description?: string | null
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutUnit_of_measureInput
  }

  export type UnitOfMeasureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutUnit_of_measureNestedInput
    account?: AccountUpdateOneRequiredWithoutUnits_of_measureNestedInput
  }

  export type UnitOfMeasureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutUnit_of_measureNestedInput
  }

  export type UnitOfMeasureCreateManyInput = {
    id?: string
    account_id: string
    name: string
    symbol: string
    description?: string | null
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitOfMeasureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitOfMeasureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    is_discount?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billing_items?: BillingItemCreateNestedManyWithoutServiceInput
    account: AccountCreateNestedOneWithoutServicesInput
    unit_of_measure: UnitOfMeasureCreateNestedOneWithoutServicesInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    account_id: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    unit_of_measure_id: string
    is_discount?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billing_items?: BillingItemUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_discount?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_items?: BillingItemUpdateManyWithoutServiceNestedInput
    account?: AccountUpdateOneRequiredWithoutServicesNestedInput
    unit_of_measure?: UnitOfMeasureUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_of_measure_id?: StringFieldUpdateOperationsInput | string
    is_discount?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_items?: BillingItemUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    account_id: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    unit_of_measure_id: string
    is_discount?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_discount?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_of_measure_id?: StringFieldUpdateOperationsInput | string
    is_discount?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingCreateInput = {
    id?: string
    billing_date?: Date | string
    due_date?: Date | string | null
    invoice_number: string
    invoice_prefix?: string
    invoice_sequence: number
    billing_address: string
    subtotal_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string
    discount_amount?: Decimal | DecimalJsLike | number | string
    total_amount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    status?: $Enums.BillingStatus
    cancellation_date?: Date | string | null
    cancellation_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    account: AccountCreateNestedOneWithoutBillingsInput
    client: ClientCreateNestedOneWithoutBillingsInput
    clientCompany?: ClientCompanyCreateNestedOneWithoutBillingsInput
    items?: BillingItemCreateNestedManyWithoutBillingInput
  }

  export type BillingUncheckedCreateInput = {
    id?: string
    account_id: string
    client_id: string
    client_company_id?: string | null
    billing_date?: Date | string
    due_date?: Date | string | null
    invoice_number: string
    invoice_prefix?: string
    invoice_sequence: number
    billing_address: string
    subtotal_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string
    discount_amount?: Decimal | DecimalJsLike | number | string
    total_amount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    status?: $Enums.BillingStatus
    cancellation_date?: Date | string | null
    cancellation_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    items?: BillingItemUncheckedCreateNestedManyWithoutBillingInput
  }

  export type BillingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    billing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_prefix?: StringFieldUpdateOperationsInput | string
    invoice_sequence?: IntFieldUpdateOperationsInput | number
    billing_address?: StringFieldUpdateOperationsInput | string
    subtotal_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    cancellation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneRequiredWithoutBillingsNestedInput
    client?: ClientUpdateOneRequiredWithoutBillingsNestedInput
    clientCompany?: ClientCompanyUpdateOneWithoutBillingsNestedInput
    items?: BillingItemUpdateManyWithoutBillingNestedInput
  }

  export type BillingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    client_company_id?: NullableStringFieldUpdateOperationsInput | string | null
    billing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_prefix?: StringFieldUpdateOperationsInput | string
    invoice_sequence?: IntFieldUpdateOperationsInput | number
    billing_address?: StringFieldUpdateOperationsInput | string
    subtotal_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    cancellation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    items?: BillingItemUncheckedUpdateManyWithoutBillingNestedInput
  }

  export type BillingCreateManyInput = {
    id?: string
    account_id: string
    client_id: string
    client_company_id?: string | null
    billing_date?: Date | string
    due_date?: Date | string | null
    invoice_number: string
    invoice_prefix?: string
    invoice_sequence: number
    billing_address: string
    subtotal_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string
    discount_amount?: Decimal | DecimalJsLike | number | string
    total_amount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    status?: $Enums.BillingStatus
    cancellation_date?: Date | string | null
    cancellation_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type BillingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    billing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_prefix?: StringFieldUpdateOperationsInput | string
    invoice_sequence?: IntFieldUpdateOperationsInput | number
    billing_address?: StringFieldUpdateOperationsInput | string
    subtotal_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    cancellation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    client_company_id?: NullableStringFieldUpdateOperationsInput | string | null
    billing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_prefix?: StringFieldUpdateOperationsInput | string
    invoice_sequence?: IntFieldUpdateOperationsInput | number
    billing_address?: StringFieldUpdateOperationsInput | string
    subtotal_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    cancellation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillingItemCreateInput = {
    id?: string
    description?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    unit_price: Decimal | DecimalJsLike | number | string
    tax_percent?: Decimal | DecimalJsLike | number | string
    discount_percent?: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string
    discount_amount?: Decimal | DecimalJsLike | number | string
    line_total: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    billing: BillingCreateNestedOneWithoutItemsInput
    service: ServiceCreateNestedOneWithoutBilling_itemsInput
  }

  export type BillingItemUncheckedCreateInput = {
    id?: string
    billing_id: string
    service_id: string
    description?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    unit_price: Decimal | DecimalJsLike | number | string
    tax_percent?: Decimal | DecimalJsLike | number | string
    discount_percent?: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string
    discount_amount?: Decimal | DecimalJsLike | number | string
    line_total: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type BillingItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    line_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    billing?: BillingUpdateOneRequiredWithoutItemsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBilling_itemsNestedInput
  }

  export type BillingItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    billing_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    line_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillingItemCreateManyInput = {
    id?: string
    billing_id: string
    service_id: string
    description?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    unit_price: Decimal | DecimalJsLike | number | string
    tax_percent?: Decimal | DecimalJsLike | number | string
    discount_percent?: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string
    discount_amount?: Decimal | DecimalJsLike | number | string
    line_total: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type BillingItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    line_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillingItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    billing_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    line_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BankAccountCreateInput = {
    id?: string
    bank_name: string
    account_number: string
    routing_number?: string | null
    account_type?: string | null
    currency?: string | null
    is_primary?: boolean
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    account: AccountCreateNestedOneWithoutBank_accountsInput
  }

  export type BankAccountUncheckedCreateInput = {
    id?: string
    account_id: string
    bank_name: string
    account_number: string
    routing_number?: string | null
    account_type?: string | null
    currency?: string | null
    is_primary?: boolean
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BankAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    routing_number?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutBank_accountsNestedInput
  }

  export type BankAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    routing_number?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountCreateManyInput = {
    id?: string
    account_id: string
    bank_name: string
    account_number: string
    routing_number?: string | null
    account_type?: string | null
    currency?: string | null
    is_primary?: boolean
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BankAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    routing_number?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    routing_number?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PDFTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    is_default?: boolean
    primary_color?: string
    secondary_color?: string
    font_family?: string
    show_logo?: boolean
    show_watermark?: boolean
    show_qr_code?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    account: AccountCreateNestedOneWithoutPdf_templatesInput
  }

  export type PDFTemplateUncheckedCreateInput = {
    id?: string
    account_id: string
    name: string
    description?: string | null
    is_default?: boolean
    primary_color?: string
    secondary_color?: string
    font_family?: string
    show_logo?: boolean
    show_watermark?: boolean
    show_qr_code?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type PDFTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    primary_color?: StringFieldUpdateOperationsInput | string
    secondary_color?: StringFieldUpdateOperationsInput | string
    font_family?: StringFieldUpdateOperationsInput | string
    show_logo?: BoolFieldUpdateOperationsInput | boolean
    show_watermark?: BoolFieldUpdateOperationsInput | boolean
    show_qr_code?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneRequiredWithoutPdf_templatesNestedInput
  }

  export type PDFTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    primary_color?: StringFieldUpdateOperationsInput | string
    secondary_color?: StringFieldUpdateOperationsInput | string
    font_family?: StringFieldUpdateOperationsInput | string
    show_logo?: BoolFieldUpdateOperationsInput | boolean
    show_watermark?: BoolFieldUpdateOperationsInput | boolean
    show_qr_code?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PDFTemplateCreateManyInput = {
    id?: string
    account_id: string
    name: string
    description?: string | null
    is_default?: boolean
    primary_color?: string
    secondary_color?: string
    font_family?: string
    show_logo?: boolean
    show_watermark?: boolean
    show_qr_code?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type PDFTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    primary_color?: StringFieldUpdateOperationsInput | string
    secondary_color?: StringFieldUpdateOperationsInput | string
    font_family?: StringFieldUpdateOperationsInput | string
    show_logo?: BoolFieldUpdateOperationsInput | boolean
    show_watermark?: BoolFieldUpdateOperationsInput | boolean
    show_qr_code?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PDFTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    primary_color?: StringFieldUpdateOperationsInput | string
    secondary_color?: StringFieldUpdateOperationsInput | string
    font_family?: StringFieldUpdateOperationsInput | string
    show_logo?: BoolFieldUpdateOperationsInput | boolean
    show_watermark?: BoolFieldUpdateOperationsInput | boolean
    show_qr_code?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    id: string
    email: string
    password_hash: string
    name?: string | null
    created_at?: Date | string
    updated_at: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    accounts?: UserAccountCreateNestedManyWithoutUserInput
    accountsAuth?: AccountAuthCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    email: string
    password_hash: string
    name?: string | null
    created_at?: Date | string
    updated_at: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: UserAccountUncheckedCreateNestedManyWithoutUserInput
    accountsAuth?: AccountAuthUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    accounts?: UserAccountUpdateManyWithoutUserNestedInput
    accountsAuth?: AccountAuthUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: UserAccountUncheckedUpdateManyWithoutUserNestedInput
    accountsAuth?: AccountAuthUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id: string
    email: string
    password_hash: string
    name?: string | null
    created_at?: Date | string
    updated_at: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    reset_token?: string | null
    reset_token_expires?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type AccountGeneralInfoNullableScalarRelationFilter = {
    is?: AccountGeneralInfoWhereInput | null
    isNot?: AccountGeneralInfoWhereInput | null
  }

  export type AccountContactInfoNullableScalarRelationFilter = {
    is?: AccountContactInfoWhereInput | null
    isNot?: AccountContactInfoWhereInput | null
  }

  export type AccountComplianceNullableScalarRelationFilter = {
    is?: AccountComplianceWhereInput | null
    isNot?: AccountComplianceWhereInput | null
  }

  export type BankAccountListRelationFilter = {
    every?: BankAccountWhereInput
    some?: BankAccountWhereInput
    none?: BankAccountWhereInput
  }

  export type BillingListRelationFilter = {
    every?: BillingWhereInput
    some?: BillingWhereInput
    none?: BillingWhereInput
  }

  export type ClientListRelationFilter = {
    every?: ClientWhereInput
    some?: ClientWhereInput
    none?: ClientWhereInput
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type UnitOfMeasureListRelationFilter = {
    every?: UnitOfMeasureWhereInput
    some?: UnitOfMeasureWhereInput
    none?: UnitOfMeasureWhereInput
  }

  export type PDFTemplateListRelationFilter = {
    every?: PDFTemplateWhereInput
    some?: PDFTemplateWhereInput
    none?: PDFTemplateWhereInput
  }

  export type UserAccountListRelationFilter = {
    every?: UserAccountWhereInput
    some?: UserAccountWhereInput
    none?: UserAccountWhereInput
  }

  export type AccountNullableScalarRelationFilter = {
    is?: AccountWhereInput | null
    isNot?: AccountWhereInput | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BankAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitOfMeasureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PDFTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelevanceInput = {
    fields: AccountOrderByRelevanceFieldEnum | AccountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    legal_name?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    parent_account_id?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    legal_name?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    parent_account_id?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    legal_name?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    parent_account_id?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[]
    notIn?: $Enums.AccountType[]
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type EnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[]
    notIn?: $Enums.AccountStatus[]
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type EnumEntityTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EntityType[] | null
    notIn?: $Enums.EntityType[] | null
    not?: NestedEnumEntityTypeNullableFilter<$PrismaModel> | $Enums.EntityType | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountScalarRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type AccountGeneralInfoOrderByRelevanceInput = {
    fields: AccountGeneralInfoOrderByRelevanceFieldEnum | AccountGeneralInfoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AccountGeneralInfoCountOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    dba_name?: SortOrder
    entity_type?: SortOrder
    ein?: SortOrder
    duns_number?: SortOrder
    incorporation_date?: SortOrder
    incorporation_state?: SortOrder
    industry?: SortOrder
    currency?: SortOrder
    payment_terms?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AccountGeneralInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    dba_name?: SortOrder
    entity_type?: SortOrder
    ein?: SortOrder
    duns_number?: SortOrder
    incorporation_date?: SortOrder
    incorporation_state?: SortOrder
    industry?: SortOrder
    currency?: SortOrder
    payment_terms?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AccountGeneralInfoMinOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    dba_name?: SortOrder
    entity_type?: SortOrder
    ein?: SortOrder
    duns_number?: SortOrder
    incorporation_date?: SortOrder
    incorporation_state?: SortOrder
    industry?: SortOrder
    currency?: SortOrder
    payment_terms?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[]
    notIn?: $Enums.AccountType[]
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type EnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[]
    notIn?: $Enums.AccountStatus[]
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type EnumEntityTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EntityType[] | null
    notIn?: $Enums.EntityType[] | null
    not?: NestedEnumEntityTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EntityType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEntityTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumEntityTypeNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type AccountContactInfoOrderByRelevanceInput = {
    fields: AccountContactInfoOrderByRelevanceFieldEnum | AccountContactInfoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AccountContactInfoCountOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    address_street?: SortOrder
    address_suite?: SortOrder
    address_city?: SortOrder
    address_state?: SortOrder
    address_zip?: SortOrder
    address_country?: SortOrder
    phone?: SortOrder
    fax?: SortOrder
    email?: SortOrder
    website?: SortOrder
    mailing_address_street?: SortOrder
    mailing_address_suite?: SortOrder
    mailing_address_city?: SortOrder
    mailing_address_state?: SortOrder
    mailing_address_zip?: SortOrder
    mailing_address_country?: SortOrder
    contact_name?: SortOrder
    contact_title?: SortOrder
    contact_phone?: SortOrder
    contact_email?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AccountContactInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    address_street?: SortOrder
    address_suite?: SortOrder
    address_city?: SortOrder
    address_state?: SortOrder
    address_zip?: SortOrder
    address_country?: SortOrder
    phone?: SortOrder
    fax?: SortOrder
    email?: SortOrder
    website?: SortOrder
    mailing_address_street?: SortOrder
    mailing_address_suite?: SortOrder
    mailing_address_city?: SortOrder
    mailing_address_state?: SortOrder
    mailing_address_zip?: SortOrder
    mailing_address_country?: SortOrder
    contact_name?: SortOrder
    contact_title?: SortOrder
    contact_phone?: SortOrder
    contact_email?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AccountContactInfoMinOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    address_street?: SortOrder
    address_suite?: SortOrder
    address_city?: SortOrder
    address_state?: SortOrder
    address_zip?: SortOrder
    address_country?: SortOrder
    phone?: SortOrder
    fax?: SortOrder
    email?: SortOrder
    website?: SortOrder
    mailing_address_street?: SortOrder
    mailing_address_suite?: SortOrder
    mailing_address_city?: SortOrder
    mailing_address_state?: SortOrder
    mailing_address_zip?: SortOrder
    mailing_address_country?: SortOrder
    contact_name?: SortOrder
    contact_title?: SortOrder
    contact_phone?: SortOrder
    contact_email?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AccountComplianceOrderByRelevanceInput = {
    fields: AccountComplianceOrderByRelevanceFieldEnum | AccountComplianceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AccountComplianceCountOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    license_numbers?: SortOrder
    insurance_info?: SortOrder
    invoice_prefix?: SortOrder
    logo_url?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AccountComplianceMaxOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    license_numbers?: SortOrder
    insurance_info?: SortOrder
    invoice_prefix?: SortOrder
    logo_url?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AccountComplianceMinOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    license_numbers?: SortOrder
    insurance_info?: SortOrder
    invoice_prefix?: SortOrder
    logo_url?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserAccountOrderByRelevanceInput = {
    fields: UserAccountOrderByRelevanceFieldEnum | UserAccountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserAccountUser_idAccount_idCompoundUniqueInput = {
    user_id: string
    account_id: string
  }

  export type UserAccountCountOrderByAggregateInput = {
    user_id?: SortOrder
    account_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type UserAccountMaxOrderByAggregateInput = {
    user_id?: SortOrder
    account_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type UserAccountMinOrderByAggregateInput = {
    user_id?: SortOrder
    account_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AccountAuthOrderByRelevanceInput = {
    fields: AccountAuthOrderByRelevanceFieldEnum | AccountAuthOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AccountAuthProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountAuthCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAuthAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountAuthMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAuthMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAuthSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionOrderByRelevanceInput = {
    fields: SessionOrderByRelevanceFieldEnum | SessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenOrderByRelevanceInput = {
    fields: VerificationTokenOrderByRelevanceFieldEnum | VerificationTokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type ProfileEmailListRelationFilter = {
    every?: ProfileEmailWhereInput
    some?: ProfileEmailWhereInput
    none?: ProfileEmailWhereInput
  }

  export type ProfilePhoneListRelationFilter = {
    every?: ProfilePhoneWhereInput
    some?: ProfilePhoneWhereInput
    none?: ProfilePhoneWhereInput
  }

  export type ProfileEmailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfilePhoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileOrderByRelevanceInput = {
    fields: ProfileOrderByRelevanceFieldEnum | ProfileOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    jobTitle?: SortOrder
    company?: SortOrder
    address1?: SortOrder
    address2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    website?: SortOrder
    linkedin?: SortOrder
    twitter?: SortOrder
    facebook?: SortOrder
    instagram?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    jobTitle?: SortOrder
    company?: SortOrder
    address1?: SortOrder
    address2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    website?: SortOrder
    linkedin?: SortOrder
    twitter?: SortOrder
    facebook?: SortOrder
    instagram?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    jobTitle?: SortOrder
    company?: SortOrder
    address1?: SortOrder
    address2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    website?: SortOrder
    linkedin?: SortOrder
    twitter?: SortOrder
    facebook?: SortOrder
    instagram?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ProfileScalarRelationFilter = {
    is?: ProfileWhereInput
    isNot?: ProfileWhereInput
  }

  export type ProfileEmailOrderByRelevanceInput = {
    fields: ProfileEmailOrderByRelevanceFieldEnum | ProfileEmailOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProfileEmailProfileIdEmailCompoundUniqueInput = {
    profileId: string
    email: string
  }

  export type ProfileEmailCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    email?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    isVerified?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProfileEmailMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    email?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    isVerified?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProfileEmailMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    email?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    isVerified?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ProfilePhoneOrderByRelevanceInput = {
    fields: ProfilePhoneOrderByRelevanceFieldEnum | ProfilePhoneOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProfilePhoneProfileIdPhoneNumberCompoundUniqueInput = {
    profileId: string
    phoneNumber: string
  }

  export type ProfilePhoneCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    phoneNumber?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    isVerified?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProfilePhoneMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    phoneNumber?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    isVerified?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProfilePhoneMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    phoneNumber?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    isVerified?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumClientTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[]
    notIn?: $Enums.ClientType[]
    not?: NestedEnumClientTypeFilter<$PrismaModel> | $Enums.ClientType
  }

  export type ClientPhoneListRelationFilter = {
    every?: ClientPhoneWhereInput
    some?: ClientPhoneWhereInput
    none?: ClientPhoneWhereInput
  }

  export type ClientEmailListRelationFilter = {
    every?: ClientEmailWhereInput
    some?: ClientEmailWhereInput
    none?: ClientEmailWhereInput
  }

  export type ClientAddressListRelationFilter = {
    every?: ClientAddressWhereInput
    some?: ClientAddressWhereInput
    none?: ClientAddressWhereInput
  }

  export type ClientCompanyListRelationFilter = {
    every?: ClientCompanyWhereInput
    some?: ClientCompanyWhereInput
    none?: ClientCompanyWhereInput
  }

  export type ClientPhoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientEmailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCompanyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientOrderByRelevanceInput = {
    fields: ClientOrderByRelevanceFieldEnum | ClientOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClientAccount_idNameCompoundUniqueInput = {
    account_id: string
    name: string
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    client_type?: SortOrder
    name?: SortOrder
    company_name?: SortOrder
    tax_id?: SortOrder
    website?: SortOrder
    notes?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    client_type?: SortOrder
    name?: SortOrder
    company_name?: SortOrder
    tax_id?: SortOrder
    website?: SortOrder
    notes?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    client_type?: SortOrder
    name?: SortOrder
    company_name?: SortOrder
    tax_id?: SortOrder
    website?: SortOrder
    notes?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumClientTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[]
    notIn?: $Enums.ClientType[]
    not?: NestedEnumClientTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClientType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientTypeFilter<$PrismaModel>
    _max?: NestedEnumClientTypeFilter<$PrismaModel>
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type ClientPhoneOrderByRelevanceInput = {
    fields: ClientPhoneOrderByRelevanceFieldEnum | ClientPhoneOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClientPhoneClient_idPhone_numberCompoundUniqueInput = {
    client_id: string
    phone_number: string
  }

  export type ClientPhoneCountOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    phone_number?: SortOrder
    type?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientPhoneMaxOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    phone_number?: SortOrder
    type?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientPhoneMinOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    phone_number?: SortOrder
    type?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientEmailOrderByRelevanceInput = {
    fields: ClientEmailOrderByRelevanceFieldEnum | ClientEmailOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClientEmailClient_idEmailCompoundUniqueInput = {
    client_id: string
    email: string
  }

  export type ClientEmailCountOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    email?: SortOrder
    type?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientEmailMaxOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    email?: SortOrder
    type?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientEmailMinOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    email?: SortOrder
    type?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientAddressOrderByRelevanceInput = {
    fields: ClientAddressOrderByRelevanceFieldEnum | ClientAddressOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClientAddressCountOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    type?: SortOrder
    street?: SortOrder
    suite?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip_code?: SortOrder
    country?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    type?: SortOrder
    street?: SortOrder
    suite?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip_code?: SortOrder
    country?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientAddressMinOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    type?: SortOrder
    street?: SortOrder
    suite?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip_code?: SortOrder
    country?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientCompanyPhoneListRelationFilter = {
    every?: ClientCompanyPhoneWhereInput
    some?: ClientCompanyPhoneWhereInput
    none?: ClientCompanyPhoneWhereInput
  }

  export type ClientCompanyEmailListRelationFilter = {
    every?: ClientCompanyEmailWhereInput
    some?: ClientCompanyEmailWhereInput
    none?: ClientCompanyEmailWhereInput
  }

  export type ClientCompanyAddressListRelationFilter = {
    every?: ClientCompanyAddressWhereInput
    some?: ClientCompanyAddressWhereInput
    none?: ClientCompanyAddressWhereInput
  }

  export type ClientCompanyPhoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCompanyEmailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCompanyAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCompanyOrderByRelevanceInput = {
    fields: ClientCompanyOrderByRelevanceFieldEnum | ClientCompanyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClientCompanyClient_idNameCompoundUniqueInput = {
    client_id: string
    name: string
  }

  export type ClientCompanyCountOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    name?: SortOrder
    tax_id?: SortOrder
    website?: SortOrder
    notes?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientCompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    name?: SortOrder
    tax_id?: SortOrder
    website?: SortOrder
    notes?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientCompanyMinOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    name?: SortOrder
    tax_id?: SortOrder
    website?: SortOrder
    notes?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientCompanyScalarRelationFilter = {
    is?: ClientCompanyWhereInput
    isNot?: ClientCompanyWhereInput
  }

  export type ClientCompanyPhoneOrderByRelevanceInput = {
    fields: ClientCompanyPhoneOrderByRelevanceFieldEnum | ClientCompanyPhoneOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClientCompanyPhoneCountOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    phone_number?: SortOrder
    type?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientCompanyPhoneMaxOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    phone_number?: SortOrder
    type?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientCompanyPhoneMinOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    phone_number?: SortOrder
    type?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientCompanyEmailOrderByRelevanceInput = {
    fields: ClientCompanyEmailOrderByRelevanceFieldEnum | ClientCompanyEmailOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClientCompanyEmailCountOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    email?: SortOrder
    type?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientCompanyEmailMaxOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    email?: SortOrder
    type?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientCompanyEmailMinOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    email?: SortOrder
    type?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientCompanyAddressOrderByRelevanceInput = {
    fields: ClientCompanyAddressOrderByRelevanceFieldEnum | ClientCompanyAddressOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClientCompanyAddressCountOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    type?: SortOrder
    street?: SortOrder
    suite?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip_code?: SortOrder
    country?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientCompanyAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    type?: SortOrder
    street?: SortOrder
    suite?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip_code?: SortOrder
    country?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClientCompanyAddressMinOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    type?: SortOrder
    street?: SortOrder
    suite?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip_code?: SortOrder
    country?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UnitOfMeasureOrderByRelevanceInput = {
    fields: UnitOfMeasureOrderByRelevanceFieldEnum | UnitOfMeasureOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UnitOfMeasureAccount_idNameCompoundUniqueInput = {
    account_id: string
    name: string
  }

  export type UnitOfMeasureCountOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UnitOfMeasureMaxOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UnitOfMeasureMinOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BillingItemListRelationFilter = {
    every?: BillingItemWhereInput
    some?: BillingItemWhereInput
    none?: BillingItemWhereInput
  }

  export type UnitOfMeasureScalarRelationFilter = {
    is?: UnitOfMeasureWhereInput
    isNot?: UnitOfMeasureWhereInput
  }

  export type BillingItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceOrderByRelevanceInput = {
    fields: ServiceOrderByRelevanceFieldEnum | ServiceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    unit_of_measure_id?: SortOrder
    is_discount?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    unit_of_measure_id?: SortOrder
    is_discount?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    unit_of_measure_id?: SortOrder
    is_discount?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumBillingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingStatus | EnumBillingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillingStatus[]
    notIn?: $Enums.BillingStatus[]
    not?: NestedEnumBillingStatusFilter<$PrismaModel> | $Enums.BillingStatus
  }

  export type ClientCompanyNullableScalarRelationFilter = {
    is?: ClientCompanyWhereInput | null
    isNot?: ClientCompanyWhereInput | null
  }

  export type BillingOrderByRelevanceInput = {
    fields: BillingOrderByRelevanceFieldEnum | BillingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BillingAccount_idInvoice_numberCompoundUniqueInput = {
    account_id: string
    invoice_number: string
  }

  export type BillingCountOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    client_id?: SortOrder
    client_company_id?: SortOrder
    billing_date?: SortOrder
    due_date?: SortOrder
    invoice_number?: SortOrder
    invoice_prefix?: SortOrder
    invoice_sequence?: SortOrder
    billing_address?: SortOrder
    subtotal_amount?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    total_amount?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    cancellation_date?: SortOrder
    cancellation_reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type BillingAvgOrderByAggregateInput = {
    invoice_sequence?: SortOrder
    subtotal_amount?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    total_amount?: SortOrder
  }

  export type BillingMaxOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    client_id?: SortOrder
    client_company_id?: SortOrder
    billing_date?: SortOrder
    due_date?: SortOrder
    invoice_number?: SortOrder
    invoice_prefix?: SortOrder
    invoice_sequence?: SortOrder
    billing_address?: SortOrder
    subtotal_amount?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    total_amount?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    cancellation_date?: SortOrder
    cancellation_reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type BillingMinOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    client_id?: SortOrder
    client_company_id?: SortOrder
    billing_date?: SortOrder
    due_date?: SortOrder
    invoice_number?: SortOrder
    invoice_prefix?: SortOrder
    invoice_sequence?: SortOrder
    billing_address?: SortOrder
    subtotal_amount?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    total_amount?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    cancellation_date?: SortOrder
    cancellation_reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type BillingSumOrderByAggregateInput = {
    invoice_sequence?: SortOrder
    subtotal_amount?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    total_amount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumBillingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingStatus | EnumBillingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillingStatus[]
    notIn?: $Enums.BillingStatus[]
    not?: NestedEnumBillingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BillingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillingStatusFilter<$PrismaModel>
    _max?: NestedEnumBillingStatusFilter<$PrismaModel>
  }

  export type BillingScalarRelationFilter = {
    is?: BillingWhereInput
    isNot?: BillingWhereInput
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type BillingItemOrderByRelevanceInput = {
    fields: BillingItemOrderByRelevanceFieldEnum | BillingItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BillingItemCountOrderByAggregateInput = {
    id?: SortOrder
    billing_id?: SortOrder
    service_id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    tax_percent?: SortOrder
    discount_percent?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    line_total?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type BillingItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unit_price?: SortOrder
    tax_percent?: SortOrder
    discount_percent?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    line_total?: SortOrder
  }

  export type BillingItemMaxOrderByAggregateInput = {
    id?: SortOrder
    billing_id?: SortOrder
    service_id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    tax_percent?: SortOrder
    discount_percent?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    line_total?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type BillingItemMinOrderByAggregateInput = {
    id?: SortOrder
    billing_id?: SortOrder
    service_id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    tax_percent?: SortOrder
    discount_percent?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    line_total?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type BillingItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unit_price?: SortOrder
    tax_percent?: SortOrder
    discount_percent?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    line_total?: SortOrder
  }

  export type BankAccountOrderByRelevanceInput = {
    fields: BankAccountOrderByRelevanceFieldEnum | BankAccountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BankAccountCountOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    bank_name?: SortOrder
    account_number?: SortOrder
    routing_number?: SortOrder
    account_type?: SortOrder
    currency?: SortOrder
    is_primary?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BankAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    bank_name?: SortOrder
    account_number?: SortOrder
    routing_number?: SortOrder
    account_type?: SortOrder
    currency?: SortOrder
    is_primary?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BankAccountMinOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    bank_name?: SortOrder
    account_number?: SortOrder
    routing_number?: SortOrder
    account_type?: SortOrder
    currency?: SortOrder
    is_primary?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PDFTemplateOrderByRelevanceInput = {
    fields: PDFTemplateOrderByRelevanceFieldEnum | PDFTemplateOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PDFTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    is_default?: SortOrder
    primary_color?: SortOrder
    secondary_color?: SortOrder
    font_family?: SortOrder
    show_logo?: SortOrder
    show_watermark?: SortOrder
    show_qr_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type PDFTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    is_default?: SortOrder
    primary_color?: SortOrder
    secondary_color?: SortOrder
    font_family?: SortOrder
    show_logo?: SortOrder
    show_watermark?: SortOrder
    show_qr_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type PDFTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    is_default?: SortOrder
    primary_color?: SortOrder
    secondary_color?: SortOrder
    font_family?: SortOrder
    show_logo?: SortOrder
    show_watermark?: SortOrder
    show_qr_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type ProfileNullableScalarRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type AccountAuthListRelationFilter = {
    every?: AccountAuthWhereInput
    some?: AccountAuthWhereInput
    none?: AccountAuthWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountAuthOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    reset_token?: SortOrder
    reset_token_expires?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    reset_token?: SortOrder
    reset_token_expires?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    reset_token?: SortOrder
    reset_token_expires?: SortOrder
  }

  export type AccountGeneralInfoCreateNestedOneWithoutAccountInput = {
    create?: XOR<AccountGeneralInfoCreateWithoutAccountInput, AccountGeneralInfoUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AccountGeneralInfoCreateOrConnectWithoutAccountInput
    connect?: AccountGeneralInfoWhereUniqueInput
  }

  export type AccountContactInfoCreateNestedOneWithoutAccountInput = {
    create?: XOR<AccountContactInfoCreateWithoutAccountInput, AccountContactInfoUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AccountContactInfoCreateOrConnectWithoutAccountInput
    connect?: AccountContactInfoWhereUniqueInput
  }

  export type AccountComplianceCreateNestedOneWithoutAccountInput = {
    create?: XOR<AccountComplianceCreateWithoutAccountInput, AccountComplianceUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AccountComplianceCreateOrConnectWithoutAccountInput
    connect?: AccountComplianceWhereUniqueInput
  }

  export type BankAccountCreateNestedManyWithoutAccountInput = {
    create?: XOR<BankAccountCreateWithoutAccountInput, BankAccountUncheckedCreateWithoutAccountInput> | BankAccountCreateWithoutAccountInput[] | BankAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BankAccountCreateOrConnectWithoutAccountInput | BankAccountCreateOrConnectWithoutAccountInput[]
    createMany?: BankAccountCreateManyAccountInputEnvelope
    connect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
  }

  export type BillingCreateNestedManyWithoutAccountInput = {
    create?: XOR<BillingCreateWithoutAccountInput, BillingUncheckedCreateWithoutAccountInput> | BillingCreateWithoutAccountInput[] | BillingUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BillingCreateOrConnectWithoutAccountInput | BillingCreateOrConnectWithoutAccountInput[]
    createMany?: BillingCreateManyAccountInputEnvelope
    connect?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
  }

  export type ClientCreateNestedManyWithoutAccountInput = {
    create?: XOR<ClientCreateWithoutAccountInput, ClientUncheckedCreateWithoutAccountInput> | ClientCreateWithoutAccountInput[] | ClientUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutAccountInput | ClientCreateOrConnectWithoutAccountInput[]
    createMany?: ClientCreateManyAccountInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type ServiceCreateNestedManyWithoutAccountInput = {
    create?: XOR<ServiceCreateWithoutAccountInput, ServiceUncheckedCreateWithoutAccountInput> | ServiceCreateWithoutAccountInput[] | ServiceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutAccountInput | ServiceCreateOrConnectWithoutAccountInput[]
    createMany?: ServiceCreateManyAccountInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type UnitOfMeasureCreateNestedManyWithoutAccountInput = {
    create?: XOR<UnitOfMeasureCreateWithoutAccountInput, UnitOfMeasureUncheckedCreateWithoutAccountInput> | UnitOfMeasureCreateWithoutAccountInput[] | UnitOfMeasureUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutAccountInput | UnitOfMeasureCreateOrConnectWithoutAccountInput[]
    createMany?: UnitOfMeasureCreateManyAccountInputEnvelope
    connect?: UnitOfMeasureWhereUniqueInput | UnitOfMeasureWhereUniqueInput[]
  }

  export type PDFTemplateCreateNestedManyWithoutAccountInput = {
    create?: XOR<PDFTemplateCreateWithoutAccountInput, PDFTemplateUncheckedCreateWithoutAccountInput> | PDFTemplateCreateWithoutAccountInput[] | PDFTemplateUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PDFTemplateCreateOrConnectWithoutAccountInput | PDFTemplateCreateOrConnectWithoutAccountInput[]
    createMany?: PDFTemplateCreateManyAccountInputEnvelope
    connect?: PDFTemplateWhereUniqueInput | PDFTemplateWhereUniqueInput[]
  }

  export type UserAccountCreateNestedManyWithoutAccountInput = {
    create?: XOR<UserAccountCreateWithoutAccountInput, UserAccountUncheckedCreateWithoutAccountInput> | UserAccountCreateWithoutAccountInput[] | UserAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: UserAccountCreateOrConnectWithoutAccountInput | UserAccountCreateOrConnectWithoutAccountInput[]
    createMany?: UserAccountCreateManyAccountInputEnvelope
    connect?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
  }

  export type AccountCreateNestedOneWithoutChild_accountsInput = {
    create?: XOR<AccountCreateWithoutChild_accountsInput, AccountUncheckedCreateWithoutChild_accountsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutChild_accountsInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountCreateNestedManyWithoutParent_accountInput = {
    create?: XOR<AccountCreateWithoutParent_accountInput, AccountUncheckedCreateWithoutParent_accountInput> | AccountCreateWithoutParent_accountInput[] | AccountUncheckedCreateWithoutParent_accountInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParent_accountInput | AccountCreateOrConnectWithoutParent_accountInput[]
    createMany?: AccountCreateManyParent_accountInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AccountGeneralInfoUncheckedCreateNestedOneWithoutAccountInput = {
    create?: XOR<AccountGeneralInfoCreateWithoutAccountInput, AccountGeneralInfoUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AccountGeneralInfoCreateOrConnectWithoutAccountInput
    connect?: AccountGeneralInfoWhereUniqueInput
  }

  export type AccountContactInfoUncheckedCreateNestedOneWithoutAccountInput = {
    create?: XOR<AccountContactInfoCreateWithoutAccountInput, AccountContactInfoUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AccountContactInfoCreateOrConnectWithoutAccountInput
    connect?: AccountContactInfoWhereUniqueInput
  }

  export type AccountComplianceUncheckedCreateNestedOneWithoutAccountInput = {
    create?: XOR<AccountComplianceCreateWithoutAccountInput, AccountComplianceUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AccountComplianceCreateOrConnectWithoutAccountInput
    connect?: AccountComplianceWhereUniqueInput
  }

  export type BankAccountUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<BankAccountCreateWithoutAccountInput, BankAccountUncheckedCreateWithoutAccountInput> | BankAccountCreateWithoutAccountInput[] | BankAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BankAccountCreateOrConnectWithoutAccountInput | BankAccountCreateOrConnectWithoutAccountInput[]
    createMany?: BankAccountCreateManyAccountInputEnvelope
    connect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
  }

  export type BillingUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<BillingCreateWithoutAccountInput, BillingUncheckedCreateWithoutAccountInput> | BillingCreateWithoutAccountInput[] | BillingUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BillingCreateOrConnectWithoutAccountInput | BillingCreateOrConnectWithoutAccountInput[]
    createMany?: BillingCreateManyAccountInputEnvelope
    connect?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<ClientCreateWithoutAccountInput, ClientUncheckedCreateWithoutAccountInput> | ClientCreateWithoutAccountInput[] | ClientUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutAccountInput | ClientCreateOrConnectWithoutAccountInput[]
    createMany?: ClientCreateManyAccountInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<ServiceCreateWithoutAccountInput, ServiceUncheckedCreateWithoutAccountInput> | ServiceCreateWithoutAccountInput[] | ServiceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutAccountInput | ServiceCreateOrConnectWithoutAccountInput[]
    createMany?: ServiceCreateManyAccountInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type UnitOfMeasureUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<UnitOfMeasureCreateWithoutAccountInput, UnitOfMeasureUncheckedCreateWithoutAccountInput> | UnitOfMeasureCreateWithoutAccountInput[] | UnitOfMeasureUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutAccountInput | UnitOfMeasureCreateOrConnectWithoutAccountInput[]
    createMany?: UnitOfMeasureCreateManyAccountInputEnvelope
    connect?: UnitOfMeasureWhereUniqueInput | UnitOfMeasureWhereUniqueInput[]
  }

  export type PDFTemplateUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<PDFTemplateCreateWithoutAccountInput, PDFTemplateUncheckedCreateWithoutAccountInput> | PDFTemplateCreateWithoutAccountInput[] | PDFTemplateUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PDFTemplateCreateOrConnectWithoutAccountInput | PDFTemplateCreateOrConnectWithoutAccountInput[]
    createMany?: PDFTemplateCreateManyAccountInputEnvelope
    connect?: PDFTemplateWhereUniqueInput | PDFTemplateWhereUniqueInput[]
  }

  export type UserAccountUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<UserAccountCreateWithoutAccountInput, UserAccountUncheckedCreateWithoutAccountInput> | UserAccountCreateWithoutAccountInput[] | UserAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: UserAccountCreateOrConnectWithoutAccountInput | UserAccountCreateOrConnectWithoutAccountInput[]
    createMany?: UserAccountCreateManyAccountInputEnvelope
    connect?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutParent_accountInput = {
    create?: XOR<AccountCreateWithoutParent_accountInput, AccountUncheckedCreateWithoutParent_accountInput> | AccountCreateWithoutParent_accountInput[] | AccountUncheckedCreateWithoutParent_accountInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParent_accountInput | AccountCreateOrConnectWithoutParent_accountInput[]
    createMany?: AccountCreateManyParent_accountInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type AccountGeneralInfoUpdateOneWithoutAccountNestedInput = {
    create?: XOR<AccountGeneralInfoCreateWithoutAccountInput, AccountGeneralInfoUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AccountGeneralInfoCreateOrConnectWithoutAccountInput
    upsert?: AccountGeneralInfoUpsertWithoutAccountInput
    disconnect?: AccountGeneralInfoWhereInput | boolean
    delete?: AccountGeneralInfoWhereInput | boolean
    connect?: AccountGeneralInfoWhereUniqueInput
    update?: XOR<XOR<AccountGeneralInfoUpdateToOneWithWhereWithoutAccountInput, AccountGeneralInfoUpdateWithoutAccountInput>, AccountGeneralInfoUncheckedUpdateWithoutAccountInput>
  }

  export type AccountContactInfoUpdateOneWithoutAccountNestedInput = {
    create?: XOR<AccountContactInfoCreateWithoutAccountInput, AccountContactInfoUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AccountContactInfoCreateOrConnectWithoutAccountInput
    upsert?: AccountContactInfoUpsertWithoutAccountInput
    disconnect?: AccountContactInfoWhereInput | boolean
    delete?: AccountContactInfoWhereInput | boolean
    connect?: AccountContactInfoWhereUniqueInput
    update?: XOR<XOR<AccountContactInfoUpdateToOneWithWhereWithoutAccountInput, AccountContactInfoUpdateWithoutAccountInput>, AccountContactInfoUncheckedUpdateWithoutAccountInput>
  }

  export type AccountComplianceUpdateOneWithoutAccountNestedInput = {
    create?: XOR<AccountComplianceCreateWithoutAccountInput, AccountComplianceUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AccountComplianceCreateOrConnectWithoutAccountInput
    upsert?: AccountComplianceUpsertWithoutAccountInput
    disconnect?: AccountComplianceWhereInput | boolean
    delete?: AccountComplianceWhereInput | boolean
    connect?: AccountComplianceWhereUniqueInput
    update?: XOR<XOR<AccountComplianceUpdateToOneWithWhereWithoutAccountInput, AccountComplianceUpdateWithoutAccountInput>, AccountComplianceUncheckedUpdateWithoutAccountInput>
  }

  export type BankAccountUpdateManyWithoutAccountNestedInput = {
    create?: XOR<BankAccountCreateWithoutAccountInput, BankAccountUncheckedCreateWithoutAccountInput> | BankAccountCreateWithoutAccountInput[] | BankAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BankAccountCreateOrConnectWithoutAccountInput | BankAccountCreateOrConnectWithoutAccountInput[]
    upsert?: BankAccountUpsertWithWhereUniqueWithoutAccountInput | BankAccountUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: BankAccountCreateManyAccountInputEnvelope
    set?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    disconnect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    delete?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    connect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    update?: BankAccountUpdateWithWhereUniqueWithoutAccountInput | BankAccountUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: BankAccountUpdateManyWithWhereWithoutAccountInput | BankAccountUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: BankAccountScalarWhereInput | BankAccountScalarWhereInput[]
  }

  export type BillingUpdateManyWithoutAccountNestedInput = {
    create?: XOR<BillingCreateWithoutAccountInput, BillingUncheckedCreateWithoutAccountInput> | BillingCreateWithoutAccountInput[] | BillingUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BillingCreateOrConnectWithoutAccountInput | BillingCreateOrConnectWithoutAccountInput[]
    upsert?: BillingUpsertWithWhereUniqueWithoutAccountInput | BillingUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: BillingCreateManyAccountInputEnvelope
    set?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    disconnect?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    delete?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    connect?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    update?: BillingUpdateWithWhereUniqueWithoutAccountInput | BillingUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: BillingUpdateManyWithWhereWithoutAccountInput | BillingUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: BillingScalarWhereInput | BillingScalarWhereInput[]
  }

  export type ClientUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ClientCreateWithoutAccountInput, ClientUncheckedCreateWithoutAccountInput> | ClientCreateWithoutAccountInput[] | ClientUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutAccountInput | ClientCreateOrConnectWithoutAccountInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutAccountInput | ClientUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ClientCreateManyAccountInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutAccountInput | ClientUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutAccountInput | ClientUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type ServiceUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ServiceCreateWithoutAccountInput, ServiceUncheckedCreateWithoutAccountInput> | ServiceCreateWithoutAccountInput[] | ServiceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutAccountInput | ServiceCreateOrConnectWithoutAccountInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutAccountInput | ServiceUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ServiceCreateManyAccountInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutAccountInput | ServiceUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutAccountInput | ServiceUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type UnitOfMeasureUpdateManyWithoutAccountNestedInput = {
    create?: XOR<UnitOfMeasureCreateWithoutAccountInput, UnitOfMeasureUncheckedCreateWithoutAccountInput> | UnitOfMeasureCreateWithoutAccountInput[] | UnitOfMeasureUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutAccountInput | UnitOfMeasureCreateOrConnectWithoutAccountInput[]
    upsert?: UnitOfMeasureUpsertWithWhereUniqueWithoutAccountInput | UnitOfMeasureUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: UnitOfMeasureCreateManyAccountInputEnvelope
    set?: UnitOfMeasureWhereUniqueInput | UnitOfMeasureWhereUniqueInput[]
    disconnect?: UnitOfMeasureWhereUniqueInput | UnitOfMeasureWhereUniqueInput[]
    delete?: UnitOfMeasureWhereUniqueInput | UnitOfMeasureWhereUniqueInput[]
    connect?: UnitOfMeasureWhereUniqueInput | UnitOfMeasureWhereUniqueInput[]
    update?: UnitOfMeasureUpdateWithWhereUniqueWithoutAccountInput | UnitOfMeasureUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: UnitOfMeasureUpdateManyWithWhereWithoutAccountInput | UnitOfMeasureUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: UnitOfMeasureScalarWhereInput | UnitOfMeasureScalarWhereInput[]
  }

  export type PDFTemplateUpdateManyWithoutAccountNestedInput = {
    create?: XOR<PDFTemplateCreateWithoutAccountInput, PDFTemplateUncheckedCreateWithoutAccountInput> | PDFTemplateCreateWithoutAccountInput[] | PDFTemplateUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PDFTemplateCreateOrConnectWithoutAccountInput | PDFTemplateCreateOrConnectWithoutAccountInput[]
    upsert?: PDFTemplateUpsertWithWhereUniqueWithoutAccountInput | PDFTemplateUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: PDFTemplateCreateManyAccountInputEnvelope
    set?: PDFTemplateWhereUniqueInput | PDFTemplateWhereUniqueInput[]
    disconnect?: PDFTemplateWhereUniqueInput | PDFTemplateWhereUniqueInput[]
    delete?: PDFTemplateWhereUniqueInput | PDFTemplateWhereUniqueInput[]
    connect?: PDFTemplateWhereUniqueInput | PDFTemplateWhereUniqueInput[]
    update?: PDFTemplateUpdateWithWhereUniqueWithoutAccountInput | PDFTemplateUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: PDFTemplateUpdateManyWithWhereWithoutAccountInput | PDFTemplateUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: PDFTemplateScalarWhereInput | PDFTemplateScalarWhereInput[]
  }

  export type UserAccountUpdateManyWithoutAccountNestedInput = {
    create?: XOR<UserAccountCreateWithoutAccountInput, UserAccountUncheckedCreateWithoutAccountInput> | UserAccountCreateWithoutAccountInput[] | UserAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: UserAccountCreateOrConnectWithoutAccountInput | UserAccountCreateOrConnectWithoutAccountInput[]
    upsert?: UserAccountUpsertWithWhereUniqueWithoutAccountInput | UserAccountUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: UserAccountCreateManyAccountInputEnvelope
    set?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    disconnect?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    delete?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    connect?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    update?: UserAccountUpdateWithWhereUniqueWithoutAccountInput | UserAccountUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: UserAccountUpdateManyWithWhereWithoutAccountInput | UserAccountUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: UserAccountScalarWhereInput | UserAccountScalarWhereInput[]
  }

  export type AccountUpdateOneWithoutChild_accountsNestedInput = {
    create?: XOR<AccountCreateWithoutChild_accountsInput, AccountUncheckedCreateWithoutChild_accountsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutChild_accountsInput
    upsert?: AccountUpsertWithoutChild_accountsInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutChild_accountsInput, AccountUpdateWithoutChild_accountsInput>, AccountUncheckedUpdateWithoutChild_accountsInput>
  }

  export type AccountUpdateManyWithoutParent_accountNestedInput = {
    create?: XOR<AccountCreateWithoutParent_accountInput, AccountUncheckedCreateWithoutParent_accountInput> | AccountCreateWithoutParent_accountInput[] | AccountUncheckedCreateWithoutParent_accountInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParent_accountInput | AccountCreateOrConnectWithoutParent_accountInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutParent_accountInput | AccountUpsertWithWhereUniqueWithoutParent_accountInput[]
    createMany?: AccountCreateManyParent_accountInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutParent_accountInput | AccountUpdateWithWhereUniqueWithoutParent_accountInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutParent_accountInput | AccountUpdateManyWithWhereWithoutParent_accountInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AccountGeneralInfoUncheckedUpdateOneWithoutAccountNestedInput = {
    create?: XOR<AccountGeneralInfoCreateWithoutAccountInput, AccountGeneralInfoUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AccountGeneralInfoCreateOrConnectWithoutAccountInput
    upsert?: AccountGeneralInfoUpsertWithoutAccountInput
    disconnect?: AccountGeneralInfoWhereInput | boolean
    delete?: AccountGeneralInfoWhereInput | boolean
    connect?: AccountGeneralInfoWhereUniqueInput
    update?: XOR<XOR<AccountGeneralInfoUpdateToOneWithWhereWithoutAccountInput, AccountGeneralInfoUpdateWithoutAccountInput>, AccountGeneralInfoUncheckedUpdateWithoutAccountInput>
  }

  export type AccountContactInfoUncheckedUpdateOneWithoutAccountNestedInput = {
    create?: XOR<AccountContactInfoCreateWithoutAccountInput, AccountContactInfoUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AccountContactInfoCreateOrConnectWithoutAccountInput
    upsert?: AccountContactInfoUpsertWithoutAccountInput
    disconnect?: AccountContactInfoWhereInput | boolean
    delete?: AccountContactInfoWhereInput | boolean
    connect?: AccountContactInfoWhereUniqueInput
    update?: XOR<XOR<AccountContactInfoUpdateToOneWithWhereWithoutAccountInput, AccountContactInfoUpdateWithoutAccountInput>, AccountContactInfoUncheckedUpdateWithoutAccountInput>
  }

  export type AccountComplianceUncheckedUpdateOneWithoutAccountNestedInput = {
    create?: XOR<AccountComplianceCreateWithoutAccountInput, AccountComplianceUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AccountComplianceCreateOrConnectWithoutAccountInput
    upsert?: AccountComplianceUpsertWithoutAccountInput
    disconnect?: AccountComplianceWhereInput | boolean
    delete?: AccountComplianceWhereInput | boolean
    connect?: AccountComplianceWhereUniqueInput
    update?: XOR<XOR<AccountComplianceUpdateToOneWithWhereWithoutAccountInput, AccountComplianceUpdateWithoutAccountInput>, AccountComplianceUncheckedUpdateWithoutAccountInput>
  }

  export type BankAccountUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<BankAccountCreateWithoutAccountInput, BankAccountUncheckedCreateWithoutAccountInput> | BankAccountCreateWithoutAccountInput[] | BankAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BankAccountCreateOrConnectWithoutAccountInput | BankAccountCreateOrConnectWithoutAccountInput[]
    upsert?: BankAccountUpsertWithWhereUniqueWithoutAccountInput | BankAccountUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: BankAccountCreateManyAccountInputEnvelope
    set?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    disconnect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    delete?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    connect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    update?: BankAccountUpdateWithWhereUniqueWithoutAccountInput | BankAccountUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: BankAccountUpdateManyWithWhereWithoutAccountInput | BankAccountUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: BankAccountScalarWhereInput | BankAccountScalarWhereInput[]
  }

  export type BillingUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<BillingCreateWithoutAccountInput, BillingUncheckedCreateWithoutAccountInput> | BillingCreateWithoutAccountInput[] | BillingUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BillingCreateOrConnectWithoutAccountInput | BillingCreateOrConnectWithoutAccountInput[]
    upsert?: BillingUpsertWithWhereUniqueWithoutAccountInput | BillingUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: BillingCreateManyAccountInputEnvelope
    set?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    disconnect?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    delete?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    connect?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    update?: BillingUpdateWithWhereUniqueWithoutAccountInput | BillingUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: BillingUpdateManyWithWhereWithoutAccountInput | BillingUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: BillingScalarWhereInput | BillingScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ClientCreateWithoutAccountInput, ClientUncheckedCreateWithoutAccountInput> | ClientCreateWithoutAccountInput[] | ClientUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutAccountInput | ClientCreateOrConnectWithoutAccountInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutAccountInput | ClientUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ClientCreateManyAccountInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutAccountInput | ClientUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutAccountInput | ClientUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ServiceCreateWithoutAccountInput, ServiceUncheckedCreateWithoutAccountInput> | ServiceCreateWithoutAccountInput[] | ServiceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutAccountInput | ServiceCreateOrConnectWithoutAccountInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutAccountInput | ServiceUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ServiceCreateManyAccountInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutAccountInput | ServiceUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutAccountInput | ServiceUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type UnitOfMeasureUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<UnitOfMeasureCreateWithoutAccountInput, UnitOfMeasureUncheckedCreateWithoutAccountInput> | UnitOfMeasureCreateWithoutAccountInput[] | UnitOfMeasureUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutAccountInput | UnitOfMeasureCreateOrConnectWithoutAccountInput[]
    upsert?: UnitOfMeasureUpsertWithWhereUniqueWithoutAccountInput | UnitOfMeasureUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: UnitOfMeasureCreateManyAccountInputEnvelope
    set?: UnitOfMeasureWhereUniqueInput | UnitOfMeasureWhereUniqueInput[]
    disconnect?: UnitOfMeasureWhereUniqueInput | UnitOfMeasureWhereUniqueInput[]
    delete?: UnitOfMeasureWhereUniqueInput | UnitOfMeasureWhereUniqueInput[]
    connect?: UnitOfMeasureWhereUniqueInput | UnitOfMeasureWhereUniqueInput[]
    update?: UnitOfMeasureUpdateWithWhereUniqueWithoutAccountInput | UnitOfMeasureUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: UnitOfMeasureUpdateManyWithWhereWithoutAccountInput | UnitOfMeasureUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: UnitOfMeasureScalarWhereInput | UnitOfMeasureScalarWhereInput[]
  }

  export type PDFTemplateUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<PDFTemplateCreateWithoutAccountInput, PDFTemplateUncheckedCreateWithoutAccountInput> | PDFTemplateCreateWithoutAccountInput[] | PDFTemplateUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PDFTemplateCreateOrConnectWithoutAccountInput | PDFTemplateCreateOrConnectWithoutAccountInput[]
    upsert?: PDFTemplateUpsertWithWhereUniqueWithoutAccountInput | PDFTemplateUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: PDFTemplateCreateManyAccountInputEnvelope
    set?: PDFTemplateWhereUniqueInput | PDFTemplateWhereUniqueInput[]
    disconnect?: PDFTemplateWhereUniqueInput | PDFTemplateWhereUniqueInput[]
    delete?: PDFTemplateWhereUniqueInput | PDFTemplateWhereUniqueInput[]
    connect?: PDFTemplateWhereUniqueInput | PDFTemplateWhereUniqueInput[]
    update?: PDFTemplateUpdateWithWhereUniqueWithoutAccountInput | PDFTemplateUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: PDFTemplateUpdateManyWithWhereWithoutAccountInput | PDFTemplateUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: PDFTemplateScalarWhereInput | PDFTemplateScalarWhereInput[]
  }

  export type UserAccountUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<UserAccountCreateWithoutAccountInput, UserAccountUncheckedCreateWithoutAccountInput> | UserAccountCreateWithoutAccountInput[] | UserAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: UserAccountCreateOrConnectWithoutAccountInput | UserAccountCreateOrConnectWithoutAccountInput[]
    upsert?: UserAccountUpsertWithWhereUniqueWithoutAccountInput | UserAccountUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: UserAccountCreateManyAccountInputEnvelope
    set?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    disconnect?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    delete?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    connect?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    update?: UserAccountUpdateWithWhereUniqueWithoutAccountInput | UserAccountUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: UserAccountUpdateManyWithWhereWithoutAccountInput | UserAccountUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: UserAccountScalarWhereInput | UserAccountScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutParent_accountNestedInput = {
    create?: XOR<AccountCreateWithoutParent_accountInput, AccountUncheckedCreateWithoutParent_accountInput> | AccountCreateWithoutParent_accountInput[] | AccountUncheckedCreateWithoutParent_accountInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParent_accountInput | AccountCreateOrConnectWithoutParent_accountInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutParent_accountInput | AccountUpsertWithWhereUniqueWithoutParent_accountInput[]
    createMany?: AccountCreateManyParent_accountInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutParent_accountInput | AccountUpdateWithWhereUniqueWithoutParent_accountInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutParent_accountInput | AccountUpdateManyWithWhereWithoutParent_accountInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutGeneral_infoInput = {
    create?: XOR<AccountCreateWithoutGeneral_infoInput, AccountUncheckedCreateWithoutGeneral_infoInput>
    connectOrCreate?: AccountCreateOrConnectWithoutGeneral_infoInput
    connect?: AccountWhereUniqueInput
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type EnumAccountStatusFieldUpdateOperationsInput = {
    set?: $Enums.AccountStatus
  }

  export type NullableEnumEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.EntityType | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AccountUpdateOneRequiredWithoutGeneral_infoNestedInput = {
    create?: XOR<AccountCreateWithoutGeneral_infoInput, AccountUncheckedCreateWithoutGeneral_infoInput>
    connectOrCreate?: AccountCreateOrConnectWithoutGeneral_infoInput
    upsert?: AccountUpsertWithoutGeneral_infoInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutGeneral_infoInput, AccountUpdateWithoutGeneral_infoInput>, AccountUncheckedUpdateWithoutGeneral_infoInput>
  }

  export type AccountCreateNestedOneWithoutContact_infoInput = {
    create?: XOR<AccountCreateWithoutContact_infoInput, AccountUncheckedCreateWithoutContact_infoInput>
    connectOrCreate?: AccountCreateOrConnectWithoutContact_infoInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutContact_infoNestedInput = {
    create?: XOR<AccountCreateWithoutContact_infoInput, AccountUncheckedCreateWithoutContact_infoInput>
    connectOrCreate?: AccountCreateOrConnectWithoutContact_infoInput
    upsert?: AccountUpsertWithoutContact_infoInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutContact_infoInput, AccountUpdateWithoutContact_infoInput>, AccountUncheckedUpdateWithoutContact_infoInput>
  }

  export type AccountCreateNestedOneWithoutCompliance_infoInput = {
    create?: XOR<AccountCreateWithoutCompliance_infoInput, AccountUncheckedCreateWithoutCompliance_infoInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCompliance_infoInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutCompliance_infoNestedInput = {
    create?: XOR<AccountCreateWithoutCompliance_infoInput, AccountUncheckedCreateWithoutCompliance_infoInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCompliance_infoInput
    upsert?: AccountUpsertWithoutCompliance_infoInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutCompliance_infoInput, AccountUpdateWithoutCompliance_infoInput>, AccountUncheckedUpdateWithoutCompliance_infoInput>
  }

  export type AccountCreateNestedOneWithoutUsersInput = {
    create?: XOR<AccountCreateWithoutUsersInput, AccountUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutUsersInput
    connect?: AccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<AccountCreateWithoutUsersInput, AccountUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutUsersInput
    upsert?: AccountUpsertWithoutUsersInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutUsersInput, AccountUpdateWithoutUsersInput>, AccountUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutAccountsAuthInput = {
    create?: XOR<UserCreateWithoutAccountsAuthInput, UserUncheckedCreateWithoutAccountsAuthInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsAuthInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsAuthNestedInput = {
    create?: XOR<UserCreateWithoutAccountsAuthInput, UserUncheckedCreateWithoutAccountsAuthInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsAuthInput
    upsert?: UserUpsertWithoutAccountsAuthInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsAuthInput, UserUpdateWithoutAccountsAuthInput>, UserUncheckedUpdateWithoutAccountsAuthInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type ProfileEmailCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfileEmailCreateWithoutProfileInput, ProfileEmailUncheckedCreateWithoutProfileInput> | ProfileEmailCreateWithoutProfileInput[] | ProfileEmailUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileEmailCreateOrConnectWithoutProfileInput | ProfileEmailCreateOrConnectWithoutProfileInput[]
    createMany?: ProfileEmailCreateManyProfileInputEnvelope
    connect?: ProfileEmailWhereUniqueInput | ProfileEmailWhereUniqueInput[]
  }

  export type ProfilePhoneCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfilePhoneCreateWithoutProfileInput, ProfilePhoneUncheckedCreateWithoutProfileInput> | ProfilePhoneCreateWithoutProfileInput[] | ProfilePhoneUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfilePhoneCreateOrConnectWithoutProfileInput | ProfilePhoneCreateOrConnectWithoutProfileInput[]
    createMany?: ProfilePhoneCreateManyProfileInputEnvelope
    connect?: ProfilePhoneWhereUniqueInput | ProfilePhoneWhereUniqueInput[]
  }

  export type ProfileEmailUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfileEmailCreateWithoutProfileInput, ProfileEmailUncheckedCreateWithoutProfileInput> | ProfileEmailCreateWithoutProfileInput[] | ProfileEmailUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileEmailCreateOrConnectWithoutProfileInput | ProfileEmailCreateOrConnectWithoutProfileInput[]
    createMany?: ProfileEmailCreateManyProfileInputEnvelope
    connect?: ProfileEmailWhereUniqueInput | ProfileEmailWhereUniqueInput[]
  }

  export type ProfilePhoneUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfilePhoneCreateWithoutProfileInput, ProfilePhoneUncheckedCreateWithoutProfileInput> | ProfilePhoneCreateWithoutProfileInput[] | ProfilePhoneUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfilePhoneCreateOrConnectWithoutProfileInput | ProfilePhoneCreateOrConnectWithoutProfileInput[]
    createMany?: ProfilePhoneCreateManyProfileInputEnvelope
    connect?: ProfilePhoneWhereUniqueInput | ProfilePhoneWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type ProfileEmailUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfileEmailCreateWithoutProfileInput, ProfileEmailUncheckedCreateWithoutProfileInput> | ProfileEmailCreateWithoutProfileInput[] | ProfileEmailUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileEmailCreateOrConnectWithoutProfileInput | ProfileEmailCreateOrConnectWithoutProfileInput[]
    upsert?: ProfileEmailUpsertWithWhereUniqueWithoutProfileInput | ProfileEmailUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfileEmailCreateManyProfileInputEnvelope
    set?: ProfileEmailWhereUniqueInput | ProfileEmailWhereUniqueInput[]
    disconnect?: ProfileEmailWhereUniqueInput | ProfileEmailWhereUniqueInput[]
    delete?: ProfileEmailWhereUniqueInput | ProfileEmailWhereUniqueInput[]
    connect?: ProfileEmailWhereUniqueInput | ProfileEmailWhereUniqueInput[]
    update?: ProfileEmailUpdateWithWhereUniqueWithoutProfileInput | ProfileEmailUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfileEmailUpdateManyWithWhereWithoutProfileInput | ProfileEmailUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfileEmailScalarWhereInput | ProfileEmailScalarWhereInput[]
  }

  export type ProfilePhoneUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfilePhoneCreateWithoutProfileInput, ProfilePhoneUncheckedCreateWithoutProfileInput> | ProfilePhoneCreateWithoutProfileInput[] | ProfilePhoneUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfilePhoneCreateOrConnectWithoutProfileInput | ProfilePhoneCreateOrConnectWithoutProfileInput[]
    upsert?: ProfilePhoneUpsertWithWhereUniqueWithoutProfileInput | ProfilePhoneUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfilePhoneCreateManyProfileInputEnvelope
    set?: ProfilePhoneWhereUniqueInput | ProfilePhoneWhereUniqueInput[]
    disconnect?: ProfilePhoneWhereUniqueInput | ProfilePhoneWhereUniqueInput[]
    delete?: ProfilePhoneWhereUniqueInput | ProfilePhoneWhereUniqueInput[]
    connect?: ProfilePhoneWhereUniqueInput | ProfilePhoneWhereUniqueInput[]
    update?: ProfilePhoneUpdateWithWhereUniqueWithoutProfileInput | ProfilePhoneUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfilePhoneUpdateManyWithWhereWithoutProfileInput | ProfilePhoneUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfilePhoneScalarWhereInput | ProfilePhoneScalarWhereInput[]
  }

  export type ProfileEmailUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfileEmailCreateWithoutProfileInput, ProfileEmailUncheckedCreateWithoutProfileInput> | ProfileEmailCreateWithoutProfileInput[] | ProfileEmailUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileEmailCreateOrConnectWithoutProfileInput | ProfileEmailCreateOrConnectWithoutProfileInput[]
    upsert?: ProfileEmailUpsertWithWhereUniqueWithoutProfileInput | ProfileEmailUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfileEmailCreateManyProfileInputEnvelope
    set?: ProfileEmailWhereUniqueInput | ProfileEmailWhereUniqueInput[]
    disconnect?: ProfileEmailWhereUniqueInput | ProfileEmailWhereUniqueInput[]
    delete?: ProfileEmailWhereUniqueInput | ProfileEmailWhereUniqueInput[]
    connect?: ProfileEmailWhereUniqueInput | ProfileEmailWhereUniqueInput[]
    update?: ProfileEmailUpdateWithWhereUniqueWithoutProfileInput | ProfileEmailUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfileEmailUpdateManyWithWhereWithoutProfileInput | ProfileEmailUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfileEmailScalarWhereInput | ProfileEmailScalarWhereInput[]
  }

  export type ProfilePhoneUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfilePhoneCreateWithoutProfileInput, ProfilePhoneUncheckedCreateWithoutProfileInput> | ProfilePhoneCreateWithoutProfileInput[] | ProfilePhoneUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfilePhoneCreateOrConnectWithoutProfileInput | ProfilePhoneCreateOrConnectWithoutProfileInput[]
    upsert?: ProfilePhoneUpsertWithWhereUniqueWithoutProfileInput | ProfilePhoneUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfilePhoneCreateManyProfileInputEnvelope
    set?: ProfilePhoneWhereUniqueInput | ProfilePhoneWhereUniqueInput[]
    disconnect?: ProfilePhoneWhereUniqueInput | ProfilePhoneWhereUniqueInput[]
    delete?: ProfilePhoneWhereUniqueInput | ProfilePhoneWhereUniqueInput[]
    connect?: ProfilePhoneWhereUniqueInput | ProfilePhoneWhereUniqueInput[]
    update?: ProfilePhoneUpdateWithWhereUniqueWithoutProfileInput | ProfilePhoneUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfilePhoneUpdateManyWithWhereWithoutProfileInput | ProfilePhoneUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfilePhoneScalarWhereInput | ProfilePhoneScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutEmailsInput = {
    create?: XOR<ProfileCreateWithoutEmailsInput, ProfileUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutEmailsInput
    connect?: ProfileWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProfileUpdateOneRequiredWithoutEmailsNestedInput = {
    create?: XOR<ProfileCreateWithoutEmailsInput, ProfileUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutEmailsInput
    upsert?: ProfileUpsertWithoutEmailsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutEmailsInput, ProfileUpdateWithoutEmailsInput>, ProfileUncheckedUpdateWithoutEmailsInput>
  }

  export type ProfileCreateNestedOneWithoutPhonesInput = {
    create?: XOR<ProfileCreateWithoutPhonesInput, ProfileUncheckedCreateWithoutPhonesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPhonesInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutPhonesNestedInput = {
    create?: XOR<ProfileCreateWithoutPhonesInput, ProfileUncheckedCreateWithoutPhonesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPhonesInput
    upsert?: ProfileUpsertWithoutPhonesInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutPhonesInput, ProfileUpdateWithoutPhonesInput>, ProfileUncheckedUpdateWithoutPhonesInput>
  }

  export type AccountCreateNestedOneWithoutClientsInput = {
    create?: XOR<AccountCreateWithoutClientsInput, AccountUncheckedCreateWithoutClientsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutClientsInput
    connect?: AccountWhereUniqueInput
  }

  export type BillingCreateNestedManyWithoutClientInput = {
    create?: XOR<BillingCreateWithoutClientInput, BillingUncheckedCreateWithoutClientInput> | BillingCreateWithoutClientInput[] | BillingUncheckedCreateWithoutClientInput[]
    connectOrCreate?: BillingCreateOrConnectWithoutClientInput | BillingCreateOrConnectWithoutClientInput[]
    createMany?: BillingCreateManyClientInputEnvelope
    connect?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
  }

  export type ClientPhoneCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientPhoneCreateWithoutClientInput, ClientPhoneUncheckedCreateWithoutClientInput> | ClientPhoneCreateWithoutClientInput[] | ClientPhoneUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientPhoneCreateOrConnectWithoutClientInput | ClientPhoneCreateOrConnectWithoutClientInput[]
    createMany?: ClientPhoneCreateManyClientInputEnvelope
    connect?: ClientPhoneWhereUniqueInput | ClientPhoneWhereUniqueInput[]
  }

  export type ClientEmailCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientEmailCreateWithoutClientInput, ClientEmailUncheckedCreateWithoutClientInput> | ClientEmailCreateWithoutClientInput[] | ClientEmailUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientEmailCreateOrConnectWithoutClientInput | ClientEmailCreateOrConnectWithoutClientInput[]
    createMany?: ClientEmailCreateManyClientInputEnvelope
    connect?: ClientEmailWhereUniqueInput | ClientEmailWhereUniqueInput[]
  }

  export type ClientAddressCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientAddressCreateWithoutClientInput, ClientAddressUncheckedCreateWithoutClientInput> | ClientAddressCreateWithoutClientInput[] | ClientAddressUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientAddressCreateOrConnectWithoutClientInput | ClientAddressCreateOrConnectWithoutClientInput[]
    createMany?: ClientAddressCreateManyClientInputEnvelope
    connect?: ClientAddressWhereUniqueInput | ClientAddressWhereUniqueInput[]
  }

  export type ClientCompanyCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientCompanyCreateWithoutClientInput, ClientCompanyUncheckedCreateWithoutClientInput> | ClientCompanyCreateWithoutClientInput[] | ClientCompanyUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutClientInput | ClientCompanyCreateOrConnectWithoutClientInput[]
    createMany?: ClientCompanyCreateManyClientInputEnvelope
    connect?: ClientCompanyWhereUniqueInput | ClientCompanyWhereUniqueInput[]
  }

  export type BillingUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<BillingCreateWithoutClientInput, BillingUncheckedCreateWithoutClientInput> | BillingCreateWithoutClientInput[] | BillingUncheckedCreateWithoutClientInput[]
    connectOrCreate?: BillingCreateOrConnectWithoutClientInput | BillingCreateOrConnectWithoutClientInput[]
    createMany?: BillingCreateManyClientInputEnvelope
    connect?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
  }

  export type ClientPhoneUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientPhoneCreateWithoutClientInput, ClientPhoneUncheckedCreateWithoutClientInput> | ClientPhoneCreateWithoutClientInput[] | ClientPhoneUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientPhoneCreateOrConnectWithoutClientInput | ClientPhoneCreateOrConnectWithoutClientInput[]
    createMany?: ClientPhoneCreateManyClientInputEnvelope
    connect?: ClientPhoneWhereUniqueInput | ClientPhoneWhereUniqueInput[]
  }

  export type ClientEmailUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientEmailCreateWithoutClientInput, ClientEmailUncheckedCreateWithoutClientInput> | ClientEmailCreateWithoutClientInput[] | ClientEmailUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientEmailCreateOrConnectWithoutClientInput | ClientEmailCreateOrConnectWithoutClientInput[]
    createMany?: ClientEmailCreateManyClientInputEnvelope
    connect?: ClientEmailWhereUniqueInput | ClientEmailWhereUniqueInput[]
  }

  export type ClientAddressUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientAddressCreateWithoutClientInput, ClientAddressUncheckedCreateWithoutClientInput> | ClientAddressCreateWithoutClientInput[] | ClientAddressUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientAddressCreateOrConnectWithoutClientInput | ClientAddressCreateOrConnectWithoutClientInput[]
    createMany?: ClientAddressCreateManyClientInputEnvelope
    connect?: ClientAddressWhereUniqueInput | ClientAddressWhereUniqueInput[]
  }

  export type ClientCompanyUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientCompanyCreateWithoutClientInput, ClientCompanyUncheckedCreateWithoutClientInput> | ClientCompanyCreateWithoutClientInput[] | ClientCompanyUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutClientInput | ClientCompanyCreateOrConnectWithoutClientInput[]
    createMany?: ClientCompanyCreateManyClientInputEnvelope
    connect?: ClientCompanyWhereUniqueInput | ClientCompanyWhereUniqueInput[]
  }

  export type EnumClientTypeFieldUpdateOperationsInput = {
    set?: $Enums.ClientType
  }

  export type AccountUpdateOneRequiredWithoutClientsNestedInput = {
    create?: XOR<AccountCreateWithoutClientsInput, AccountUncheckedCreateWithoutClientsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutClientsInput
    upsert?: AccountUpsertWithoutClientsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutClientsInput, AccountUpdateWithoutClientsInput>, AccountUncheckedUpdateWithoutClientsInput>
  }

  export type BillingUpdateManyWithoutClientNestedInput = {
    create?: XOR<BillingCreateWithoutClientInput, BillingUncheckedCreateWithoutClientInput> | BillingCreateWithoutClientInput[] | BillingUncheckedCreateWithoutClientInput[]
    connectOrCreate?: BillingCreateOrConnectWithoutClientInput | BillingCreateOrConnectWithoutClientInput[]
    upsert?: BillingUpsertWithWhereUniqueWithoutClientInput | BillingUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: BillingCreateManyClientInputEnvelope
    set?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    disconnect?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    delete?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    connect?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    update?: BillingUpdateWithWhereUniqueWithoutClientInput | BillingUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: BillingUpdateManyWithWhereWithoutClientInput | BillingUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: BillingScalarWhereInput | BillingScalarWhereInput[]
  }

  export type ClientPhoneUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientPhoneCreateWithoutClientInput, ClientPhoneUncheckedCreateWithoutClientInput> | ClientPhoneCreateWithoutClientInput[] | ClientPhoneUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientPhoneCreateOrConnectWithoutClientInput | ClientPhoneCreateOrConnectWithoutClientInput[]
    upsert?: ClientPhoneUpsertWithWhereUniqueWithoutClientInput | ClientPhoneUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientPhoneCreateManyClientInputEnvelope
    set?: ClientPhoneWhereUniqueInput | ClientPhoneWhereUniqueInput[]
    disconnect?: ClientPhoneWhereUniqueInput | ClientPhoneWhereUniqueInput[]
    delete?: ClientPhoneWhereUniqueInput | ClientPhoneWhereUniqueInput[]
    connect?: ClientPhoneWhereUniqueInput | ClientPhoneWhereUniqueInput[]
    update?: ClientPhoneUpdateWithWhereUniqueWithoutClientInput | ClientPhoneUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientPhoneUpdateManyWithWhereWithoutClientInput | ClientPhoneUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientPhoneScalarWhereInput | ClientPhoneScalarWhereInput[]
  }

  export type ClientEmailUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientEmailCreateWithoutClientInput, ClientEmailUncheckedCreateWithoutClientInput> | ClientEmailCreateWithoutClientInput[] | ClientEmailUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientEmailCreateOrConnectWithoutClientInput | ClientEmailCreateOrConnectWithoutClientInput[]
    upsert?: ClientEmailUpsertWithWhereUniqueWithoutClientInput | ClientEmailUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientEmailCreateManyClientInputEnvelope
    set?: ClientEmailWhereUniqueInput | ClientEmailWhereUniqueInput[]
    disconnect?: ClientEmailWhereUniqueInput | ClientEmailWhereUniqueInput[]
    delete?: ClientEmailWhereUniqueInput | ClientEmailWhereUniqueInput[]
    connect?: ClientEmailWhereUniqueInput | ClientEmailWhereUniqueInput[]
    update?: ClientEmailUpdateWithWhereUniqueWithoutClientInput | ClientEmailUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientEmailUpdateManyWithWhereWithoutClientInput | ClientEmailUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientEmailScalarWhereInput | ClientEmailScalarWhereInput[]
  }

  export type ClientAddressUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientAddressCreateWithoutClientInput, ClientAddressUncheckedCreateWithoutClientInput> | ClientAddressCreateWithoutClientInput[] | ClientAddressUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientAddressCreateOrConnectWithoutClientInput | ClientAddressCreateOrConnectWithoutClientInput[]
    upsert?: ClientAddressUpsertWithWhereUniqueWithoutClientInput | ClientAddressUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientAddressCreateManyClientInputEnvelope
    set?: ClientAddressWhereUniqueInput | ClientAddressWhereUniqueInput[]
    disconnect?: ClientAddressWhereUniqueInput | ClientAddressWhereUniqueInput[]
    delete?: ClientAddressWhereUniqueInput | ClientAddressWhereUniqueInput[]
    connect?: ClientAddressWhereUniqueInput | ClientAddressWhereUniqueInput[]
    update?: ClientAddressUpdateWithWhereUniqueWithoutClientInput | ClientAddressUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientAddressUpdateManyWithWhereWithoutClientInput | ClientAddressUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientAddressScalarWhereInput | ClientAddressScalarWhereInput[]
  }

  export type ClientCompanyUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientCompanyCreateWithoutClientInput, ClientCompanyUncheckedCreateWithoutClientInput> | ClientCompanyCreateWithoutClientInput[] | ClientCompanyUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutClientInput | ClientCompanyCreateOrConnectWithoutClientInput[]
    upsert?: ClientCompanyUpsertWithWhereUniqueWithoutClientInput | ClientCompanyUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientCompanyCreateManyClientInputEnvelope
    set?: ClientCompanyWhereUniqueInput | ClientCompanyWhereUniqueInput[]
    disconnect?: ClientCompanyWhereUniqueInput | ClientCompanyWhereUniqueInput[]
    delete?: ClientCompanyWhereUniqueInput | ClientCompanyWhereUniqueInput[]
    connect?: ClientCompanyWhereUniqueInput | ClientCompanyWhereUniqueInput[]
    update?: ClientCompanyUpdateWithWhereUniqueWithoutClientInput | ClientCompanyUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientCompanyUpdateManyWithWhereWithoutClientInput | ClientCompanyUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientCompanyScalarWhereInput | ClientCompanyScalarWhereInput[]
  }

  export type BillingUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<BillingCreateWithoutClientInput, BillingUncheckedCreateWithoutClientInput> | BillingCreateWithoutClientInput[] | BillingUncheckedCreateWithoutClientInput[]
    connectOrCreate?: BillingCreateOrConnectWithoutClientInput | BillingCreateOrConnectWithoutClientInput[]
    upsert?: BillingUpsertWithWhereUniqueWithoutClientInput | BillingUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: BillingCreateManyClientInputEnvelope
    set?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    disconnect?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    delete?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    connect?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    update?: BillingUpdateWithWhereUniqueWithoutClientInput | BillingUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: BillingUpdateManyWithWhereWithoutClientInput | BillingUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: BillingScalarWhereInput | BillingScalarWhereInput[]
  }

  export type ClientPhoneUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientPhoneCreateWithoutClientInput, ClientPhoneUncheckedCreateWithoutClientInput> | ClientPhoneCreateWithoutClientInput[] | ClientPhoneUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientPhoneCreateOrConnectWithoutClientInput | ClientPhoneCreateOrConnectWithoutClientInput[]
    upsert?: ClientPhoneUpsertWithWhereUniqueWithoutClientInput | ClientPhoneUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientPhoneCreateManyClientInputEnvelope
    set?: ClientPhoneWhereUniqueInput | ClientPhoneWhereUniqueInput[]
    disconnect?: ClientPhoneWhereUniqueInput | ClientPhoneWhereUniqueInput[]
    delete?: ClientPhoneWhereUniqueInput | ClientPhoneWhereUniqueInput[]
    connect?: ClientPhoneWhereUniqueInput | ClientPhoneWhereUniqueInput[]
    update?: ClientPhoneUpdateWithWhereUniqueWithoutClientInput | ClientPhoneUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientPhoneUpdateManyWithWhereWithoutClientInput | ClientPhoneUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientPhoneScalarWhereInput | ClientPhoneScalarWhereInput[]
  }

  export type ClientEmailUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientEmailCreateWithoutClientInput, ClientEmailUncheckedCreateWithoutClientInput> | ClientEmailCreateWithoutClientInput[] | ClientEmailUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientEmailCreateOrConnectWithoutClientInput | ClientEmailCreateOrConnectWithoutClientInput[]
    upsert?: ClientEmailUpsertWithWhereUniqueWithoutClientInput | ClientEmailUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientEmailCreateManyClientInputEnvelope
    set?: ClientEmailWhereUniqueInput | ClientEmailWhereUniqueInput[]
    disconnect?: ClientEmailWhereUniqueInput | ClientEmailWhereUniqueInput[]
    delete?: ClientEmailWhereUniqueInput | ClientEmailWhereUniqueInput[]
    connect?: ClientEmailWhereUniqueInput | ClientEmailWhereUniqueInput[]
    update?: ClientEmailUpdateWithWhereUniqueWithoutClientInput | ClientEmailUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientEmailUpdateManyWithWhereWithoutClientInput | ClientEmailUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientEmailScalarWhereInput | ClientEmailScalarWhereInput[]
  }

  export type ClientAddressUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientAddressCreateWithoutClientInput, ClientAddressUncheckedCreateWithoutClientInput> | ClientAddressCreateWithoutClientInput[] | ClientAddressUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientAddressCreateOrConnectWithoutClientInput | ClientAddressCreateOrConnectWithoutClientInput[]
    upsert?: ClientAddressUpsertWithWhereUniqueWithoutClientInput | ClientAddressUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientAddressCreateManyClientInputEnvelope
    set?: ClientAddressWhereUniqueInput | ClientAddressWhereUniqueInput[]
    disconnect?: ClientAddressWhereUniqueInput | ClientAddressWhereUniqueInput[]
    delete?: ClientAddressWhereUniqueInput | ClientAddressWhereUniqueInput[]
    connect?: ClientAddressWhereUniqueInput | ClientAddressWhereUniqueInput[]
    update?: ClientAddressUpdateWithWhereUniqueWithoutClientInput | ClientAddressUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientAddressUpdateManyWithWhereWithoutClientInput | ClientAddressUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientAddressScalarWhereInput | ClientAddressScalarWhereInput[]
  }

  export type ClientCompanyUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientCompanyCreateWithoutClientInput, ClientCompanyUncheckedCreateWithoutClientInput> | ClientCompanyCreateWithoutClientInput[] | ClientCompanyUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutClientInput | ClientCompanyCreateOrConnectWithoutClientInput[]
    upsert?: ClientCompanyUpsertWithWhereUniqueWithoutClientInput | ClientCompanyUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientCompanyCreateManyClientInputEnvelope
    set?: ClientCompanyWhereUniqueInput | ClientCompanyWhereUniqueInput[]
    disconnect?: ClientCompanyWhereUniqueInput | ClientCompanyWhereUniqueInput[]
    delete?: ClientCompanyWhereUniqueInput | ClientCompanyWhereUniqueInput[]
    connect?: ClientCompanyWhereUniqueInput | ClientCompanyWhereUniqueInput[]
    update?: ClientCompanyUpdateWithWhereUniqueWithoutClientInput | ClientCompanyUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientCompanyUpdateManyWithWhereWithoutClientInput | ClientCompanyUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientCompanyScalarWhereInput | ClientCompanyScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutPhonesInput = {
    create?: XOR<ClientCreateWithoutPhonesInput, ClientUncheckedCreateWithoutPhonesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutPhonesInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutPhonesNestedInput = {
    create?: XOR<ClientCreateWithoutPhonesInput, ClientUncheckedCreateWithoutPhonesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutPhonesInput
    upsert?: ClientUpsertWithoutPhonesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutPhonesInput, ClientUpdateWithoutPhonesInput>, ClientUncheckedUpdateWithoutPhonesInput>
  }

  export type ClientCreateNestedOneWithoutEmailsInput = {
    create?: XOR<ClientCreateWithoutEmailsInput, ClientUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutEmailsInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutEmailsNestedInput = {
    create?: XOR<ClientCreateWithoutEmailsInput, ClientUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutEmailsInput
    upsert?: ClientUpsertWithoutEmailsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutEmailsInput, ClientUpdateWithoutEmailsInput>, ClientUncheckedUpdateWithoutEmailsInput>
  }

  export type ClientCreateNestedOneWithoutAddressesInput = {
    create?: XOR<ClientCreateWithoutAddressesInput, ClientUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAddressesInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<ClientCreateWithoutAddressesInput, ClientUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAddressesInput
    upsert?: ClientUpsertWithoutAddressesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutAddressesInput, ClientUpdateWithoutAddressesInput>, ClientUncheckedUpdateWithoutAddressesInput>
  }

  export type ClientCreateNestedOneWithoutClientCompanyInput = {
    create?: XOR<ClientCreateWithoutClientCompanyInput, ClientUncheckedCreateWithoutClientCompanyInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientCompanyInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientCompanyPhoneCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ClientCompanyPhoneCreateWithoutCompanyInput, ClientCompanyPhoneUncheckedCreateWithoutCompanyInput> | ClientCompanyPhoneCreateWithoutCompanyInput[] | ClientCompanyPhoneUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientCompanyPhoneCreateOrConnectWithoutCompanyInput | ClientCompanyPhoneCreateOrConnectWithoutCompanyInput[]
    createMany?: ClientCompanyPhoneCreateManyCompanyInputEnvelope
    connect?: ClientCompanyPhoneWhereUniqueInput | ClientCompanyPhoneWhereUniqueInput[]
  }

  export type ClientCompanyEmailCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ClientCompanyEmailCreateWithoutCompanyInput, ClientCompanyEmailUncheckedCreateWithoutCompanyInput> | ClientCompanyEmailCreateWithoutCompanyInput[] | ClientCompanyEmailUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientCompanyEmailCreateOrConnectWithoutCompanyInput | ClientCompanyEmailCreateOrConnectWithoutCompanyInput[]
    createMany?: ClientCompanyEmailCreateManyCompanyInputEnvelope
    connect?: ClientCompanyEmailWhereUniqueInput | ClientCompanyEmailWhereUniqueInput[]
  }

  export type ClientCompanyAddressCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ClientCompanyAddressCreateWithoutCompanyInput, ClientCompanyAddressUncheckedCreateWithoutCompanyInput> | ClientCompanyAddressCreateWithoutCompanyInput[] | ClientCompanyAddressUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientCompanyAddressCreateOrConnectWithoutCompanyInput | ClientCompanyAddressCreateOrConnectWithoutCompanyInput[]
    createMany?: ClientCompanyAddressCreateManyCompanyInputEnvelope
    connect?: ClientCompanyAddressWhereUniqueInput | ClientCompanyAddressWhereUniqueInput[]
  }

  export type BillingCreateNestedManyWithoutClientCompanyInput = {
    create?: XOR<BillingCreateWithoutClientCompanyInput, BillingUncheckedCreateWithoutClientCompanyInput> | BillingCreateWithoutClientCompanyInput[] | BillingUncheckedCreateWithoutClientCompanyInput[]
    connectOrCreate?: BillingCreateOrConnectWithoutClientCompanyInput | BillingCreateOrConnectWithoutClientCompanyInput[]
    createMany?: BillingCreateManyClientCompanyInputEnvelope
    connect?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
  }

  export type ClientCompanyPhoneUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ClientCompanyPhoneCreateWithoutCompanyInput, ClientCompanyPhoneUncheckedCreateWithoutCompanyInput> | ClientCompanyPhoneCreateWithoutCompanyInput[] | ClientCompanyPhoneUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientCompanyPhoneCreateOrConnectWithoutCompanyInput | ClientCompanyPhoneCreateOrConnectWithoutCompanyInput[]
    createMany?: ClientCompanyPhoneCreateManyCompanyInputEnvelope
    connect?: ClientCompanyPhoneWhereUniqueInput | ClientCompanyPhoneWhereUniqueInput[]
  }

  export type ClientCompanyEmailUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ClientCompanyEmailCreateWithoutCompanyInput, ClientCompanyEmailUncheckedCreateWithoutCompanyInput> | ClientCompanyEmailCreateWithoutCompanyInput[] | ClientCompanyEmailUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientCompanyEmailCreateOrConnectWithoutCompanyInput | ClientCompanyEmailCreateOrConnectWithoutCompanyInput[]
    createMany?: ClientCompanyEmailCreateManyCompanyInputEnvelope
    connect?: ClientCompanyEmailWhereUniqueInput | ClientCompanyEmailWhereUniqueInput[]
  }

  export type ClientCompanyAddressUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ClientCompanyAddressCreateWithoutCompanyInput, ClientCompanyAddressUncheckedCreateWithoutCompanyInput> | ClientCompanyAddressCreateWithoutCompanyInput[] | ClientCompanyAddressUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientCompanyAddressCreateOrConnectWithoutCompanyInput | ClientCompanyAddressCreateOrConnectWithoutCompanyInput[]
    createMany?: ClientCompanyAddressCreateManyCompanyInputEnvelope
    connect?: ClientCompanyAddressWhereUniqueInput | ClientCompanyAddressWhereUniqueInput[]
  }

  export type BillingUncheckedCreateNestedManyWithoutClientCompanyInput = {
    create?: XOR<BillingCreateWithoutClientCompanyInput, BillingUncheckedCreateWithoutClientCompanyInput> | BillingCreateWithoutClientCompanyInput[] | BillingUncheckedCreateWithoutClientCompanyInput[]
    connectOrCreate?: BillingCreateOrConnectWithoutClientCompanyInput | BillingCreateOrConnectWithoutClientCompanyInput[]
    createMany?: BillingCreateManyClientCompanyInputEnvelope
    connect?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
  }

  export type ClientUpdateOneRequiredWithoutClientCompanyNestedInput = {
    create?: XOR<ClientCreateWithoutClientCompanyInput, ClientUncheckedCreateWithoutClientCompanyInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientCompanyInput
    upsert?: ClientUpsertWithoutClientCompanyInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutClientCompanyInput, ClientUpdateWithoutClientCompanyInput>, ClientUncheckedUpdateWithoutClientCompanyInput>
  }

  export type ClientCompanyPhoneUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ClientCompanyPhoneCreateWithoutCompanyInput, ClientCompanyPhoneUncheckedCreateWithoutCompanyInput> | ClientCompanyPhoneCreateWithoutCompanyInput[] | ClientCompanyPhoneUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientCompanyPhoneCreateOrConnectWithoutCompanyInput | ClientCompanyPhoneCreateOrConnectWithoutCompanyInput[]
    upsert?: ClientCompanyPhoneUpsertWithWhereUniqueWithoutCompanyInput | ClientCompanyPhoneUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ClientCompanyPhoneCreateManyCompanyInputEnvelope
    set?: ClientCompanyPhoneWhereUniqueInput | ClientCompanyPhoneWhereUniqueInput[]
    disconnect?: ClientCompanyPhoneWhereUniqueInput | ClientCompanyPhoneWhereUniqueInput[]
    delete?: ClientCompanyPhoneWhereUniqueInput | ClientCompanyPhoneWhereUniqueInput[]
    connect?: ClientCompanyPhoneWhereUniqueInput | ClientCompanyPhoneWhereUniqueInput[]
    update?: ClientCompanyPhoneUpdateWithWhereUniqueWithoutCompanyInput | ClientCompanyPhoneUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ClientCompanyPhoneUpdateManyWithWhereWithoutCompanyInput | ClientCompanyPhoneUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ClientCompanyPhoneScalarWhereInput | ClientCompanyPhoneScalarWhereInput[]
  }

  export type ClientCompanyEmailUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ClientCompanyEmailCreateWithoutCompanyInput, ClientCompanyEmailUncheckedCreateWithoutCompanyInput> | ClientCompanyEmailCreateWithoutCompanyInput[] | ClientCompanyEmailUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientCompanyEmailCreateOrConnectWithoutCompanyInput | ClientCompanyEmailCreateOrConnectWithoutCompanyInput[]
    upsert?: ClientCompanyEmailUpsertWithWhereUniqueWithoutCompanyInput | ClientCompanyEmailUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ClientCompanyEmailCreateManyCompanyInputEnvelope
    set?: ClientCompanyEmailWhereUniqueInput | ClientCompanyEmailWhereUniqueInput[]
    disconnect?: ClientCompanyEmailWhereUniqueInput | ClientCompanyEmailWhereUniqueInput[]
    delete?: ClientCompanyEmailWhereUniqueInput | ClientCompanyEmailWhereUniqueInput[]
    connect?: ClientCompanyEmailWhereUniqueInput | ClientCompanyEmailWhereUniqueInput[]
    update?: ClientCompanyEmailUpdateWithWhereUniqueWithoutCompanyInput | ClientCompanyEmailUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ClientCompanyEmailUpdateManyWithWhereWithoutCompanyInput | ClientCompanyEmailUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ClientCompanyEmailScalarWhereInput | ClientCompanyEmailScalarWhereInput[]
  }

  export type ClientCompanyAddressUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ClientCompanyAddressCreateWithoutCompanyInput, ClientCompanyAddressUncheckedCreateWithoutCompanyInput> | ClientCompanyAddressCreateWithoutCompanyInput[] | ClientCompanyAddressUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientCompanyAddressCreateOrConnectWithoutCompanyInput | ClientCompanyAddressCreateOrConnectWithoutCompanyInput[]
    upsert?: ClientCompanyAddressUpsertWithWhereUniqueWithoutCompanyInput | ClientCompanyAddressUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ClientCompanyAddressCreateManyCompanyInputEnvelope
    set?: ClientCompanyAddressWhereUniqueInput | ClientCompanyAddressWhereUniqueInput[]
    disconnect?: ClientCompanyAddressWhereUniqueInput | ClientCompanyAddressWhereUniqueInput[]
    delete?: ClientCompanyAddressWhereUniqueInput | ClientCompanyAddressWhereUniqueInput[]
    connect?: ClientCompanyAddressWhereUniqueInput | ClientCompanyAddressWhereUniqueInput[]
    update?: ClientCompanyAddressUpdateWithWhereUniqueWithoutCompanyInput | ClientCompanyAddressUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ClientCompanyAddressUpdateManyWithWhereWithoutCompanyInput | ClientCompanyAddressUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ClientCompanyAddressScalarWhereInput | ClientCompanyAddressScalarWhereInput[]
  }

  export type BillingUpdateManyWithoutClientCompanyNestedInput = {
    create?: XOR<BillingCreateWithoutClientCompanyInput, BillingUncheckedCreateWithoutClientCompanyInput> | BillingCreateWithoutClientCompanyInput[] | BillingUncheckedCreateWithoutClientCompanyInput[]
    connectOrCreate?: BillingCreateOrConnectWithoutClientCompanyInput | BillingCreateOrConnectWithoutClientCompanyInput[]
    upsert?: BillingUpsertWithWhereUniqueWithoutClientCompanyInput | BillingUpsertWithWhereUniqueWithoutClientCompanyInput[]
    createMany?: BillingCreateManyClientCompanyInputEnvelope
    set?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    disconnect?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    delete?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    connect?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    update?: BillingUpdateWithWhereUniqueWithoutClientCompanyInput | BillingUpdateWithWhereUniqueWithoutClientCompanyInput[]
    updateMany?: BillingUpdateManyWithWhereWithoutClientCompanyInput | BillingUpdateManyWithWhereWithoutClientCompanyInput[]
    deleteMany?: BillingScalarWhereInput | BillingScalarWhereInput[]
  }

  export type ClientCompanyPhoneUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ClientCompanyPhoneCreateWithoutCompanyInput, ClientCompanyPhoneUncheckedCreateWithoutCompanyInput> | ClientCompanyPhoneCreateWithoutCompanyInput[] | ClientCompanyPhoneUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientCompanyPhoneCreateOrConnectWithoutCompanyInput | ClientCompanyPhoneCreateOrConnectWithoutCompanyInput[]
    upsert?: ClientCompanyPhoneUpsertWithWhereUniqueWithoutCompanyInput | ClientCompanyPhoneUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ClientCompanyPhoneCreateManyCompanyInputEnvelope
    set?: ClientCompanyPhoneWhereUniqueInput | ClientCompanyPhoneWhereUniqueInput[]
    disconnect?: ClientCompanyPhoneWhereUniqueInput | ClientCompanyPhoneWhereUniqueInput[]
    delete?: ClientCompanyPhoneWhereUniqueInput | ClientCompanyPhoneWhereUniqueInput[]
    connect?: ClientCompanyPhoneWhereUniqueInput | ClientCompanyPhoneWhereUniqueInput[]
    update?: ClientCompanyPhoneUpdateWithWhereUniqueWithoutCompanyInput | ClientCompanyPhoneUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ClientCompanyPhoneUpdateManyWithWhereWithoutCompanyInput | ClientCompanyPhoneUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ClientCompanyPhoneScalarWhereInput | ClientCompanyPhoneScalarWhereInput[]
  }

  export type ClientCompanyEmailUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ClientCompanyEmailCreateWithoutCompanyInput, ClientCompanyEmailUncheckedCreateWithoutCompanyInput> | ClientCompanyEmailCreateWithoutCompanyInput[] | ClientCompanyEmailUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientCompanyEmailCreateOrConnectWithoutCompanyInput | ClientCompanyEmailCreateOrConnectWithoutCompanyInput[]
    upsert?: ClientCompanyEmailUpsertWithWhereUniqueWithoutCompanyInput | ClientCompanyEmailUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ClientCompanyEmailCreateManyCompanyInputEnvelope
    set?: ClientCompanyEmailWhereUniqueInput | ClientCompanyEmailWhereUniqueInput[]
    disconnect?: ClientCompanyEmailWhereUniqueInput | ClientCompanyEmailWhereUniqueInput[]
    delete?: ClientCompanyEmailWhereUniqueInput | ClientCompanyEmailWhereUniqueInput[]
    connect?: ClientCompanyEmailWhereUniqueInput | ClientCompanyEmailWhereUniqueInput[]
    update?: ClientCompanyEmailUpdateWithWhereUniqueWithoutCompanyInput | ClientCompanyEmailUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ClientCompanyEmailUpdateManyWithWhereWithoutCompanyInput | ClientCompanyEmailUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ClientCompanyEmailScalarWhereInput | ClientCompanyEmailScalarWhereInput[]
  }

  export type ClientCompanyAddressUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ClientCompanyAddressCreateWithoutCompanyInput, ClientCompanyAddressUncheckedCreateWithoutCompanyInput> | ClientCompanyAddressCreateWithoutCompanyInput[] | ClientCompanyAddressUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientCompanyAddressCreateOrConnectWithoutCompanyInput | ClientCompanyAddressCreateOrConnectWithoutCompanyInput[]
    upsert?: ClientCompanyAddressUpsertWithWhereUniqueWithoutCompanyInput | ClientCompanyAddressUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ClientCompanyAddressCreateManyCompanyInputEnvelope
    set?: ClientCompanyAddressWhereUniqueInput | ClientCompanyAddressWhereUniqueInput[]
    disconnect?: ClientCompanyAddressWhereUniqueInput | ClientCompanyAddressWhereUniqueInput[]
    delete?: ClientCompanyAddressWhereUniqueInput | ClientCompanyAddressWhereUniqueInput[]
    connect?: ClientCompanyAddressWhereUniqueInput | ClientCompanyAddressWhereUniqueInput[]
    update?: ClientCompanyAddressUpdateWithWhereUniqueWithoutCompanyInput | ClientCompanyAddressUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ClientCompanyAddressUpdateManyWithWhereWithoutCompanyInput | ClientCompanyAddressUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ClientCompanyAddressScalarWhereInput | ClientCompanyAddressScalarWhereInput[]
  }

  export type BillingUncheckedUpdateManyWithoutClientCompanyNestedInput = {
    create?: XOR<BillingCreateWithoutClientCompanyInput, BillingUncheckedCreateWithoutClientCompanyInput> | BillingCreateWithoutClientCompanyInput[] | BillingUncheckedCreateWithoutClientCompanyInput[]
    connectOrCreate?: BillingCreateOrConnectWithoutClientCompanyInput | BillingCreateOrConnectWithoutClientCompanyInput[]
    upsert?: BillingUpsertWithWhereUniqueWithoutClientCompanyInput | BillingUpsertWithWhereUniqueWithoutClientCompanyInput[]
    createMany?: BillingCreateManyClientCompanyInputEnvelope
    set?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    disconnect?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    delete?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    connect?: BillingWhereUniqueInput | BillingWhereUniqueInput[]
    update?: BillingUpdateWithWhereUniqueWithoutClientCompanyInput | BillingUpdateWithWhereUniqueWithoutClientCompanyInput[]
    updateMany?: BillingUpdateManyWithWhereWithoutClientCompanyInput | BillingUpdateManyWithWhereWithoutClientCompanyInput[]
    deleteMany?: BillingScalarWhereInput | BillingScalarWhereInput[]
  }

  export type ClientCompanyCreateNestedOneWithoutPhonesInput = {
    create?: XOR<ClientCompanyCreateWithoutPhonesInput, ClientCompanyUncheckedCreateWithoutPhonesInput>
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutPhonesInput
    connect?: ClientCompanyWhereUniqueInput
  }

  export type ClientCompanyUpdateOneRequiredWithoutPhonesNestedInput = {
    create?: XOR<ClientCompanyCreateWithoutPhonesInput, ClientCompanyUncheckedCreateWithoutPhonesInput>
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutPhonesInput
    upsert?: ClientCompanyUpsertWithoutPhonesInput
    connect?: ClientCompanyWhereUniqueInput
    update?: XOR<XOR<ClientCompanyUpdateToOneWithWhereWithoutPhonesInput, ClientCompanyUpdateWithoutPhonesInput>, ClientCompanyUncheckedUpdateWithoutPhonesInput>
  }

  export type ClientCompanyCreateNestedOneWithoutEmailsInput = {
    create?: XOR<ClientCompanyCreateWithoutEmailsInput, ClientCompanyUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutEmailsInput
    connect?: ClientCompanyWhereUniqueInput
  }

  export type ClientCompanyUpdateOneRequiredWithoutEmailsNestedInput = {
    create?: XOR<ClientCompanyCreateWithoutEmailsInput, ClientCompanyUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutEmailsInput
    upsert?: ClientCompanyUpsertWithoutEmailsInput
    connect?: ClientCompanyWhereUniqueInput
    update?: XOR<XOR<ClientCompanyUpdateToOneWithWhereWithoutEmailsInput, ClientCompanyUpdateWithoutEmailsInput>, ClientCompanyUncheckedUpdateWithoutEmailsInput>
  }

  export type ClientCompanyCreateNestedOneWithoutAddressesInput = {
    create?: XOR<ClientCompanyCreateWithoutAddressesInput, ClientCompanyUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutAddressesInput
    connect?: ClientCompanyWhereUniqueInput
  }

  export type ClientCompanyUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<ClientCompanyCreateWithoutAddressesInput, ClientCompanyUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutAddressesInput
    upsert?: ClientCompanyUpsertWithoutAddressesInput
    connect?: ClientCompanyWhereUniqueInput
    update?: XOR<XOR<ClientCompanyUpdateToOneWithWhereWithoutAddressesInput, ClientCompanyUpdateWithoutAddressesInput>, ClientCompanyUncheckedUpdateWithoutAddressesInput>
  }

  export type ServiceCreateNestedManyWithoutUnit_of_measureInput = {
    create?: XOR<ServiceCreateWithoutUnit_of_measureInput, ServiceUncheckedCreateWithoutUnit_of_measureInput> | ServiceCreateWithoutUnit_of_measureInput[] | ServiceUncheckedCreateWithoutUnit_of_measureInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUnit_of_measureInput | ServiceCreateOrConnectWithoutUnit_of_measureInput[]
    createMany?: ServiceCreateManyUnit_of_measureInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type AccountCreateNestedOneWithoutUnits_of_measureInput = {
    create?: XOR<AccountCreateWithoutUnits_of_measureInput, AccountUncheckedCreateWithoutUnits_of_measureInput>
    connectOrCreate?: AccountCreateOrConnectWithoutUnits_of_measureInput
    connect?: AccountWhereUniqueInput
  }

  export type ServiceUncheckedCreateNestedManyWithoutUnit_of_measureInput = {
    create?: XOR<ServiceCreateWithoutUnit_of_measureInput, ServiceUncheckedCreateWithoutUnit_of_measureInput> | ServiceCreateWithoutUnit_of_measureInput[] | ServiceUncheckedCreateWithoutUnit_of_measureInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUnit_of_measureInput | ServiceCreateOrConnectWithoutUnit_of_measureInput[]
    createMany?: ServiceCreateManyUnit_of_measureInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUpdateManyWithoutUnit_of_measureNestedInput = {
    create?: XOR<ServiceCreateWithoutUnit_of_measureInput, ServiceUncheckedCreateWithoutUnit_of_measureInput> | ServiceCreateWithoutUnit_of_measureInput[] | ServiceUncheckedCreateWithoutUnit_of_measureInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUnit_of_measureInput | ServiceCreateOrConnectWithoutUnit_of_measureInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutUnit_of_measureInput | ServiceUpsertWithWhereUniqueWithoutUnit_of_measureInput[]
    createMany?: ServiceCreateManyUnit_of_measureInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutUnit_of_measureInput | ServiceUpdateWithWhereUniqueWithoutUnit_of_measureInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutUnit_of_measureInput | ServiceUpdateManyWithWhereWithoutUnit_of_measureInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type AccountUpdateOneRequiredWithoutUnits_of_measureNestedInput = {
    create?: XOR<AccountCreateWithoutUnits_of_measureInput, AccountUncheckedCreateWithoutUnits_of_measureInput>
    connectOrCreate?: AccountCreateOrConnectWithoutUnits_of_measureInput
    upsert?: AccountUpsertWithoutUnits_of_measureInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutUnits_of_measureInput, AccountUpdateWithoutUnits_of_measureInput>, AccountUncheckedUpdateWithoutUnits_of_measureInput>
  }

  export type ServiceUncheckedUpdateManyWithoutUnit_of_measureNestedInput = {
    create?: XOR<ServiceCreateWithoutUnit_of_measureInput, ServiceUncheckedCreateWithoutUnit_of_measureInput> | ServiceCreateWithoutUnit_of_measureInput[] | ServiceUncheckedCreateWithoutUnit_of_measureInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUnit_of_measureInput | ServiceCreateOrConnectWithoutUnit_of_measureInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutUnit_of_measureInput | ServiceUpsertWithWhereUniqueWithoutUnit_of_measureInput[]
    createMany?: ServiceCreateManyUnit_of_measureInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutUnit_of_measureInput | ServiceUpdateWithWhereUniqueWithoutUnit_of_measureInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutUnit_of_measureInput | ServiceUpdateManyWithWhereWithoutUnit_of_measureInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type BillingItemCreateNestedManyWithoutServiceInput = {
    create?: XOR<BillingItemCreateWithoutServiceInput, BillingItemUncheckedCreateWithoutServiceInput> | BillingItemCreateWithoutServiceInput[] | BillingItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BillingItemCreateOrConnectWithoutServiceInput | BillingItemCreateOrConnectWithoutServiceInput[]
    createMany?: BillingItemCreateManyServiceInputEnvelope
    connect?: BillingItemWhereUniqueInput | BillingItemWhereUniqueInput[]
  }

  export type AccountCreateNestedOneWithoutServicesInput = {
    create?: XOR<AccountCreateWithoutServicesInput, AccountUncheckedCreateWithoutServicesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutServicesInput
    connect?: AccountWhereUniqueInput
  }

  export type UnitOfMeasureCreateNestedOneWithoutServicesInput = {
    create?: XOR<UnitOfMeasureCreateWithoutServicesInput, UnitOfMeasureUncheckedCreateWithoutServicesInput>
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutServicesInput
    connect?: UnitOfMeasureWhereUniqueInput
  }

  export type BillingItemUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<BillingItemCreateWithoutServiceInput, BillingItemUncheckedCreateWithoutServiceInput> | BillingItemCreateWithoutServiceInput[] | BillingItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BillingItemCreateOrConnectWithoutServiceInput | BillingItemCreateOrConnectWithoutServiceInput[]
    createMany?: BillingItemCreateManyServiceInputEnvelope
    connect?: BillingItemWhereUniqueInput | BillingItemWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BillingItemUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BillingItemCreateWithoutServiceInput, BillingItemUncheckedCreateWithoutServiceInput> | BillingItemCreateWithoutServiceInput[] | BillingItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BillingItemCreateOrConnectWithoutServiceInput | BillingItemCreateOrConnectWithoutServiceInput[]
    upsert?: BillingItemUpsertWithWhereUniqueWithoutServiceInput | BillingItemUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BillingItemCreateManyServiceInputEnvelope
    set?: BillingItemWhereUniqueInput | BillingItemWhereUniqueInput[]
    disconnect?: BillingItemWhereUniqueInput | BillingItemWhereUniqueInput[]
    delete?: BillingItemWhereUniqueInput | BillingItemWhereUniqueInput[]
    connect?: BillingItemWhereUniqueInput | BillingItemWhereUniqueInput[]
    update?: BillingItemUpdateWithWhereUniqueWithoutServiceInput | BillingItemUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BillingItemUpdateManyWithWhereWithoutServiceInput | BillingItemUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BillingItemScalarWhereInput | BillingItemScalarWhereInput[]
  }

  export type AccountUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<AccountCreateWithoutServicesInput, AccountUncheckedCreateWithoutServicesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutServicesInput
    upsert?: AccountUpsertWithoutServicesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutServicesInput, AccountUpdateWithoutServicesInput>, AccountUncheckedUpdateWithoutServicesInput>
  }

  export type UnitOfMeasureUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<UnitOfMeasureCreateWithoutServicesInput, UnitOfMeasureUncheckedCreateWithoutServicesInput>
    connectOrCreate?: UnitOfMeasureCreateOrConnectWithoutServicesInput
    upsert?: UnitOfMeasureUpsertWithoutServicesInput
    connect?: UnitOfMeasureWhereUniqueInput
    update?: XOR<XOR<UnitOfMeasureUpdateToOneWithWhereWithoutServicesInput, UnitOfMeasureUpdateWithoutServicesInput>, UnitOfMeasureUncheckedUpdateWithoutServicesInput>
  }

  export type BillingItemUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BillingItemCreateWithoutServiceInput, BillingItemUncheckedCreateWithoutServiceInput> | BillingItemCreateWithoutServiceInput[] | BillingItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BillingItemCreateOrConnectWithoutServiceInput | BillingItemCreateOrConnectWithoutServiceInput[]
    upsert?: BillingItemUpsertWithWhereUniqueWithoutServiceInput | BillingItemUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BillingItemCreateManyServiceInputEnvelope
    set?: BillingItemWhereUniqueInput | BillingItemWhereUniqueInput[]
    disconnect?: BillingItemWhereUniqueInput | BillingItemWhereUniqueInput[]
    delete?: BillingItemWhereUniqueInput | BillingItemWhereUniqueInput[]
    connect?: BillingItemWhereUniqueInput | BillingItemWhereUniqueInput[]
    update?: BillingItemUpdateWithWhereUniqueWithoutServiceInput | BillingItemUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BillingItemUpdateManyWithWhereWithoutServiceInput | BillingItemUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BillingItemScalarWhereInput | BillingItemScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutBillingsInput = {
    create?: XOR<AccountCreateWithoutBillingsInput, AccountUncheckedCreateWithoutBillingsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutBillingsInput
    connect?: AccountWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutBillingsInput = {
    create?: XOR<ClientCreateWithoutBillingsInput, ClientUncheckedCreateWithoutBillingsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutBillingsInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientCompanyCreateNestedOneWithoutBillingsInput = {
    create?: XOR<ClientCompanyCreateWithoutBillingsInput, ClientCompanyUncheckedCreateWithoutBillingsInput>
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutBillingsInput
    connect?: ClientCompanyWhereUniqueInput
  }

  export type BillingItemCreateNestedManyWithoutBillingInput = {
    create?: XOR<BillingItemCreateWithoutBillingInput, BillingItemUncheckedCreateWithoutBillingInput> | BillingItemCreateWithoutBillingInput[] | BillingItemUncheckedCreateWithoutBillingInput[]
    connectOrCreate?: BillingItemCreateOrConnectWithoutBillingInput | BillingItemCreateOrConnectWithoutBillingInput[]
    createMany?: BillingItemCreateManyBillingInputEnvelope
    connect?: BillingItemWhereUniqueInput | BillingItemWhereUniqueInput[]
  }

  export type BillingItemUncheckedCreateNestedManyWithoutBillingInput = {
    create?: XOR<BillingItemCreateWithoutBillingInput, BillingItemUncheckedCreateWithoutBillingInput> | BillingItemCreateWithoutBillingInput[] | BillingItemUncheckedCreateWithoutBillingInput[]
    connectOrCreate?: BillingItemCreateOrConnectWithoutBillingInput | BillingItemCreateOrConnectWithoutBillingInput[]
    createMany?: BillingItemCreateManyBillingInputEnvelope
    connect?: BillingItemWhereUniqueInput | BillingItemWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumBillingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BillingStatus
  }

  export type AccountUpdateOneRequiredWithoutBillingsNestedInput = {
    create?: XOR<AccountCreateWithoutBillingsInput, AccountUncheckedCreateWithoutBillingsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutBillingsInput
    upsert?: AccountUpsertWithoutBillingsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutBillingsInput, AccountUpdateWithoutBillingsInput>, AccountUncheckedUpdateWithoutBillingsInput>
  }

  export type ClientUpdateOneRequiredWithoutBillingsNestedInput = {
    create?: XOR<ClientCreateWithoutBillingsInput, ClientUncheckedCreateWithoutBillingsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutBillingsInput
    upsert?: ClientUpsertWithoutBillingsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutBillingsInput, ClientUpdateWithoutBillingsInput>, ClientUncheckedUpdateWithoutBillingsInput>
  }

  export type ClientCompanyUpdateOneWithoutBillingsNestedInput = {
    create?: XOR<ClientCompanyCreateWithoutBillingsInput, ClientCompanyUncheckedCreateWithoutBillingsInput>
    connectOrCreate?: ClientCompanyCreateOrConnectWithoutBillingsInput
    upsert?: ClientCompanyUpsertWithoutBillingsInput
    disconnect?: ClientCompanyWhereInput | boolean
    delete?: ClientCompanyWhereInput | boolean
    connect?: ClientCompanyWhereUniqueInput
    update?: XOR<XOR<ClientCompanyUpdateToOneWithWhereWithoutBillingsInput, ClientCompanyUpdateWithoutBillingsInput>, ClientCompanyUncheckedUpdateWithoutBillingsInput>
  }

  export type BillingItemUpdateManyWithoutBillingNestedInput = {
    create?: XOR<BillingItemCreateWithoutBillingInput, BillingItemUncheckedCreateWithoutBillingInput> | BillingItemCreateWithoutBillingInput[] | BillingItemUncheckedCreateWithoutBillingInput[]
    connectOrCreate?: BillingItemCreateOrConnectWithoutBillingInput | BillingItemCreateOrConnectWithoutBillingInput[]
    upsert?: BillingItemUpsertWithWhereUniqueWithoutBillingInput | BillingItemUpsertWithWhereUniqueWithoutBillingInput[]
    createMany?: BillingItemCreateManyBillingInputEnvelope
    set?: BillingItemWhereUniqueInput | BillingItemWhereUniqueInput[]
    disconnect?: BillingItemWhereUniqueInput | BillingItemWhereUniqueInput[]
    delete?: BillingItemWhereUniqueInput | BillingItemWhereUniqueInput[]
    connect?: BillingItemWhereUniqueInput | BillingItemWhereUniqueInput[]
    update?: BillingItemUpdateWithWhereUniqueWithoutBillingInput | BillingItemUpdateWithWhereUniqueWithoutBillingInput[]
    updateMany?: BillingItemUpdateManyWithWhereWithoutBillingInput | BillingItemUpdateManyWithWhereWithoutBillingInput[]
    deleteMany?: BillingItemScalarWhereInput | BillingItemScalarWhereInput[]
  }

  export type BillingItemUncheckedUpdateManyWithoutBillingNestedInput = {
    create?: XOR<BillingItemCreateWithoutBillingInput, BillingItemUncheckedCreateWithoutBillingInput> | BillingItemCreateWithoutBillingInput[] | BillingItemUncheckedCreateWithoutBillingInput[]
    connectOrCreate?: BillingItemCreateOrConnectWithoutBillingInput | BillingItemCreateOrConnectWithoutBillingInput[]
    upsert?: BillingItemUpsertWithWhereUniqueWithoutBillingInput | BillingItemUpsertWithWhereUniqueWithoutBillingInput[]
    createMany?: BillingItemCreateManyBillingInputEnvelope
    set?: BillingItemWhereUniqueInput | BillingItemWhereUniqueInput[]
    disconnect?: BillingItemWhereUniqueInput | BillingItemWhereUniqueInput[]
    delete?: BillingItemWhereUniqueInput | BillingItemWhereUniqueInput[]
    connect?: BillingItemWhereUniqueInput | BillingItemWhereUniqueInput[]
    update?: BillingItemUpdateWithWhereUniqueWithoutBillingInput | BillingItemUpdateWithWhereUniqueWithoutBillingInput[]
    updateMany?: BillingItemUpdateManyWithWhereWithoutBillingInput | BillingItemUpdateManyWithWhereWithoutBillingInput[]
    deleteMany?: BillingItemScalarWhereInput | BillingItemScalarWhereInput[]
  }

  export type BillingCreateNestedOneWithoutItemsInput = {
    create?: XOR<BillingCreateWithoutItemsInput, BillingUncheckedCreateWithoutItemsInput>
    connectOrCreate?: BillingCreateOrConnectWithoutItemsInput
    connect?: BillingWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutBilling_itemsInput = {
    create?: XOR<ServiceCreateWithoutBilling_itemsInput, ServiceUncheckedCreateWithoutBilling_itemsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBilling_itemsInput
    connect?: ServiceWhereUniqueInput
  }

  export type BillingUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<BillingCreateWithoutItemsInput, BillingUncheckedCreateWithoutItemsInput>
    connectOrCreate?: BillingCreateOrConnectWithoutItemsInput
    upsert?: BillingUpsertWithoutItemsInput
    connect?: BillingWhereUniqueInput
    update?: XOR<XOR<BillingUpdateToOneWithWhereWithoutItemsInput, BillingUpdateWithoutItemsInput>, BillingUncheckedUpdateWithoutItemsInput>
  }

  export type ServiceUpdateOneRequiredWithoutBilling_itemsNestedInput = {
    create?: XOR<ServiceCreateWithoutBilling_itemsInput, ServiceUncheckedCreateWithoutBilling_itemsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBilling_itemsInput
    upsert?: ServiceUpsertWithoutBilling_itemsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutBilling_itemsInput, ServiceUpdateWithoutBilling_itemsInput>, ServiceUncheckedUpdateWithoutBilling_itemsInput>
  }

  export type AccountCreateNestedOneWithoutBank_accountsInput = {
    create?: XOR<AccountCreateWithoutBank_accountsInput, AccountUncheckedCreateWithoutBank_accountsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutBank_accountsInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutBank_accountsNestedInput = {
    create?: XOR<AccountCreateWithoutBank_accountsInput, AccountUncheckedCreateWithoutBank_accountsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutBank_accountsInput
    upsert?: AccountUpsertWithoutBank_accountsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutBank_accountsInput, AccountUpdateWithoutBank_accountsInput>, AccountUncheckedUpdateWithoutBank_accountsInput>
  }

  export type AccountCreateNestedOneWithoutPdf_templatesInput = {
    create?: XOR<AccountCreateWithoutPdf_templatesInput, AccountUncheckedCreateWithoutPdf_templatesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutPdf_templatesInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutPdf_templatesNestedInput = {
    create?: XOR<AccountCreateWithoutPdf_templatesInput, AccountUncheckedCreateWithoutPdf_templatesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutPdf_templatesInput
    upsert?: AccountUpsertWithoutPdf_templatesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutPdf_templatesInput, AccountUpdateWithoutPdf_templatesInput>, AccountUncheckedUpdateWithoutPdf_templatesInput>
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type UserAccountCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAccountCreateWithoutUserInput, UserAccountUncheckedCreateWithoutUserInput> | UserAccountCreateWithoutUserInput[] | UserAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAccountCreateOrConnectWithoutUserInput | UserAccountCreateOrConnectWithoutUserInput[]
    createMany?: UserAccountCreateManyUserInputEnvelope
    connect?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
  }

  export type AccountAuthCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountAuthCreateWithoutUserInput, AccountAuthUncheckedCreateWithoutUserInput> | AccountAuthCreateWithoutUserInput[] | AccountAuthUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountAuthCreateOrConnectWithoutUserInput | AccountAuthCreateOrConnectWithoutUserInput[]
    createMany?: AccountAuthCreateManyUserInputEnvelope
    connect?: AccountAuthWhereUniqueInput | AccountAuthWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type UserAccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAccountCreateWithoutUserInput, UserAccountUncheckedCreateWithoutUserInput> | UserAccountCreateWithoutUserInput[] | UserAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAccountCreateOrConnectWithoutUserInput | UserAccountCreateOrConnectWithoutUserInput[]
    createMany?: UserAccountCreateManyUserInputEnvelope
    connect?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
  }

  export type AccountAuthUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountAuthCreateWithoutUserInput, AccountAuthUncheckedCreateWithoutUserInput> | AccountAuthCreateWithoutUserInput[] | AccountAuthUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountAuthCreateOrConnectWithoutUserInput | AccountAuthCreateOrConnectWithoutUserInput[]
    createMany?: AccountAuthCreateManyUserInputEnvelope
    connect?: AccountAuthWhereUniqueInput | AccountAuthWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserAccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAccountCreateWithoutUserInput, UserAccountUncheckedCreateWithoutUserInput> | UserAccountCreateWithoutUserInput[] | UserAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAccountCreateOrConnectWithoutUserInput | UserAccountCreateOrConnectWithoutUserInput[]
    upsert?: UserAccountUpsertWithWhereUniqueWithoutUserInput | UserAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAccountCreateManyUserInputEnvelope
    set?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    disconnect?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    delete?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    connect?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    update?: UserAccountUpdateWithWhereUniqueWithoutUserInput | UserAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAccountUpdateManyWithWhereWithoutUserInput | UserAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAccountScalarWhereInput | UserAccountScalarWhereInput[]
  }

  export type AccountAuthUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountAuthCreateWithoutUserInput, AccountAuthUncheckedCreateWithoutUserInput> | AccountAuthCreateWithoutUserInput[] | AccountAuthUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountAuthCreateOrConnectWithoutUserInput | AccountAuthCreateOrConnectWithoutUserInput[]
    upsert?: AccountAuthUpsertWithWhereUniqueWithoutUserInput | AccountAuthUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountAuthCreateManyUserInputEnvelope
    set?: AccountAuthWhereUniqueInput | AccountAuthWhereUniqueInput[]
    disconnect?: AccountAuthWhereUniqueInput | AccountAuthWhereUniqueInput[]
    delete?: AccountAuthWhereUniqueInput | AccountAuthWhereUniqueInput[]
    connect?: AccountAuthWhereUniqueInput | AccountAuthWhereUniqueInput[]
    update?: AccountAuthUpdateWithWhereUniqueWithoutUserInput | AccountAuthUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountAuthUpdateManyWithWhereWithoutUserInput | AccountAuthUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountAuthScalarWhereInput | AccountAuthScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserAccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAccountCreateWithoutUserInput, UserAccountUncheckedCreateWithoutUserInput> | UserAccountCreateWithoutUserInput[] | UserAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAccountCreateOrConnectWithoutUserInput | UserAccountCreateOrConnectWithoutUserInput[]
    upsert?: UserAccountUpsertWithWhereUniqueWithoutUserInput | UserAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAccountCreateManyUserInputEnvelope
    set?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    disconnect?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    delete?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    connect?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    update?: UserAccountUpdateWithWhereUniqueWithoutUserInput | UserAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAccountUpdateManyWithWhereWithoutUserInput | UserAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAccountScalarWhereInput | UserAccountScalarWhereInput[]
  }

  export type AccountAuthUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountAuthCreateWithoutUserInput, AccountAuthUncheckedCreateWithoutUserInput> | AccountAuthCreateWithoutUserInput[] | AccountAuthUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountAuthCreateOrConnectWithoutUserInput | AccountAuthCreateOrConnectWithoutUserInput[]
    upsert?: AccountAuthUpsertWithWhereUniqueWithoutUserInput | AccountAuthUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountAuthCreateManyUserInputEnvelope
    set?: AccountAuthWhereUniqueInput | AccountAuthWhereUniqueInput[]
    disconnect?: AccountAuthWhereUniqueInput | AccountAuthWhereUniqueInput[]
    delete?: AccountAuthWhereUniqueInput | AccountAuthWhereUniqueInput[]
    connect?: AccountAuthWhereUniqueInput | AccountAuthWhereUniqueInput[]
    update?: AccountAuthUpdateWithWhereUniqueWithoutUserInput | AccountAuthUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountAuthUpdateManyWithWhereWithoutUserInput | AccountAuthUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountAuthScalarWhereInput | AccountAuthScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[]
    notIn?: $Enums.AccountType[]
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type NestedEnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[]
    notIn?: $Enums.AccountStatus[]
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type NestedEnumEntityTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EntityType[] | null
    notIn?: $Enums.EntityType[] | null
    not?: NestedEnumEntityTypeNullableFilter<$PrismaModel> | $Enums.EntityType | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[]
    notIn?: $Enums.AccountType[]
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[]
    notIn?: $Enums.AccountStatus[]
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type NestedEnumEntityTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EntityType[] | null
    notIn?: $Enums.EntityType[] | null
    not?: NestedEnumEntityTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EntityType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEntityTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumEntityTypeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumClientTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[]
    notIn?: $Enums.ClientType[]
    not?: NestedEnumClientTypeFilter<$PrismaModel> | $Enums.ClientType
  }

  export type NestedEnumClientTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[]
    notIn?: $Enums.ClientType[]
    not?: NestedEnumClientTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClientType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientTypeFilter<$PrismaModel>
    _max?: NestedEnumClientTypeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumBillingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingStatus | EnumBillingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillingStatus[]
    notIn?: $Enums.BillingStatus[]
    not?: NestedEnumBillingStatusFilter<$PrismaModel> | $Enums.BillingStatus
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumBillingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingStatus | EnumBillingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillingStatus[]
    notIn?: $Enums.BillingStatus[]
    not?: NestedEnumBillingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BillingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillingStatusFilter<$PrismaModel>
    _max?: NestedEnumBillingStatusFilter<$PrismaModel>
  }

  export type AccountGeneralInfoCreateWithoutAccountInput = {
    id?: string
    type: $Enums.AccountType
    status?: $Enums.AccountStatus
    dba_name?: string | null
    entity_type?: $Enums.EntityType | null
    ein?: string | null
    duns_number?: string | null
    incorporation_date?: Date | string | null
    incorporation_state?: string | null
    industry?: string | null
    currency?: string | null
    payment_terms?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountGeneralInfoUncheckedCreateWithoutAccountInput = {
    id?: string
    type: $Enums.AccountType
    status?: $Enums.AccountStatus
    dba_name?: string | null
    entity_type?: $Enums.EntityType | null
    ein?: string | null
    duns_number?: string | null
    incorporation_date?: Date | string | null
    incorporation_state?: string | null
    industry?: string | null
    currency?: string | null
    payment_terms?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountGeneralInfoCreateOrConnectWithoutAccountInput = {
    where: AccountGeneralInfoWhereUniqueInput
    create: XOR<AccountGeneralInfoCreateWithoutAccountInput, AccountGeneralInfoUncheckedCreateWithoutAccountInput>
  }

  export type AccountContactInfoCreateWithoutAccountInput = {
    id?: string
    address_street?: string | null
    address_suite?: string | null
    address_city?: string | null
    address_state?: string | null
    address_zip?: string | null
    address_country?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    website?: string | null
    mailing_address_street?: string | null
    mailing_address_suite?: string | null
    mailing_address_city?: string | null
    mailing_address_state?: string | null
    mailing_address_zip?: string | null
    mailing_address_country?: string | null
    contact_name?: string | null
    contact_title?: string | null
    contact_phone?: string | null
    contact_email?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountContactInfoUncheckedCreateWithoutAccountInput = {
    id?: string
    address_street?: string | null
    address_suite?: string | null
    address_city?: string | null
    address_state?: string | null
    address_zip?: string | null
    address_country?: string | null
    phone?: string | null
    fax?: string | null
    email?: string | null
    website?: string | null
    mailing_address_street?: string | null
    mailing_address_suite?: string | null
    mailing_address_city?: string | null
    mailing_address_state?: string | null
    mailing_address_zip?: string | null
    mailing_address_country?: string | null
    contact_name?: string | null
    contact_title?: string | null
    contact_phone?: string | null
    contact_email?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountContactInfoCreateOrConnectWithoutAccountInput = {
    where: AccountContactInfoWhereUniqueInput
    create: XOR<AccountContactInfoCreateWithoutAccountInput, AccountContactInfoUncheckedCreateWithoutAccountInput>
  }

  export type AccountComplianceCreateWithoutAccountInput = {
    id?: string
    license_numbers?: string | null
    insurance_info?: string | null
    invoice_prefix?: string | null
    logo_url?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountComplianceUncheckedCreateWithoutAccountInput = {
    id?: string
    license_numbers?: string | null
    insurance_info?: string | null
    invoice_prefix?: string | null
    logo_url?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountComplianceCreateOrConnectWithoutAccountInput = {
    where: AccountComplianceWhereUniqueInput
    create: XOR<AccountComplianceCreateWithoutAccountInput, AccountComplianceUncheckedCreateWithoutAccountInput>
  }

  export type BankAccountCreateWithoutAccountInput = {
    id?: string
    bank_name: string
    account_number: string
    routing_number?: string | null
    account_type?: string | null
    currency?: string | null
    is_primary?: boolean
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BankAccountUncheckedCreateWithoutAccountInput = {
    id?: string
    bank_name: string
    account_number: string
    routing_number?: string | null
    account_type?: string | null
    currency?: string | null
    is_primary?: boolean
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BankAccountCreateOrConnectWithoutAccountInput = {
    where: BankAccountWhereUniqueInput
    create: XOR<BankAccountCreateWithoutAccountInput, BankAccountUncheckedCreateWithoutAccountInput>
  }

  export type BankAccountCreateManyAccountInputEnvelope = {
    data: BankAccountCreateManyAccountInput | BankAccountCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type BillingCreateWithoutAccountInput = {
    id?: string
    billing_date?: Date | string
    due_date?: Date | string | null
    invoice_number: string
    invoice_prefix?: string
    invoice_sequence: number
    billing_address: string
    subtotal_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string
    discount_amount?: Decimal | DecimalJsLike | number | string
    total_amount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    status?: $Enums.BillingStatus
    cancellation_date?: Date | string | null
    cancellation_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    client: ClientCreateNestedOneWithoutBillingsInput
    clientCompany?: ClientCompanyCreateNestedOneWithoutBillingsInput
    items?: BillingItemCreateNestedManyWithoutBillingInput
  }

  export type BillingUncheckedCreateWithoutAccountInput = {
    id?: string
    client_id: string
    client_company_id?: string | null
    billing_date?: Date | string
    due_date?: Date | string | null
    invoice_number: string
    invoice_prefix?: string
    invoice_sequence: number
    billing_address: string
    subtotal_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string
    discount_amount?: Decimal | DecimalJsLike | number | string
    total_amount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    status?: $Enums.BillingStatus
    cancellation_date?: Date | string | null
    cancellation_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    items?: BillingItemUncheckedCreateNestedManyWithoutBillingInput
  }

  export type BillingCreateOrConnectWithoutAccountInput = {
    where: BillingWhereUniqueInput
    create: XOR<BillingCreateWithoutAccountInput, BillingUncheckedCreateWithoutAccountInput>
  }

  export type BillingCreateManyAccountInputEnvelope = {
    data: BillingCreateManyAccountInput | BillingCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutAccountInput = {
    id?: string
    client_type?: $Enums.ClientType
    name: string
    company_name?: string | null
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billings?: BillingCreateNestedManyWithoutClientInput
    phones?: ClientPhoneCreateNestedManyWithoutClientInput
    emails?: ClientEmailCreateNestedManyWithoutClientInput
    addresses?: ClientAddressCreateNestedManyWithoutClientInput
    ClientCompany?: ClientCompanyCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutAccountInput = {
    id?: string
    client_type?: $Enums.ClientType
    name: string
    company_name?: string | null
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billings?: BillingUncheckedCreateNestedManyWithoutClientInput
    phones?: ClientPhoneUncheckedCreateNestedManyWithoutClientInput
    emails?: ClientEmailUncheckedCreateNestedManyWithoutClientInput
    addresses?: ClientAddressUncheckedCreateNestedManyWithoutClientInput
    ClientCompany?: ClientCompanyUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutAccountInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutAccountInput, ClientUncheckedCreateWithoutAccountInput>
  }

  export type ClientCreateManyAccountInputEnvelope = {
    data: ClientCreateManyAccountInput | ClientCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCreateWithoutAccountInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    is_discount?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billing_items?: BillingItemCreateNestedManyWithoutServiceInput
    unit_of_measure: UnitOfMeasureCreateNestedOneWithoutServicesInput
  }

  export type ServiceUncheckedCreateWithoutAccountInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    unit_of_measure_id: string
    is_discount?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billing_items?: BillingItemUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutAccountInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutAccountInput, ServiceUncheckedCreateWithoutAccountInput>
  }

  export type ServiceCreateManyAccountInputEnvelope = {
    data: ServiceCreateManyAccountInput | ServiceCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type UnitOfMeasureCreateWithoutAccountInput = {
    id?: string
    name: string
    symbol: string
    description?: string | null
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    services?: ServiceCreateNestedManyWithoutUnit_of_measureInput
  }

  export type UnitOfMeasureUncheckedCreateWithoutAccountInput = {
    id?: string
    name: string
    symbol: string
    description?: string | null
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutUnit_of_measureInput
  }

  export type UnitOfMeasureCreateOrConnectWithoutAccountInput = {
    where: UnitOfMeasureWhereUniqueInput
    create: XOR<UnitOfMeasureCreateWithoutAccountInput, UnitOfMeasureUncheckedCreateWithoutAccountInput>
  }

  export type UnitOfMeasureCreateManyAccountInputEnvelope = {
    data: UnitOfMeasureCreateManyAccountInput | UnitOfMeasureCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type PDFTemplateCreateWithoutAccountInput = {
    id?: string
    name: string
    description?: string | null
    is_default?: boolean
    primary_color?: string
    secondary_color?: string
    font_family?: string
    show_logo?: boolean
    show_watermark?: boolean
    show_qr_code?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type PDFTemplateUncheckedCreateWithoutAccountInput = {
    id?: string
    name: string
    description?: string | null
    is_default?: boolean
    primary_color?: string
    secondary_color?: string
    font_family?: string
    show_logo?: boolean
    show_watermark?: boolean
    show_qr_code?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type PDFTemplateCreateOrConnectWithoutAccountInput = {
    where: PDFTemplateWhereUniqueInput
    create: XOR<PDFTemplateCreateWithoutAccountInput, PDFTemplateUncheckedCreateWithoutAccountInput>
  }

  export type PDFTemplateCreateManyAccountInputEnvelope = {
    data: PDFTemplateCreateManyAccountInput | PDFTemplateCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type UserAccountCreateWithoutAccountInput = {
    role: string
    created_at?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type UserAccountUncheckedCreateWithoutAccountInput = {
    user_id: string
    role: string
    created_at?: Date | string
  }

  export type UserAccountCreateOrConnectWithoutAccountInput = {
    where: UserAccountWhereUniqueInput
    create: XOR<UserAccountCreateWithoutAccountInput, UserAccountUncheckedCreateWithoutAccountInput>
  }

  export type UserAccountCreateManyAccountInputEnvelope = {
    data: UserAccountCreateManyAccountInput | UserAccountCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutChild_accountsInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    general_info?: AccountGeneralInfoCreateNestedOneWithoutAccountInput
    contact_info?: AccountContactInfoCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountCreateNestedManyWithoutAccountInput
    billings?: BillingCreateNestedManyWithoutAccountInput
    clients?: ClientCreateNestedManyWithoutAccountInput
    services?: ServiceCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateCreateNestedManyWithoutAccountInput
    users?: UserAccountCreateNestedManyWithoutAccountInput
    parent_account?: AccountCreateNestedOneWithoutChild_accountsInput
  }

  export type AccountUncheckedCreateWithoutChild_accountsInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    parent_account_id?: string | null
    general_info?: AccountGeneralInfoUncheckedCreateNestedOneWithoutAccountInput
    contact_info?: AccountContactInfoUncheckedCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceUncheckedCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountUncheckedCreateNestedManyWithoutAccountInput
    billings?: BillingUncheckedCreateNestedManyWithoutAccountInput
    clients?: ClientUncheckedCreateNestedManyWithoutAccountInput
    services?: ServiceUncheckedCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureUncheckedCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateUncheckedCreateNestedManyWithoutAccountInput
    users?: UserAccountUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutChild_accountsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutChild_accountsInput, AccountUncheckedCreateWithoutChild_accountsInput>
  }

  export type AccountCreateWithoutParent_accountInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    general_info?: AccountGeneralInfoCreateNestedOneWithoutAccountInput
    contact_info?: AccountContactInfoCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountCreateNestedManyWithoutAccountInput
    billings?: BillingCreateNestedManyWithoutAccountInput
    clients?: ClientCreateNestedManyWithoutAccountInput
    services?: ServiceCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateCreateNestedManyWithoutAccountInput
    users?: UserAccountCreateNestedManyWithoutAccountInput
    child_accounts?: AccountCreateNestedManyWithoutParent_accountInput
  }

  export type AccountUncheckedCreateWithoutParent_accountInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    general_info?: AccountGeneralInfoUncheckedCreateNestedOneWithoutAccountInput
    contact_info?: AccountContactInfoUncheckedCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceUncheckedCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountUncheckedCreateNestedManyWithoutAccountInput
    billings?: BillingUncheckedCreateNestedManyWithoutAccountInput
    clients?: ClientUncheckedCreateNestedManyWithoutAccountInput
    services?: ServiceUncheckedCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureUncheckedCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateUncheckedCreateNestedManyWithoutAccountInput
    users?: UserAccountUncheckedCreateNestedManyWithoutAccountInput
    child_accounts?: AccountUncheckedCreateNestedManyWithoutParent_accountInput
  }

  export type AccountCreateOrConnectWithoutParent_accountInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutParent_accountInput, AccountUncheckedCreateWithoutParent_accountInput>
  }

  export type AccountCreateManyParent_accountInputEnvelope = {
    data: AccountCreateManyParent_accountInput | AccountCreateManyParent_accountInput[]
    skipDuplicates?: boolean
  }

  export type AccountGeneralInfoUpsertWithoutAccountInput = {
    update: XOR<AccountGeneralInfoUpdateWithoutAccountInput, AccountGeneralInfoUncheckedUpdateWithoutAccountInput>
    create: XOR<AccountGeneralInfoCreateWithoutAccountInput, AccountGeneralInfoUncheckedCreateWithoutAccountInput>
    where?: AccountGeneralInfoWhereInput
  }

  export type AccountGeneralInfoUpdateToOneWithWhereWithoutAccountInput = {
    where?: AccountGeneralInfoWhereInput
    data: XOR<AccountGeneralInfoUpdateWithoutAccountInput, AccountGeneralInfoUncheckedUpdateWithoutAccountInput>
  }

  export type AccountGeneralInfoUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    dba_name?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    ein?: NullableStringFieldUpdateOperationsInput | string | null
    duns_number?: NullableStringFieldUpdateOperationsInput | string | null
    incorporation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incorporation_state?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountGeneralInfoUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    dba_name?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    ein?: NullableStringFieldUpdateOperationsInput | string | null
    duns_number?: NullableStringFieldUpdateOperationsInput | string | null
    incorporation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incorporation_state?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountContactInfoUpsertWithoutAccountInput = {
    update: XOR<AccountContactInfoUpdateWithoutAccountInput, AccountContactInfoUncheckedUpdateWithoutAccountInput>
    create: XOR<AccountContactInfoCreateWithoutAccountInput, AccountContactInfoUncheckedCreateWithoutAccountInput>
    where?: AccountContactInfoWhereInput
  }

  export type AccountContactInfoUpdateToOneWithWhereWithoutAccountInput = {
    where?: AccountContactInfoWhereInput
    data: XOR<AccountContactInfoUpdateWithoutAccountInput, AccountContactInfoUncheckedUpdateWithoutAccountInput>
  }

  export type AccountContactInfoUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_suite?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_state?: NullableStringFieldUpdateOperationsInput | string | null
    address_zip?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_street?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_suite?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_city?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_state?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_zip?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_country?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    contact_title?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountContactInfoUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_suite?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_state?: NullableStringFieldUpdateOperationsInput | string | null
    address_zip?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_street?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_suite?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_city?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_state?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_zip?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_address_country?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    contact_title?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountComplianceUpsertWithoutAccountInput = {
    update: XOR<AccountComplianceUpdateWithoutAccountInput, AccountComplianceUncheckedUpdateWithoutAccountInput>
    create: XOR<AccountComplianceCreateWithoutAccountInput, AccountComplianceUncheckedCreateWithoutAccountInput>
    where?: AccountComplianceWhereInput
  }

  export type AccountComplianceUpdateToOneWithWhereWithoutAccountInput = {
    where?: AccountComplianceWhereInput
    data: XOR<AccountComplianceUpdateWithoutAccountInput, AccountComplianceUncheckedUpdateWithoutAccountInput>
  }

  export type AccountComplianceUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    license_numbers?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountComplianceUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    license_numbers?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUpsertWithWhereUniqueWithoutAccountInput = {
    where: BankAccountWhereUniqueInput
    update: XOR<BankAccountUpdateWithoutAccountInput, BankAccountUncheckedUpdateWithoutAccountInput>
    create: XOR<BankAccountCreateWithoutAccountInput, BankAccountUncheckedCreateWithoutAccountInput>
  }

  export type BankAccountUpdateWithWhereUniqueWithoutAccountInput = {
    where: BankAccountWhereUniqueInput
    data: XOR<BankAccountUpdateWithoutAccountInput, BankAccountUncheckedUpdateWithoutAccountInput>
  }

  export type BankAccountUpdateManyWithWhereWithoutAccountInput = {
    where: BankAccountScalarWhereInput
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyWithoutAccountInput>
  }

  export type BankAccountScalarWhereInput = {
    AND?: BankAccountScalarWhereInput | BankAccountScalarWhereInput[]
    OR?: BankAccountScalarWhereInput[]
    NOT?: BankAccountScalarWhereInput | BankAccountScalarWhereInput[]
    id?: StringFilter<"BankAccount"> | string
    account_id?: StringFilter<"BankAccount"> | string
    bank_name?: StringFilter<"BankAccount"> | string
    account_number?: StringFilter<"BankAccount"> | string
    routing_number?: StringNullableFilter<"BankAccount"> | string | null
    account_type?: StringNullableFilter<"BankAccount"> | string | null
    currency?: StringNullableFilter<"BankAccount"> | string | null
    is_primary?: BoolFilter<"BankAccount"> | boolean
    description?: StringNullableFilter<"BankAccount"> | string | null
    created_at?: DateTimeFilter<"BankAccount"> | Date | string
    updated_at?: DateTimeFilter<"BankAccount"> | Date | string
  }

  export type BillingUpsertWithWhereUniqueWithoutAccountInput = {
    where: BillingWhereUniqueInput
    update: XOR<BillingUpdateWithoutAccountInput, BillingUncheckedUpdateWithoutAccountInput>
    create: XOR<BillingCreateWithoutAccountInput, BillingUncheckedCreateWithoutAccountInput>
  }

  export type BillingUpdateWithWhereUniqueWithoutAccountInput = {
    where: BillingWhereUniqueInput
    data: XOR<BillingUpdateWithoutAccountInput, BillingUncheckedUpdateWithoutAccountInput>
  }

  export type BillingUpdateManyWithWhereWithoutAccountInput = {
    where: BillingScalarWhereInput
    data: XOR<BillingUpdateManyMutationInput, BillingUncheckedUpdateManyWithoutAccountInput>
  }

  export type BillingScalarWhereInput = {
    AND?: BillingScalarWhereInput | BillingScalarWhereInput[]
    OR?: BillingScalarWhereInput[]
    NOT?: BillingScalarWhereInput | BillingScalarWhereInput[]
    id?: StringFilter<"Billing"> | string
    account_id?: StringFilter<"Billing"> | string
    client_id?: StringFilter<"Billing"> | string
    client_company_id?: StringNullableFilter<"Billing"> | string | null
    billing_date?: DateTimeFilter<"Billing"> | Date | string
    due_date?: DateTimeNullableFilter<"Billing"> | Date | string | null
    invoice_number?: StringFilter<"Billing"> | string
    invoice_prefix?: StringFilter<"Billing"> | string
    invoice_sequence?: IntFilter<"Billing"> | number
    billing_address?: StringFilter<"Billing"> | string
    subtotal_amount?: DecimalFilter<"Billing"> | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFilter<"Billing"> | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFilter<"Billing"> | Decimal | DecimalJsLike | number | string
    total_amount?: DecimalFilter<"Billing"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Billing"> | string | null
    status?: EnumBillingStatusFilter<"Billing"> | $Enums.BillingStatus
    cancellation_date?: DateTimeNullableFilter<"Billing"> | Date | string | null
    cancellation_reason?: StringNullableFilter<"Billing"> | string | null
    created_at?: DateTimeFilter<"Billing"> | Date | string
    updated_at?: DateTimeFilter<"Billing"> | Date | string
    created_by?: StringNullableFilter<"Billing"> | string | null
    updated_by?: StringNullableFilter<"Billing"> | string | null
  }

  export type ClientUpsertWithWhereUniqueWithoutAccountInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutAccountInput, ClientUncheckedUpdateWithoutAccountInput>
    create: XOR<ClientCreateWithoutAccountInput, ClientUncheckedCreateWithoutAccountInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutAccountInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutAccountInput, ClientUncheckedUpdateWithoutAccountInput>
  }

  export type ClientUpdateManyWithWhereWithoutAccountInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutAccountInput>
  }

  export type ClientScalarWhereInput = {
    AND?: ClientScalarWhereInput | ClientScalarWhereInput[]
    OR?: ClientScalarWhereInput[]
    NOT?: ClientScalarWhereInput | ClientScalarWhereInput[]
    id?: StringFilter<"Client"> | string
    account_id?: StringFilter<"Client"> | string
    client_type?: EnumClientTypeFilter<"Client"> | $Enums.ClientType
    name?: StringFilter<"Client"> | string
    company_name?: StringNullableFilter<"Client"> | string | null
    tax_id?: StringNullableFilter<"Client"> | string | null
    website?: StringNullableFilter<"Client"> | string | null
    notes?: StringNullableFilter<"Client"> | string | null
    is_active?: BoolFilter<"Client"> | boolean
    created_at?: DateTimeFilter<"Client"> | Date | string
    updated_at?: DateTimeFilter<"Client"> | Date | string
  }

  export type ServiceUpsertWithWhereUniqueWithoutAccountInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutAccountInput, ServiceUncheckedUpdateWithoutAccountInput>
    create: XOR<ServiceCreateWithoutAccountInput, ServiceUncheckedCreateWithoutAccountInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutAccountInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutAccountInput, ServiceUncheckedUpdateWithoutAccountInput>
  }

  export type ServiceUpdateManyWithWhereWithoutAccountInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutAccountInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: StringFilter<"Service"> | string
    account_id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    price?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    unit_of_measure_id?: StringFilter<"Service"> | string
    is_discount?: BoolFilter<"Service"> | boolean
    is_active?: BoolFilter<"Service"> | boolean
    created_at?: DateTimeFilter<"Service"> | Date | string
    updated_at?: DateTimeFilter<"Service"> | Date | string
  }

  export type UnitOfMeasureUpsertWithWhereUniqueWithoutAccountInput = {
    where: UnitOfMeasureWhereUniqueInput
    update: XOR<UnitOfMeasureUpdateWithoutAccountInput, UnitOfMeasureUncheckedUpdateWithoutAccountInput>
    create: XOR<UnitOfMeasureCreateWithoutAccountInput, UnitOfMeasureUncheckedCreateWithoutAccountInput>
  }

  export type UnitOfMeasureUpdateWithWhereUniqueWithoutAccountInput = {
    where: UnitOfMeasureWhereUniqueInput
    data: XOR<UnitOfMeasureUpdateWithoutAccountInput, UnitOfMeasureUncheckedUpdateWithoutAccountInput>
  }

  export type UnitOfMeasureUpdateManyWithWhereWithoutAccountInput = {
    where: UnitOfMeasureScalarWhereInput
    data: XOR<UnitOfMeasureUpdateManyMutationInput, UnitOfMeasureUncheckedUpdateManyWithoutAccountInput>
  }

  export type UnitOfMeasureScalarWhereInput = {
    AND?: UnitOfMeasureScalarWhereInput | UnitOfMeasureScalarWhereInput[]
    OR?: UnitOfMeasureScalarWhereInput[]
    NOT?: UnitOfMeasureScalarWhereInput | UnitOfMeasureScalarWhereInput[]
    id?: StringFilter<"UnitOfMeasure"> | string
    account_id?: StringFilter<"UnitOfMeasure"> | string
    name?: StringFilter<"UnitOfMeasure"> | string
    symbol?: StringFilter<"UnitOfMeasure"> | string
    description?: StringNullableFilter<"UnitOfMeasure"> | string | null
    is_default?: BoolFilter<"UnitOfMeasure"> | boolean
    created_at?: DateTimeFilter<"UnitOfMeasure"> | Date | string
    updated_at?: DateTimeFilter<"UnitOfMeasure"> | Date | string
  }

  export type PDFTemplateUpsertWithWhereUniqueWithoutAccountInput = {
    where: PDFTemplateWhereUniqueInput
    update: XOR<PDFTemplateUpdateWithoutAccountInput, PDFTemplateUncheckedUpdateWithoutAccountInput>
    create: XOR<PDFTemplateCreateWithoutAccountInput, PDFTemplateUncheckedCreateWithoutAccountInput>
  }

  export type PDFTemplateUpdateWithWhereUniqueWithoutAccountInput = {
    where: PDFTemplateWhereUniqueInput
    data: XOR<PDFTemplateUpdateWithoutAccountInput, PDFTemplateUncheckedUpdateWithoutAccountInput>
  }

  export type PDFTemplateUpdateManyWithWhereWithoutAccountInput = {
    where: PDFTemplateScalarWhereInput
    data: XOR<PDFTemplateUpdateManyMutationInput, PDFTemplateUncheckedUpdateManyWithoutAccountInput>
  }

  export type PDFTemplateScalarWhereInput = {
    AND?: PDFTemplateScalarWhereInput | PDFTemplateScalarWhereInput[]
    OR?: PDFTemplateScalarWhereInput[]
    NOT?: PDFTemplateScalarWhereInput | PDFTemplateScalarWhereInput[]
    id?: StringFilter<"PDFTemplate"> | string
    account_id?: StringFilter<"PDFTemplate"> | string
    name?: StringFilter<"PDFTemplate"> | string
    description?: StringNullableFilter<"PDFTemplate"> | string | null
    is_default?: BoolFilter<"PDFTemplate"> | boolean
    primary_color?: StringFilter<"PDFTemplate"> | string
    secondary_color?: StringFilter<"PDFTemplate"> | string
    font_family?: StringFilter<"PDFTemplate"> | string
    show_logo?: BoolFilter<"PDFTemplate"> | boolean
    show_watermark?: BoolFilter<"PDFTemplate"> | boolean
    show_qr_code?: BoolFilter<"PDFTemplate"> | boolean
    created_at?: DateTimeFilter<"PDFTemplate"> | Date | string
    updated_at?: DateTimeFilter<"PDFTemplate"> | Date | string
    created_by?: StringNullableFilter<"PDFTemplate"> | string | null
    updated_by?: StringNullableFilter<"PDFTemplate"> | string | null
  }

  export type UserAccountUpsertWithWhereUniqueWithoutAccountInput = {
    where: UserAccountWhereUniqueInput
    update: XOR<UserAccountUpdateWithoutAccountInput, UserAccountUncheckedUpdateWithoutAccountInput>
    create: XOR<UserAccountCreateWithoutAccountInput, UserAccountUncheckedCreateWithoutAccountInput>
  }

  export type UserAccountUpdateWithWhereUniqueWithoutAccountInput = {
    where: UserAccountWhereUniqueInput
    data: XOR<UserAccountUpdateWithoutAccountInput, UserAccountUncheckedUpdateWithoutAccountInput>
  }

  export type UserAccountUpdateManyWithWhereWithoutAccountInput = {
    where: UserAccountScalarWhereInput
    data: XOR<UserAccountUpdateManyMutationInput, UserAccountUncheckedUpdateManyWithoutAccountInput>
  }

  export type UserAccountScalarWhereInput = {
    AND?: UserAccountScalarWhereInput | UserAccountScalarWhereInput[]
    OR?: UserAccountScalarWhereInput[]
    NOT?: UserAccountScalarWhereInput | UserAccountScalarWhereInput[]
    user_id?: StringFilter<"UserAccount"> | string
    account_id?: StringFilter<"UserAccount"> | string
    role?: StringFilter<"UserAccount"> | string
    created_at?: DateTimeFilter<"UserAccount"> | Date | string
  }

  export type AccountUpsertWithoutChild_accountsInput = {
    update: XOR<AccountUpdateWithoutChild_accountsInput, AccountUncheckedUpdateWithoutChild_accountsInput>
    create: XOR<AccountCreateWithoutChild_accountsInput, AccountUncheckedCreateWithoutChild_accountsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutChild_accountsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutChild_accountsInput, AccountUncheckedUpdateWithoutChild_accountsInput>
  }

  export type AccountUpdateWithoutChild_accountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUpdateOneWithoutAccountNestedInput
    contact_info?: AccountContactInfoUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUpdateManyWithoutAccountNestedInput
    billings?: BillingUpdateManyWithoutAccountNestedInput
    clients?: ClientUpdateManyWithoutAccountNestedInput
    services?: ServiceUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUpdateManyWithoutAccountNestedInput
    users?: UserAccountUpdateManyWithoutAccountNestedInput
    parent_account?: AccountUpdateOneWithoutChild_accountsNestedInput
  }

  export type AccountUncheckedUpdateWithoutChild_accountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    parent_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUncheckedUpdateOneWithoutAccountNestedInput
    contact_info?: AccountContactInfoUncheckedUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUncheckedUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUncheckedUpdateManyWithoutAccountNestedInput
    billings?: BillingUncheckedUpdateManyWithoutAccountNestedInput
    clients?: ClientUncheckedUpdateManyWithoutAccountNestedInput
    services?: ServiceUncheckedUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUncheckedUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUncheckedUpdateManyWithoutAccountNestedInput
    users?: UserAccountUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUpsertWithWhereUniqueWithoutParent_accountInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutParent_accountInput, AccountUncheckedUpdateWithoutParent_accountInput>
    create: XOR<AccountCreateWithoutParent_accountInput, AccountUncheckedCreateWithoutParent_accountInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutParent_accountInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutParent_accountInput, AccountUncheckedUpdateWithoutParent_accountInput>
  }

  export type AccountUpdateManyWithWhereWithoutParent_accountInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutParent_accountInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    legal_name?: StringFilter<"Account"> | string
    created_at?: DateTimeFilter<"Account"> | Date | string
    created_by?: StringNullableFilter<"Account"> | string | null
    updated_at?: DateTimeFilter<"Account"> | Date | string
    updated_by?: StringNullableFilter<"Account"> | string | null
    parent_account_id?: StringNullableFilter<"Account"> | string | null
  }

  export type AccountCreateWithoutGeneral_infoInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    contact_info?: AccountContactInfoCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountCreateNestedManyWithoutAccountInput
    billings?: BillingCreateNestedManyWithoutAccountInput
    clients?: ClientCreateNestedManyWithoutAccountInput
    services?: ServiceCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateCreateNestedManyWithoutAccountInput
    users?: UserAccountCreateNestedManyWithoutAccountInput
    parent_account?: AccountCreateNestedOneWithoutChild_accountsInput
    child_accounts?: AccountCreateNestedManyWithoutParent_accountInput
  }

  export type AccountUncheckedCreateWithoutGeneral_infoInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    parent_account_id?: string | null
    contact_info?: AccountContactInfoUncheckedCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceUncheckedCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountUncheckedCreateNestedManyWithoutAccountInput
    billings?: BillingUncheckedCreateNestedManyWithoutAccountInput
    clients?: ClientUncheckedCreateNestedManyWithoutAccountInput
    services?: ServiceUncheckedCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureUncheckedCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateUncheckedCreateNestedManyWithoutAccountInput
    users?: UserAccountUncheckedCreateNestedManyWithoutAccountInput
    child_accounts?: AccountUncheckedCreateNestedManyWithoutParent_accountInput
  }

  export type AccountCreateOrConnectWithoutGeneral_infoInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutGeneral_infoInput, AccountUncheckedCreateWithoutGeneral_infoInput>
  }

  export type AccountUpsertWithoutGeneral_infoInput = {
    update: XOR<AccountUpdateWithoutGeneral_infoInput, AccountUncheckedUpdateWithoutGeneral_infoInput>
    create: XOR<AccountCreateWithoutGeneral_infoInput, AccountUncheckedCreateWithoutGeneral_infoInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutGeneral_infoInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutGeneral_infoInput, AccountUncheckedUpdateWithoutGeneral_infoInput>
  }

  export type AccountUpdateWithoutGeneral_infoInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    contact_info?: AccountContactInfoUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUpdateManyWithoutAccountNestedInput
    billings?: BillingUpdateManyWithoutAccountNestedInput
    clients?: ClientUpdateManyWithoutAccountNestedInput
    services?: ServiceUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUpdateManyWithoutAccountNestedInput
    users?: UserAccountUpdateManyWithoutAccountNestedInput
    parent_account?: AccountUpdateOneWithoutChild_accountsNestedInput
    child_accounts?: AccountUpdateManyWithoutParent_accountNestedInput
  }

  export type AccountUncheckedUpdateWithoutGeneral_infoInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    parent_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    contact_info?: AccountContactInfoUncheckedUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUncheckedUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUncheckedUpdateManyWithoutAccountNestedInput
    billings?: BillingUncheckedUpdateManyWithoutAccountNestedInput
    clients?: ClientUncheckedUpdateManyWithoutAccountNestedInput
    services?: ServiceUncheckedUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUncheckedUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUncheckedUpdateManyWithoutAccountNestedInput
    users?: UserAccountUncheckedUpdateManyWithoutAccountNestedInput
    child_accounts?: AccountUncheckedUpdateManyWithoutParent_accountNestedInput
  }

  export type AccountCreateWithoutContact_infoInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    general_info?: AccountGeneralInfoCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountCreateNestedManyWithoutAccountInput
    billings?: BillingCreateNestedManyWithoutAccountInput
    clients?: ClientCreateNestedManyWithoutAccountInput
    services?: ServiceCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateCreateNestedManyWithoutAccountInput
    users?: UserAccountCreateNestedManyWithoutAccountInput
    parent_account?: AccountCreateNestedOneWithoutChild_accountsInput
    child_accounts?: AccountCreateNestedManyWithoutParent_accountInput
  }

  export type AccountUncheckedCreateWithoutContact_infoInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    parent_account_id?: string | null
    general_info?: AccountGeneralInfoUncheckedCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceUncheckedCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountUncheckedCreateNestedManyWithoutAccountInput
    billings?: BillingUncheckedCreateNestedManyWithoutAccountInput
    clients?: ClientUncheckedCreateNestedManyWithoutAccountInput
    services?: ServiceUncheckedCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureUncheckedCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateUncheckedCreateNestedManyWithoutAccountInput
    users?: UserAccountUncheckedCreateNestedManyWithoutAccountInput
    child_accounts?: AccountUncheckedCreateNestedManyWithoutParent_accountInput
  }

  export type AccountCreateOrConnectWithoutContact_infoInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutContact_infoInput, AccountUncheckedCreateWithoutContact_infoInput>
  }

  export type AccountUpsertWithoutContact_infoInput = {
    update: XOR<AccountUpdateWithoutContact_infoInput, AccountUncheckedUpdateWithoutContact_infoInput>
    create: XOR<AccountCreateWithoutContact_infoInput, AccountUncheckedCreateWithoutContact_infoInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutContact_infoInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutContact_infoInput, AccountUncheckedUpdateWithoutContact_infoInput>
  }

  export type AccountUpdateWithoutContact_infoInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUpdateManyWithoutAccountNestedInput
    billings?: BillingUpdateManyWithoutAccountNestedInput
    clients?: ClientUpdateManyWithoutAccountNestedInput
    services?: ServiceUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUpdateManyWithoutAccountNestedInput
    users?: UserAccountUpdateManyWithoutAccountNestedInput
    parent_account?: AccountUpdateOneWithoutChild_accountsNestedInput
    child_accounts?: AccountUpdateManyWithoutParent_accountNestedInput
  }

  export type AccountUncheckedUpdateWithoutContact_infoInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    parent_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUncheckedUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUncheckedUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUncheckedUpdateManyWithoutAccountNestedInput
    billings?: BillingUncheckedUpdateManyWithoutAccountNestedInput
    clients?: ClientUncheckedUpdateManyWithoutAccountNestedInput
    services?: ServiceUncheckedUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUncheckedUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUncheckedUpdateManyWithoutAccountNestedInput
    users?: UserAccountUncheckedUpdateManyWithoutAccountNestedInput
    child_accounts?: AccountUncheckedUpdateManyWithoutParent_accountNestedInput
  }

  export type AccountCreateWithoutCompliance_infoInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    general_info?: AccountGeneralInfoCreateNestedOneWithoutAccountInput
    contact_info?: AccountContactInfoCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountCreateNestedManyWithoutAccountInput
    billings?: BillingCreateNestedManyWithoutAccountInput
    clients?: ClientCreateNestedManyWithoutAccountInput
    services?: ServiceCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateCreateNestedManyWithoutAccountInput
    users?: UserAccountCreateNestedManyWithoutAccountInput
    parent_account?: AccountCreateNestedOneWithoutChild_accountsInput
    child_accounts?: AccountCreateNestedManyWithoutParent_accountInput
  }

  export type AccountUncheckedCreateWithoutCompliance_infoInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    parent_account_id?: string | null
    general_info?: AccountGeneralInfoUncheckedCreateNestedOneWithoutAccountInput
    contact_info?: AccountContactInfoUncheckedCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountUncheckedCreateNestedManyWithoutAccountInput
    billings?: BillingUncheckedCreateNestedManyWithoutAccountInput
    clients?: ClientUncheckedCreateNestedManyWithoutAccountInput
    services?: ServiceUncheckedCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureUncheckedCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateUncheckedCreateNestedManyWithoutAccountInput
    users?: UserAccountUncheckedCreateNestedManyWithoutAccountInput
    child_accounts?: AccountUncheckedCreateNestedManyWithoutParent_accountInput
  }

  export type AccountCreateOrConnectWithoutCompliance_infoInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCompliance_infoInput, AccountUncheckedCreateWithoutCompliance_infoInput>
  }

  export type AccountUpsertWithoutCompliance_infoInput = {
    update: XOR<AccountUpdateWithoutCompliance_infoInput, AccountUncheckedUpdateWithoutCompliance_infoInput>
    create: XOR<AccountCreateWithoutCompliance_infoInput, AccountUncheckedCreateWithoutCompliance_infoInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutCompliance_infoInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutCompliance_infoInput, AccountUncheckedUpdateWithoutCompliance_infoInput>
  }

  export type AccountUpdateWithoutCompliance_infoInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUpdateOneWithoutAccountNestedInput
    contact_info?: AccountContactInfoUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUpdateManyWithoutAccountNestedInput
    billings?: BillingUpdateManyWithoutAccountNestedInput
    clients?: ClientUpdateManyWithoutAccountNestedInput
    services?: ServiceUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUpdateManyWithoutAccountNestedInput
    users?: UserAccountUpdateManyWithoutAccountNestedInput
    parent_account?: AccountUpdateOneWithoutChild_accountsNestedInput
    child_accounts?: AccountUpdateManyWithoutParent_accountNestedInput
  }

  export type AccountUncheckedUpdateWithoutCompliance_infoInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    parent_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUncheckedUpdateOneWithoutAccountNestedInput
    contact_info?: AccountContactInfoUncheckedUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUncheckedUpdateManyWithoutAccountNestedInput
    billings?: BillingUncheckedUpdateManyWithoutAccountNestedInput
    clients?: ClientUncheckedUpdateManyWithoutAccountNestedInput
    services?: ServiceUncheckedUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUncheckedUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUncheckedUpdateManyWithoutAccountNestedInput
    users?: UserAccountUncheckedUpdateManyWithoutAccountNestedInput
    child_accounts?: AccountUncheckedUpdateManyWithoutParent_accountNestedInput
  }

  export type AccountCreateWithoutUsersInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    general_info?: AccountGeneralInfoCreateNestedOneWithoutAccountInput
    contact_info?: AccountContactInfoCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountCreateNestedManyWithoutAccountInput
    billings?: BillingCreateNestedManyWithoutAccountInput
    clients?: ClientCreateNestedManyWithoutAccountInput
    services?: ServiceCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateCreateNestedManyWithoutAccountInput
    parent_account?: AccountCreateNestedOneWithoutChild_accountsInput
    child_accounts?: AccountCreateNestedManyWithoutParent_accountInput
  }

  export type AccountUncheckedCreateWithoutUsersInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    parent_account_id?: string | null
    general_info?: AccountGeneralInfoUncheckedCreateNestedOneWithoutAccountInput
    contact_info?: AccountContactInfoUncheckedCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceUncheckedCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountUncheckedCreateNestedManyWithoutAccountInput
    billings?: BillingUncheckedCreateNestedManyWithoutAccountInput
    clients?: ClientUncheckedCreateNestedManyWithoutAccountInput
    services?: ServiceUncheckedCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureUncheckedCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateUncheckedCreateNestedManyWithoutAccountInput
    child_accounts?: AccountUncheckedCreateNestedManyWithoutParent_accountInput
  }

  export type AccountCreateOrConnectWithoutUsersInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUsersInput, AccountUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutAccountsInput = {
    id: string
    email: string
    password_hash: string
    name?: string | null
    created_at?: Date | string
    updated_at: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    accountsAuth?: AccountAuthCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id: string
    email: string
    password_hash: string
    name?: string | null
    created_at?: Date | string
    updated_at: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    accountsAuth?: AccountAuthUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type AccountUpsertWithoutUsersInput = {
    update: XOR<AccountUpdateWithoutUsersInput, AccountUncheckedUpdateWithoutUsersInput>
    create: XOR<AccountCreateWithoutUsersInput, AccountUncheckedCreateWithoutUsersInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutUsersInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutUsersInput, AccountUncheckedUpdateWithoutUsersInput>
  }

  export type AccountUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUpdateOneWithoutAccountNestedInput
    contact_info?: AccountContactInfoUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUpdateManyWithoutAccountNestedInput
    billings?: BillingUpdateManyWithoutAccountNestedInput
    clients?: ClientUpdateManyWithoutAccountNestedInput
    services?: ServiceUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUpdateManyWithoutAccountNestedInput
    parent_account?: AccountUpdateOneWithoutChild_accountsNestedInput
    child_accounts?: AccountUpdateManyWithoutParent_accountNestedInput
  }

  export type AccountUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    parent_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUncheckedUpdateOneWithoutAccountNestedInput
    contact_info?: AccountContactInfoUncheckedUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUncheckedUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUncheckedUpdateManyWithoutAccountNestedInput
    billings?: BillingUncheckedUpdateManyWithoutAccountNestedInput
    clients?: ClientUncheckedUpdateManyWithoutAccountNestedInput
    services?: ServiceUncheckedUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUncheckedUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUncheckedUpdateManyWithoutAccountNestedInput
    child_accounts?: AccountUncheckedUpdateManyWithoutParent_accountNestedInput
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    accountsAuth?: AccountAuthUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    accountsAuth?: AccountAuthUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountsAuthInput = {
    id: string
    email: string
    password_hash: string
    name?: string | null
    created_at?: Date | string
    updated_at: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    accounts?: UserAccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsAuthInput = {
    id: string
    email: string
    password_hash: string
    name?: string | null
    created_at?: Date | string
    updated_at: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: UserAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsAuthInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsAuthInput, UserUncheckedCreateWithoutAccountsAuthInput>
  }

  export type UserUpsertWithoutAccountsAuthInput = {
    update: XOR<UserUpdateWithoutAccountsAuthInput, UserUncheckedUpdateWithoutAccountsAuthInput>
    create: XOR<UserCreateWithoutAccountsAuthInput, UserUncheckedCreateWithoutAccountsAuthInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsAuthInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsAuthInput, UserUncheckedUpdateWithoutAccountsAuthInput>
  }

  export type UserUpdateWithoutAccountsAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    accounts?: UserAccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: UserAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id: string
    email: string
    password_hash: string
    name?: string | null
    created_at?: Date | string
    updated_at: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    accounts?: UserAccountCreateNestedManyWithoutUserInput
    accountsAuth?: AccountAuthCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id: string
    email: string
    password_hash: string
    name?: string | null
    created_at?: Date | string
    updated_at: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: UserAccountUncheckedCreateNestedManyWithoutUserInput
    accountsAuth?: AccountAuthUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    accounts?: UserAccountUpdateManyWithoutUserNestedInput
    accountsAuth?: AccountAuthUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: UserAccountUncheckedUpdateManyWithoutUserNestedInput
    accountsAuth?: AccountAuthUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutProfileInput = {
    id: string
    email: string
    password_hash: string
    name?: string | null
    created_at?: Date | string
    updated_at: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    accounts?: UserAccountCreateNestedManyWithoutUserInput
    accountsAuth?: AccountAuthCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id: string
    email: string
    password_hash: string
    name?: string | null
    created_at?: Date | string
    updated_at: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    reset_token?: string | null
    reset_token_expires?: Date | string | null
    accounts?: UserAccountUncheckedCreateNestedManyWithoutUserInput
    accountsAuth?: AccountAuthUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type ProfileEmailCreateWithoutProfileInput = {
    id?: string
    email: string
    type: string
    isPrimary?: boolean
    isVerified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProfileEmailUncheckedCreateWithoutProfileInput = {
    id?: string
    email: string
    type: string
    isPrimary?: boolean
    isVerified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProfileEmailCreateOrConnectWithoutProfileInput = {
    where: ProfileEmailWhereUniqueInput
    create: XOR<ProfileEmailCreateWithoutProfileInput, ProfileEmailUncheckedCreateWithoutProfileInput>
  }

  export type ProfileEmailCreateManyProfileInputEnvelope = {
    data: ProfileEmailCreateManyProfileInput | ProfileEmailCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type ProfilePhoneCreateWithoutProfileInput = {
    id?: string
    phoneNumber: string
    type: string
    isPrimary?: boolean
    isVerified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProfilePhoneUncheckedCreateWithoutProfileInput = {
    id?: string
    phoneNumber: string
    type: string
    isPrimary?: boolean
    isVerified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProfilePhoneCreateOrConnectWithoutProfileInput = {
    where: ProfilePhoneWhereUniqueInput
    create: XOR<ProfilePhoneCreateWithoutProfileInput, ProfilePhoneUncheckedCreateWithoutProfileInput>
  }

  export type ProfilePhoneCreateManyProfileInputEnvelope = {
    data: ProfilePhoneCreateManyProfileInput | ProfilePhoneCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: UserAccountUpdateManyWithoutUserNestedInput
    accountsAuth?: AccountAuthUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: UserAccountUncheckedUpdateManyWithoutUserNestedInput
    accountsAuth?: AccountAuthUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProfileEmailUpsertWithWhereUniqueWithoutProfileInput = {
    where: ProfileEmailWhereUniqueInput
    update: XOR<ProfileEmailUpdateWithoutProfileInput, ProfileEmailUncheckedUpdateWithoutProfileInput>
    create: XOR<ProfileEmailCreateWithoutProfileInput, ProfileEmailUncheckedCreateWithoutProfileInput>
  }

  export type ProfileEmailUpdateWithWhereUniqueWithoutProfileInput = {
    where: ProfileEmailWhereUniqueInput
    data: XOR<ProfileEmailUpdateWithoutProfileInput, ProfileEmailUncheckedUpdateWithoutProfileInput>
  }

  export type ProfileEmailUpdateManyWithWhereWithoutProfileInput = {
    where: ProfileEmailScalarWhereInput
    data: XOR<ProfileEmailUpdateManyMutationInput, ProfileEmailUncheckedUpdateManyWithoutProfileInput>
  }

  export type ProfileEmailScalarWhereInput = {
    AND?: ProfileEmailScalarWhereInput | ProfileEmailScalarWhereInput[]
    OR?: ProfileEmailScalarWhereInput[]
    NOT?: ProfileEmailScalarWhereInput | ProfileEmailScalarWhereInput[]
    id?: StringFilter<"ProfileEmail"> | string
    profileId?: StringFilter<"ProfileEmail"> | string
    email?: StringFilter<"ProfileEmail"> | string
    type?: StringFilter<"ProfileEmail"> | string
    isPrimary?: BoolFilter<"ProfileEmail"> | boolean
    isVerified?: BoolFilter<"ProfileEmail"> | boolean
    created_at?: DateTimeFilter<"ProfileEmail"> | Date | string
    updated_at?: DateTimeFilter<"ProfileEmail"> | Date | string
  }

  export type ProfilePhoneUpsertWithWhereUniqueWithoutProfileInput = {
    where: ProfilePhoneWhereUniqueInput
    update: XOR<ProfilePhoneUpdateWithoutProfileInput, ProfilePhoneUncheckedUpdateWithoutProfileInput>
    create: XOR<ProfilePhoneCreateWithoutProfileInput, ProfilePhoneUncheckedCreateWithoutProfileInput>
  }

  export type ProfilePhoneUpdateWithWhereUniqueWithoutProfileInput = {
    where: ProfilePhoneWhereUniqueInput
    data: XOR<ProfilePhoneUpdateWithoutProfileInput, ProfilePhoneUncheckedUpdateWithoutProfileInput>
  }

  export type ProfilePhoneUpdateManyWithWhereWithoutProfileInput = {
    where: ProfilePhoneScalarWhereInput
    data: XOR<ProfilePhoneUpdateManyMutationInput, ProfilePhoneUncheckedUpdateManyWithoutProfileInput>
  }

  export type ProfilePhoneScalarWhereInput = {
    AND?: ProfilePhoneScalarWhereInput | ProfilePhoneScalarWhereInput[]
    OR?: ProfilePhoneScalarWhereInput[]
    NOT?: ProfilePhoneScalarWhereInput | ProfilePhoneScalarWhereInput[]
    id?: StringFilter<"ProfilePhone"> | string
    profileId?: StringFilter<"ProfilePhone"> | string
    phoneNumber?: StringFilter<"ProfilePhone"> | string
    type?: StringFilter<"ProfilePhone"> | string
    isPrimary?: BoolFilter<"ProfilePhone"> | boolean
    isVerified?: BoolFilter<"ProfilePhone"> | boolean
    created_at?: DateTimeFilter<"ProfilePhone"> | Date | string
    updated_at?: DateTimeFilter<"ProfilePhone"> | Date | string
  }

  export type ProfileCreateWithoutEmailsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    displayName?: string | null
    bio?: string | null
    jobTitle?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    language?: string | null
    timezone?: string | null
    website?: string | null
    linkedin?: string | null
    twitter?: string | null
    facebook?: string | null
    instagram?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
    phones?: ProfilePhoneCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutEmailsInput = {
    id?: string
    userId: string
    firstName?: string | null
    lastName?: string | null
    displayName?: string | null
    bio?: string | null
    jobTitle?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    language?: string | null
    timezone?: string | null
    website?: string | null
    linkedin?: string | null
    twitter?: string | null
    facebook?: string | null
    instagram?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    phones?: ProfilePhoneUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutEmailsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutEmailsInput, ProfileUncheckedCreateWithoutEmailsInput>
  }

  export type ProfileUpsertWithoutEmailsInput = {
    update: XOR<ProfileUpdateWithoutEmailsInput, ProfileUncheckedUpdateWithoutEmailsInput>
    create: XOR<ProfileCreateWithoutEmailsInput, ProfileUncheckedCreateWithoutEmailsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutEmailsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutEmailsInput, ProfileUncheckedUpdateWithoutEmailsInput>
  }

  export type ProfileUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    phones?: ProfilePhoneUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: ProfilePhoneUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileCreateWithoutPhonesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    displayName?: string | null
    bio?: string | null
    jobTitle?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    language?: string | null
    timezone?: string | null
    website?: string | null
    linkedin?: string | null
    twitter?: string | null
    facebook?: string | null
    instagram?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
    emails?: ProfileEmailCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutPhonesInput = {
    id?: string
    userId: string
    firstName?: string | null
    lastName?: string | null
    displayName?: string | null
    bio?: string | null
    jobTitle?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    language?: string | null
    timezone?: string | null
    website?: string | null
    linkedin?: string | null
    twitter?: string | null
    facebook?: string | null
    instagram?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    emails?: ProfileEmailUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutPhonesInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutPhonesInput, ProfileUncheckedCreateWithoutPhonesInput>
  }

  export type ProfileUpsertWithoutPhonesInput = {
    update: XOR<ProfileUpdateWithoutPhonesInput, ProfileUncheckedUpdateWithoutPhonesInput>
    create: XOR<ProfileCreateWithoutPhonesInput, ProfileUncheckedCreateWithoutPhonesInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutPhonesInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutPhonesInput, ProfileUncheckedUpdateWithoutPhonesInput>
  }

  export type ProfileUpdateWithoutPhonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    emails?: ProfileEmailUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutPhonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    emails?: ProfileEmailUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type AccountCreateWithoutClientsInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    general_info?: AccountGeneralInfoCreateNestedOneWithoutAccountInput
    contact_info?: AccountContactInfoCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountCreateNestedManyWithoutAccountInput
    billings?: BillingCreateNestedManyWithoutAccountInput
    services?: ServiceCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateCreateNestedManyWithoutAccountInput
    users?: UserAccountCreateNestedManyWithoutAccountInput
    parent_account?: AccountCreateNestedOneWithoutChild_accountsInput
    child_accounts?: AccountCreateNestedManyWithoutParent_accountInput
  }

  export type AccountUncheckedCreateWithoutClientsInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    parent_account_id?: string | null
    general_info?: AccountGeneralInfoUncheckedCreateNestedOneWithoutAccountInput
    contact_info?: AccountContactInfoUncheckedCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceUncheckedCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountUncheckedCreateNestedManyWithoutAccountInput
    billings?: BillingUncheckedCreateNestedManyWithoutAccountInput
    services?: ServiceUncheckedCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureUncheckedCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateUncheckedCreateNestedManyWithoutAccountInput
    users?: UserAccountUncheckedCreateNestedManyWithoutAccountInput
    child_accounts?: AccountUncheckedCreateNestedManyWithoutParent_accountInput
  }

  export type AccountCreateOrConnectWithoutClientsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutClientsInput, AccountUncheckedCreateWithoutClientsInput>
  }

  export type BillingCreateWithoutClientInput = {
    id?: string
    billing_date?: Date | string
    due_date?: Date | string | null
    invoice_number: string
    invoice_prefix?: string
    invoice_sequence: number
    billing_address: string
    subtotal_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string
    discount_amount?: Decimal | DecimalJsLike | number | string
    total_amount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    status?: $Enums.BillingStatus
    cancellation_date?: Date | string | null
    cancellation_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    account: AccountCreateNestedOneWithoutBillingsInput
    clientCompany?: ClientCompanyCreateNestedOneWithoutBillingsInput
    items?: BillingItemCreateNestedManyWithoutBillingInput
  }

  export type BillingUncheckedCreateWithoutClientInput = {
    id?: string
    account_id: string
    client_company_id?: string | null
    billing_date?: Date | string
    due_date?: Date | string | null
    invoice_number: string
    invoice_prefix?: string
    invoice_sequence: number
    billing_address: string
    subtotal_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string
    discount_amount?: Decimal | DecimalJsLike | number | string
    total_amount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    status?: $Enums.BillingStatus
    cancellation_date?: Date | string | null
    cancellation_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    items?: BillingItemUncheckedCreateNestedManyWithoutBillingInput
  }

  export type BillingCreateOrConnectWithoutClientInput = {
    where: BillingWhereUniqueInput
    create: XOR<BillingCreateWithoutClientInput, BillingUncheckedCreateWithoutClientInput>
  }

  export type BillingCreateManyClientInputEnvelope = {
    data: BillingCreateManyClientInput | BillingCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ClientPhoneCreateWithoutClientInput = {
    id?: string
    phone_number: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientPhoneUncheckedCreateWithoutClientInput = {
    id?: string
    phone_number: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientPhoneCreateOrConnectWithoutClientInput = {
    where: ClientPhoneWhereUniqueInput
    create: XOR<ClientPhoneCreateWithoutClientInput, ClientPhoneUncheckedCreateWithoutClientInput>
  }

  export type ClientPhoneCreateManyClientInputEnvelope = {
    data: ClientPhoneCreateManyClientInput | ClientPhoneCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ClientEmailCreateWithoutClientInput = {
    id?: string
    email: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientEmailUncheckedCreateWithoutClientInput = {
    id?: string
    email: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientEmailCreateOrConnectWithoutClientInput = {
    where: ClientEmailWhereUniqueInput
    create: XOR<ClientEmailCreateWithoutClientInput, ClientEmailUncheckedCreateWithoutClientInput>
  }

  export type ClientEmailCreateManyClientInputEnvelope = {
    data: ClientEmailCreateManyClientInput | ClientEmailCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ClientAddressCreateWithoutClientInput = {
    id?: string
    type: string
    street: string
    suite?: string | null
    city: string
    state: string
    zip_code: string
    country?: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientAddressUncheckedCreateWithoutClientInput = {
    id?: string
    type: string
    street: string
    suite?: string | null
    city: string
    state: string
    zip_code: string
    country?: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientAddressCreateOrConnectWithoutClientInput = {
    where: ClientAddressWhereUniqueInput
    create: XOR<ClientAddressCreateWithoutClientInput, ClientAddressUncheckedCreateWithoutClientInput>
  }

  export type ClientAddressCreateManyClientInputEnvelope = {
    data: ClientAddressCreateManyClientInput | ClientAddressCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ClientCompanyCreateWithoutClientInput = {
    id?: string
    name: string
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    phones?: ClientCompanyPhoneCreateNestedManyWithoutCompanyInput
    emails?: ClientCompanyEmailCreateNestedManyWithoutCompanyInput
    addresses?: ClientCompanyAddressCreateNestedManyWithoutCompanyInput
    billings?: BillingCreateNestedManyWithoutClientCompanyInput
  }

  export type ClientCompanyUncheckedCreateWithoutClientInput = {
    id?: string
    name: string
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    phones?: ClientCompanyPhoneUncheckedCreateNestedManyWithoutCompanyInput
    emails?: ClientCompanyEmailUncheckedCreateNestedManyWithoutCompanyInput
    addresses?: ClientCompanyAddressUncheckedCreateNestedManyWithoutCompanyInput
    billings?: BillingUncheckedCreateNestedManyWithoutClientCompanyInput
  }

  export type ClientCompanyCreateOrConnectWithoutClientInput = {
    where: ClientCompanyWhereUniqueInput
    create: XOR<ClientCompanyCreateWithoutClientInput, ClientCompanyUncheckedCreateWithoutClientInput>
  }

  export type ClientCompanyCreateManyClientInputEnvelope = {
    data: ClientCompanyCreateManyClientInput | ClientCompanyCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutClientsInput = {
    update: XOR<AccountUpdateWithoutClientsInput, AccountUncheckedUpdateWithoutClientsInput>
    create: XOR<AccountCreateWithoutClientsInput, AccountUncheckedCreateWithoutClientsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutClientsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutClientsInput, AccountUncheckedUpdateWithoutClientsInput>
  }

  export type AccountUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUpdateOneWithoutAccountNestedInput
    contact_info?: AccountContactInfoUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUpdateManyWithoutAccountNestedInput
    billings?: BillingUpdateManyWithoutAccountNestedInput
    services?: ServiceUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUpdateManyWithoutAccountNestedInput
    users?: UserAccountUpdateManyWithoutAccountNestedInput
    parent_account?: AccountUpdateOneWithoutChild_accountsNestedInput
    child_accounts?: AccountUpdateManyWithoutParent_accountNestedInput
  }

  export type AccountUncheckedUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    parent_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUncheckedUpdateOneWithoutAccountNestedInput
    contact_info?: AccountContactInfoUncheckedUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUncheckedUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUncheckedUpdateManyWithoutAccountNestedInput
    billings?: BillingUncheckedUpdateManyWithoutAccountNestedInput
    services?: ServiceUncheckedUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUncheckedUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUncheckedUpdateManyWithoutAccountNestedInput
    users?: UserAccountUncheckedUpdateManyWithoutAccountNestedInput
    child_accounts?: AccountUncheckedUpdateManyWithoutParent_accountNestedInput
  }

  export type BillingUpsertWithWhereUniqueWithoutClientInput = {
    where: BillingWhereUniqueInput
    update: XOR<BillingUpdateWithoutClientInput, BillingUncheckedUpdateWithoutClientInput>
    create: XOR<BillingCreateWithoutClientInput, BillingUncheckedCreateWithoutClientInput>
  }

  export type BillingUpdateWithWhereUniqueWithoutClientInput = {
    where: BillingWhereUniqueInput
    data: XOR<BillingUpdateWithoutClientInput, BillingUncheckedUpdateWithoutClientInput>
  }

  export type BillingUpdateManyWithWhereWithoutClientInput = {
    where: BillingScalarWhereInput
    data: XOR<BillingUpdateManyMutationInput, BillingUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientPhoneUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientPhoneWhereUniqueInput
    update: XOR<ClientPhoneUpdateWithoutClientInput, ClientPhoneUncheckedUpdateWithoutClientInput>
    create: XOR<ClientPhoneCreateWithoutClientInput, ClientPhoneUncheckedCreateWithoutClientInput>
  }

  export type ClientPhoneUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientPhoneWhereUniqueInput
    data: XOR<ClientPhoneUpdateWithoutClientInput, ClientPhoneUncheckedUpdateWithoutClientInput>
  }

  export type ClientPhoneUpdateManyWithWhereWithoutClientInput = {
    where: ClientPhoneScalarWhereInput
    data: XOR<ClientPhoneUpdateManyMutationInput, ClientPhoneUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientPhoneScalarWhereInput = {
    AND?: ClientPhoneScalarWhereInput | ClientPhoneScalarWhereInput[]
    OR?: ClientPhoneScalarWhereInput[]
    NOT?: ClientPhoneScalarWhereInput | ClientPhoneScalarWhereInput[]
    id?: StringFilter<"ClientPhone"> | string
    client_id?: StringFilter<"ClientPhone"> | string
    phone_number?: StringFilter<"ClientPhone"> | string
    type?: StringFilter<"ClientPhone"> | string
    is_primary?: BoolFilter<"ClientPhone"> | boolean
    created_at?: DateTimeFilter<"ClientPhone"> | Date | string
    updated_at?: DateTimeFilter<"ClientPhone"> | Date | string
  }

  export type ClientEmailUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientEmailWhereUniqueInput
    update: XOR<ClientEmailUpdateWithoutClientInput, ClientEmailUncheckedUpdateWithoutClientInput>
    create: XOR<ClientEmailCreateWithoutClientInput, ClientEmailUncheckedCreateWithoutClientInput>
  }

  export type ClientEmailUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientEmailWhereUniqueInput
    data: XOR<ClientEmailUpdateWithoutClientInput, ClientEmailUncheckedUpdateWithoutClientInput>
  }

  export type ClientEmailUpdateManyWithWhereWithoutClientInput = {
    where: ClientEmailScalarWhereInput
    data: XOR<ClientEmailUpdateManyMutationInput, ClientEmailUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientEmailScalarWhereInput = {
    AND?: ClientEmailScalarWhereInput | ClientEmailScalarWhereInput[]
    OR?: ClientEmailScalarWhereInput[]
    NOT?: ClientEmailScalarWhereInput | ClientEmailScalarWhereInput[]
    id?: StringFilter<"ClientEmail"> | string
    client_id?: StringFilter<"ClientEmail"> | string
    email?: StringFilter<"ClientEmail"> | string
    type?: StringFilter<"ClientEmail"> | string
    is_primary?: BoolFilter<"ClientEmail"> | boolean
    created_at?: DateTimeFilter<"ClientEmail"> | Date | string
    updated_at?: DateTimeFilter<"ClientEmail"> | Date | string
  }

  export type ClientAddressUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientAddressWhereUniqueInput
    update: XOR<ClientAddressUpdateWithoutClientInput, ClientAddressUncheckedUpdateWithoutClientInput>
    create: XOR<ClientAddressCreateWithoutClientInput, ClientAddressUncheckedCreateWithoutClientInput>
  }

  export type ClientAddressUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientAddressWhereUniqueInput
    data: XOR<ClientAddressUpdateWithoutClientInput, ClientAddressUncheckedUpdateWithoutClientInput>
  }

  export type ClientAddressUpdateManyWithWhereWithoutClientInput = {
    where: ClientAddressScalarWhereInput
    data: XOR<ClientAddressUpdateManyMutationInput, ClientAddressUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientAddressScalarWhereInput = {
    AND?: ClientAddressScalarWhereInput | ClientAddressScalarWhereInput[]
    OR?: ClientAddressScalarWhereInput[]
    NOT?: ClientAddressScalarWhereInput | ClientAddressScalarWhereInput[]
    id?: StringFilter<"ClientAddress"> | string
    client_id?: StringFilter<"ClientAddress"> | string
    type?: StringFilter<"ClientAddress"> | string
    street?: StringFilter<"ClientAddress"> | string
    suite?: StringNullableFilter<"ClientAddress"> | string | null
    city?: StringFilter<"ClientAddress"> | string
    state?: StringFilter<"ClientAddress"> | string
    zip_code?: StringFilter<"ClientAddress"> | string
    country?: StringFilter<"ClientAddress"> | string
    is_primary?: BoolFilter<"ClientAddress"> | boolean
    created_at?: DateTimeFilter<"ClientAddress"> | Date | string
    updated_at?: DateTimeFilter<"ClientAddress"> | Date | string
  }

  export type ClientCompanyUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientCompanyWhereUniqueInput
    update: XOR<ClientCompanyUpdateWithoutClientInput, ClientCompanyUncheckedUpdateWithoutClientInput>
    create: XOR<ClientCompanyCreateWithoutClientInput, ClientCompanyUncheckedCreateWithoutClientInput>
  }

  export type ClientCompanyUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientCompanyWhereUniqueInput
    data: XOR<ClientCompanyUpdateWithoutClientInput, ClientCompanyUncheckedUpdateWithoutClientInput>
  }

  export type ClientCompanyUpdateManyWithWhereWithoutClientInput = {
    where: ClientCompanyScalarWhereInput
    data: XOR<ClientCompanyUpdateManyMutationInput, ClientCompanyUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientCompanyScalarWhereInput = {
    AND?: ClientCompanyScalarWhereInput | ClientCompanyScalarWhereInput[]
    OR?: ClientCompanyScalarWhereInput[]
    NOT?: ClientCompanyScalarWhereInput | ClientCompanyScalarWhereInput[]
    id?: StringFilter<"ClientCompany"> | string
    client_id?: StringFilter<"ClientCompany"> | string
    name?: StringFilter<"ClientCompany"> | string
    tax_id?: StringNullableFilter<"ClientCompany"> | string | null
    website?: StringNullableFilter<"ClientCompany"> | string | null
    notes?: StringNullableFilter<"ClientCompany"> | string | null
    is_active?: BoolFilter<"ClientCompany"> | boolean
    created_at?: DateTimeFilter<"ClientCompany"> | Date | string
    updated_at?: DateTimeFilter<"ClientCompany"> | Date | string
  }

  export type ClientCreateWithoutPhonesInput = {
    id?: string
    client_type?: $Enums.ClientType
    name: string
    company_name?: string | null
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    account: AccountCreateNestedOneWithoutClientsInput
    billings?: BillingCreateNestedManyWithoutClientInput
    emails?: ClientEmailCreateNestedManyWithoutClientInput
    addresses?: ClientAddressCreateNestedManyWithoutClientInput
    ClientCompany?: ClientCompanyCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutPhonesInput = {
    id?: string
    account_id: string
    client_type?: $Enums.ClientType
    name: string
    company_name?: string | null
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billings?: BillingUncheckedCreateNestedManyWithoutClientInput
    emails?: ClientEmailUncheckedCreateNestedManyWithoutClientInput
    addresses?: ClientAddressUncheckedCreateNestedManyWithoutClientInput
    ClientCompany?: ClientCompanyUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutPhonesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutPhonesInput, ClientUncheckedCreateWithoutPhonesInput>
  }

  export type ClientUpsertWithoutPhonesInput = {
    update: XOR<ClientUpdateWithoutPhonesInput, ClientUncheckedUpdateWithoutPhonesInput>
    create: XOR<ClientCreateWithoutPhonesInput, ClientUncheckedCreateWithoutPhonesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutPhonesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutPhonesInput, ClientUncheckedUpdateWithoutPhonesInput>
  }

  export type ClientUpdateWithoutPhonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutClientsNestedInput
    billings?: BillingUpdateManyWithoutClientNestedInput
    emails?: ClientEmailUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUpdateManyWithoutClientNestedInput
    ClientCompany?: ClientCompanyUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutPhonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billings?: BillingUncheckedUpdateManyWithoutClientNestedInput
    emails?: ClientEmailUncheckedUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUncheckedUpdateManyWithoutClientNestedInput
    ClientCompany?: ClientCompanyUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateWithoutEmailsInput = {
    id?: string
    client_type?: $Enums.ClientType
    name: string
    company_name?: string | null
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    account: AccountCreateNestedOneWithoutClientsInput
    billings?: BillingCreateNestedManyWithoutClientInput
    phones?: ClientPhoneCreateNestedManyWithoutClientInput
    addresses?: ClientAddressCreateNestedManyWithoutClientInput
    ClientCompany?: ClientCompanyCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutEmailsInput = {
    id?: string
    account_id: string
    client_type?: $Enums.ClientType
    name: string
    company_name?: string | null
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billings?: BillingUncheckedCreateNestedManyWithoutClientInput
    phones?: ClientPhoneUncheckedCreateNestedManyWithoutClientInput
    addresses?: ClientAddressUncheckedCreateNestedManyWithoutClientInput
    ClientCompany?: ClientCompanyUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutEmailsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutEmailsInput, ClientUncheckedCreateWithoutEmailsInput>
  }

  export type ClientUpsertWithoutEmailsInput = {
    update: XOR<ClientUpdateWithoutEmailsInput, ClientUncheckedUpdateWithoutEmailsInput>
    create: XOR<ClientCreateWithoutEmailsInput, ClientUncheckedCreateWithoutEmailsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutEmailsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutEmailsInput, ClientUncheckedUpdateWithoutEmailsInput>
  }

  export type ClientUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutClientsNestedInput
    billings?: BillingUpdateManyWithoutClientNestedInput
    phones?: ClientPhoneUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUpdateManyWithoutClientNestedInput
    ClientCompany?: ClientCompanyUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billings?: BillingUncheckedUpdateManyWithoutClientNestedInput
    phones?: ClientPhoneUncheckedUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUncheckedUpdateManyWithoutClientNestedInput
    ClientCompany?: ClientCompanyUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateWithoutAddressesInput = {
    id?: string
    client_type?: $Enums.ClientType
    name: string
    company_name?: string | null
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    account: AccountCreateNestedOneWithoutClientsInput
    billings?: BillingCreateNestedManyWithoutClientInput
    phones?: ClientPhoneCreateNestedManyWithoutClientInput
    emails?: ClientEmailCreateNestedManyWithoutClientInput
    ClientCompany?: ClientCompanyCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutAddressesInput = {
    id?: string
    account_id: string
    client_type?: $Enums.ClientType
    name: string
    company_name?: string | null
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billings?: BillingUncheckedCreateNestedManyWithoutClientInput
    phones?: ClientPhoneUncheckedCreateNestedManyWithoutClientInput
    emails?: ClientEmailUncheckedCreateNestedManyWithoutClientInput
    ClientCompany?: ClientCompanyUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutAddressesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutAddressesInput, ClientUncheckedCreateWithoutAddressesInput>
  }

  export type ClientUpsertWithoutAddressesInput = {
    update: XOR<ClientUpdateWithoutAddressesInput, ClientUncheckedUpdateWithoutAddressesInput>
    create: XOR<ClientCreateWithoutAddressesInput, ClientUncheckedCreateWithoutAddressesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutAddressesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutAddressesInput, ClientUncheckedUpdateWithoutAddressesInput>
  }

  export type ClientUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutClientsNestedInput
    billings?: BillingUpdateManyWithoutClientNestedInput
    phones?: ClientPhoneUpdateManyWithoutClientNestedInput
    emails?: ClientEmailUpdateManyWithoutClientNestedInput
    ClientCompany?: ClientCompanyUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billings?: BillingUncheckedUpdateManyWithoutClientNestedInput
    phones?: ClientPhoneUncheckedUpdateManyWithoutClientNestedInput
    emails?: ClientEmailUncheckedUpdateManyWithoutClientNestedInput
    ClientCompany?: ClientCompanyUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateWithoutClientCompanyInput = {
    id?: string
    client_type?: $Enums.ClientType
    name: string
    company_name?: string | null
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    account: AccountCreateNestedOneWithoutClientsInput
    billings?: BillingCreateNestedManyWithoutClientInput
    phones?: ClientPhoneCreateNestedManyWithoutClientInput
    emails?: ClientEmailCreateNestedManyWithoutClientInput
    addresses?: ClientAddressCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutClientCompanyInput = {
    id?: string
    account_id: string
    client_type?: $Enums.ClientType
    name: string
    company_name?: string | null
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billings?: BillingUncheckedCreateNestedManyWithoutClientInput
    phones?: ClientPhoneUncheckedCreateNestedManyWithoutClientInput
    emails?: ClientEmailUncheckedCreateNestedManyWithoutClientInput
    addresses?: ClientAddressUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutClientCompanyInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutClientCompanyInput, ClientUncheckedCreateWithoutClientCompanyInput>
  }

  export type ClientCompanyPhoneCreateWithoutCompanyInput = {
    id?: string
    phone_number: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientCompanyPhoneUncheckedCreateWithoutCompanyInput = {
    id?: string
    phone_number: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientCompanyPhoneCreateOrConnectWithoutCompanyInput = {
    where: ClientCompanyPhoneWhereUniqueInput
    create: XOR<ClientCompanyPhoneCreateWithoutCompanyInput, ClientCompanyPhoneUncheckedCreateWithoutCompanyInput>
  }

  export type ClientCompanyPhoneCreateManyCompanyInputEnvelope = {
    data: ClientCompanyPhoneCreateManyCompanyInput | ClientCompanyPhoneCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ClientCompanyEmailCreateWithoutCompanyInput = {
    id?: string
    email: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientCompanyEmailUncheckedCreateWithoutCompanyInput = {
    id?: string
    email: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientCompanyEmailCreateOrConnectWithoutCompanyInput = {
    where: ClientCompanyEmailWhereUniqueInput
    create: XOR<ClientCompanyEmailCreateWithoutCompanyInput, ClientCompanyEmailUncheckedCreateWithoutCompanyInput>
  }

  export type ClientCompanyEmailCreateManyCompanyInputEnvelope = {
    data: ClientCompanyEmailCreateManyCompanyInput | ClientCompanyEmailCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ClientCompanyAddressCreateWithoutCompanyInput = {
    id?: string
    type: string
    street: string
    suite?: string | null
    city: string
    state: string
    zip_code: string
    country: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientCompanyAddressUncheckedCreateWithoutCompanyInput = {
    id?: string
    type: string
    street: string
    suite?: string | null
    city: string
    state: string
    zip_code: string
    country: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientCompanyAddressCreateOrConnectWithoutCompanyInput = {
    where: ClientCompanyAddressWhereUniqueInput
    create: XOR<ClientCompanyAddressCreateWithoutCompanyInput, ClientCompanyAddressUncheckedCreateWithoutCompanyInput>
  }

  export type ClientCompanyAddressCreateManyCompanyInputEnvelope = {
    data: ClientCompanyAddressCreateManyCompanyInput | ClientCompanyAddressCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type BillingCreateWithoutClientCompanyInput = {
    id?: string
    billing_date?: Date | string
    due_date?: Date | string | null
    invoice_number: string
    invoice_prefix?: string
    invoice_sequence: number
    billing_address: string
    subtotal_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string
    discount_amount?: Decimal | DecimalJsLike | number | string
    total_amount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    status?: $Enums.BillingStatus
    cancellation_date?: Date | string | null
    cancellation_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    account: AccountCreateNestedOneWithoutBillingsInput
    client: ClientCreateNestedOneWithoutBillingsInput
    items?: BillingItemCreateNestedManyWithoutBillingInput
  }

  export type BillingUncheckedCreateWithoutClientCompanyInput = {
    id?: string
    account_id: string
    client_id: string
    billing_date?: Date | string
    due_date?: Date | string | null
    invoice_number: string
    invoice_prefix?: string
    invoice_sequence: number
    billing_address: string
    subtotal_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string
    discount_amount?: Decimal | DecimalJsLike | number | string
    total_amount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    status?: $Enums.BillingStatus
    cancellation_date?: Date | string | null
    cancellation_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    items?: BillingItemUncheckedCreateNestedManyWithoutBillingInput
  }

  export type BillingCreateOrConnectWithoutClientCompanyInput = {
    where: BillingWhereUniqueInput
    create: XOR<BillingCreateWithoutClientCompanyInput, BillingUncheckedCreateWithoutClientCompanyInput>
  }

  export type BillingCreateManyClientCompanyInputEnvelope = {
    data: BillingCreateManyClientCompanyInput | BillingCreateManyClientCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutClientCompanyInput = {
    update: XOR<ClientUpdateWithoutClientCompanyInput, ClientUncheckedUpdateWithoutClientCompanyInput>
    create: XOR<ClientCreateWithoutClientCompanyInput, ClientUncheckedCreateWithoutClientCompanyInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutClientCompanyInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutClientCompanyInput, ClientUncheckedUpdateWithoutClientCompanyInput>
  }

  export type ClientUpdateWithoutClientCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutClientsNestedInput
    billings?: BillingUpdateManyWithoutClientNestedInput
    phones?: ClientPhoneUpdateManyWithoutClientNestedInput
    emails?: ClientEmailUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutClientCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billings?: BillingUncheckedUpdateManyWithoutClientNestedInput
    phones?: ClientPhoneUncheckedUpdateManyWithoutClientNestedInput
    emails?: ClientEmailUncheckedUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCompanyPhoneUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ClientCompanyPhoneWhereUniqueInput
    update: XOR<ClientCompanyPhoneUpdateWithoutCompanyInput, ClientCompanyPhoneUncheckedUpdateWithoutCompanyInput>
    create: XOR<ClientCompanyPhoneCreateWithoutCompanyInput, ClientCompanyPhoneUncheckedCreateWithoutCompanyInput>
  }

  export type ClientCompanyPhoneUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ClientCompanyPhoneWhereUniqueInput
    data: XOR<ClientCompanyPhoneUpdateWithoutCompanyInput, ClientCompanyPhoneUncheckedUpdateWithoutCompanyInput>
  }

  export type ClientCompanyPhoneUpdateManyWithWhereWithoutCompanyInput = {
    where: ClientCompanyPhoneScalarWhereInput
    data: XOR<ClientCompanyPhoneUpdateManyMutationInput, ClientCompanyPhoneUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ClientCompanyPhoneScalarWhereInput = {
    AND?: ClientCompanyPhoneScalarWhereInput | ClientCompanyPhoneScalarWhereInput[]
    OR?: ClientCompanyPhoneScalarWhereInput[]
    NOT?: ClientCompanyPhoneScalarWhereInput | ClientCompanyPhoneScalarWhereInput[]
    id?: StringFilter<"ClientCompanyPhone"> | string
    company_id?: StringFilter<"ClientCompanyPhone"> | string
    phone_number?: StringFilter<"ClientCompanyPhone"> | string
    type?: StringFilter<"ClientCompanyPhone"> | string
    is_primary?: BoolFilter<"ClientCompanyPhone"> | boolean
    created_at?: DateTimeFilter<"ClientCompanyPhone"> | Date | string
    updated_at?: DateTimeFilter<"ClientCompanyPhone"> | Date | string
  }

  export type ClientCompanyEmailUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ClientCompanyEmailWhereUniqueInput
    update: XOR<ClientCompanyEmailUpdateWithoutCompanyInput, ClientCompanyEmailUncheckedUpdateWithoutCompanyInput>
    create: XOR<ClientCompanyEmailCreateWithoutCompanyInput, ClientCompanyEmailUncheckedCreateWithoutCompanyInput>
  }

  export type ClientCompanyEmailUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ClientCompanyEmailWhereUniqueInput
    data: XOR<ClientCompanyEmailUpdateWithoutCompanyInput, ClientCompanyEmailUncheckedUpdateWithoutCompanyInput>
  }

  export type ClientCompanyEmailUpdateManyWithWhereWithoutCompanyInput = {
    where: ClientCompanyEmailScalarWhereInput
    data: XOR<ClientCompanyEmailUpdateManyMutationInput, ClientCompanyEmailUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ClientCompanyEmailScalarWhereInput = {
    AND?: ClientCompanyEmailScalarWhereInput | ClientCompanyEmailScalarWhereInput[]
    OR?: ClientCompanyEmailScalarWhereInput[]
    NOT?: ClientCompanyEmailScalarWhereInput | ClientCompanyEmailScalarWhereInput[]
    id?: StringFilter<"ClientCompanyEmail"> | string
    company_id?: StringFilter<"ClientCompanyEmail"> | string
    email?: StringFilter<"ClientCompanyEmail"> | string
    type?: StringFilter<"ClientCompanyEmail"> | string
    is_primary?: BoolFilter<"ClientCompanyEmail"> | boolean
    created_at?: DateTimeFilter<"ClientCompanyEmail"> | Date | string
    updated_at?: DateTimeFilter<"ClientCompanyEmail"> | Date | string
  }

  export type ClientCompanyAddressUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ClientCompanyAddressWhereUniqueInput
    update: XOR<ClientCompanyAddressUpdateWithoutCompanyInput, ClientCompanyAddressUncheckedUpdateWithoutCompanyInput>
    create: XOR<ClientCompanyAddressCreateWithoutCompanyInput, ClientCompanyAddressUncheckedCreateWithoutCompanyInput>
  }

  export type ClientCompanyAddressUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ClientCompanyAddressWhereUniqueInput
    data: XOR<ClientCompanyAddressUpdateWithoutCompanyInput, ClientCompanyAddressUncheckedUpdateWithoutCompanyInput>
  }

  export type ClientCompanyAddressUpdateManyWithWhereWithoutCompanyInput = {
    where: ClientCompanyAddressScalarWhereInput
    data: XOR<ClientCompanyAddressUpdateManyMutationInput, ClientCompanyAddressUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ClientCompanyAddressScalarWhereInput = {
    AND?: ClientCompanyAddressScalarWhereInput | ClientCompanyAddressScalarWhereInput[]
    OR?: ClientCompanyAddressScalarWhereInput[]
    NOT?: ClientCompanyAddressScalarWhereInput | ClientCompanyAddressScalarWhereInput[]
    id?: StringFilter<"ClientCompanyAddress"> | string
    company_id?: StringFilter<"ClientCompanyAddress"> | string
    type?: StringFilter<"ClientCompanyAddress"> | string
    street?: StringFilter<"ClientCompanyAddress"> | string
    suite?: StringNullableFilter<"ClientCompanyAddress"> | string | null
    city?: StringFilter<"ClientCompanyAddress"> | string
    state?: StringFilter<"ClientCompanyAddress"> | string
    zip_code?: StringFilter<"ClientCompanyAddress"> | string
    country?: StringFilter<"ClientCompanyAddress"> | string
    is_primary?: BoolFilter<"ClientCompanyAddress"> | boolean
    created_at?: DateTimeFilter<"ClientCompanyAddress"> | Date | string
    updated_at?: DateTimeFilter<"ClientCompanyAddress"> | Date | string
  }

  export type BillingUpsertWithWhereUniqueWithoutClientCompanyInput = {
    where: BillingWhereUniqueInput
    update: XOR<BillingUpdateWithoutClientCompanyInput, BillingUncheckedUpdateWithoutClientCompanyInput>
    create: XOR<BillingCreateWithoutClientCompanyInput, BillingUncheckedCreateWithoutClientCompanyInput>
  }

  export type BillingUpdateWithWhereUniqueWithoutClientCompanyInput = {
    where: BillingWhereUniqueInput
    data: XOR<BillingUpdateWithoutClientCompanyInput, BillingUncheckedUpdateWithoutClientCompanyInput>
  }

  export type BillingUpdateManyWithWhereWithoutClientCompanyInput = {
    where: BillingScalarWhereInput
    data: XOR<BillingUpdateManyMutationInput, BillingUncheckedUpdateManyWithoutClientCompanyInput>
  }

  export type ClientCompanyCreateWithoutPhonesInput = {
    id?: string
    name: string
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    client: ClientCreateNestedOneWithoutClientCompanyInput
    emails?: ClientCompanyEmailCreateNestedManyWithoutCompanyInput
    addresses?: ClientCompanyAddressCreateNestedManyWithoutCompanyInput
    billings?: BillingCreateNestedManyWithoutClientCompanyInput
  }

  export type ClientCompanyUncheckedCreateWithoutPhonesInput = {
    id?: string
    client_id: string
    name: string
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    emails?: ClientCompanyEmailUncheckedCreateNestedManyWithoutCompanyInput
    addresses?: ClientCompanyAddressUncheckedCreateNestedManyWithoutCompanyInput
    billings?: BillingUncheckedCreateNestedManyWithoutClientCompanyInput
  }

  export type ClientCompanyCreateOrConnectWithoutPhonesInput = {
    where: ClientCompanyWhereUniqueInput
    create: XOR<ClientCompanyCreateWithoutPhonesInput, ClientCompanyUncheckedCreateWithoutPhonesInput>
  }

  export type ClientCompanyUpsertWithoutPhonesInput = {
    update: XOR<ClientCompanyUpdateWithoutPhonesInput, ClientCompanyUncheckedUpdateWithoutPhonesInput>
    create: XOR<ClientCompanyCreateWithoutPhonesInput, ClientCompanyUncheckedCreateWithoutPhonesInput>
    where?: ClientCompanyWhereInput
  }

  export type ClientCompanyUpdateToOneWithWhereWithoutPhonesInput = {
    where?: ClientCompanyWhereInput
    data: XOR<ClientCompanyUpdateWithoutPhonesInput, ClientCompanyUncheckedUpdateWithoutPhonesInput>
  }

  export type ClientCompanyUpdateWithoutPhonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutClientCompanyNestedInput
    emails?: ClientCompanyEmailUpdateManyWithoutCompanyNestedInput
    addresses?: ClientCompanyAddressUpdateManyWithoutCompanyNestedInput
    billings?: BillingUpdateManyWithoutClientCompanyNestedInput
  }

  export type ClientCompanyUncheckedUpdateWithoutPhonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    emails?: ClientCompanyEmailUncheckedUpdateManyWithoutCompanyNestedInput
    addresses?: ClientCompanyAddressUncheckedUpdateManyWithoutCompanyNestedInput
    billings?: BillingUncheckedUpdateManyWithoutClientCompanyNestedInput
  }

  export type ClientCompanyCreateWithoutEmailsInput = {
    id?: string
    name: string
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    client: ClientCreateNestedOneWithoutClientCompanyInput
    phones?: ClientCompanyPhoneCreateNestedManyWithoutCompanyInput
    addresses?: ClientCompanyAddressCreateNestedManyWithoutCompanyInput
    billings?: BillingCreateNestedManyWithoutClientCompanyInput
  }

  export type ClientCompanyUncheckedCreateWithoutEmailsInput = {
    id?: string
    client_id: string
    name: string
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    phones?: ClientCompanyPhoneUncheckedCreateNestedManyWithoutCompanyInput
    addresses?: ClientCompanyAddressUncheckedCreateNestedManyWithoutCompanyInput
    billings?: BillingUncheckedCreateNestedManyWithoutClientCompanyInput
  }

  export type ClientCompanyCreateOrConnectWithoutEmailsInput = {
    where: ClientCompanyWhereUniqueInput
    create: XOR<ClientCompanyCreateWithoutEmailsInput, ClientCompanyUncheckedCreateWithoutEmailsInput>
  }

  export type ClientCompanyUpsertWithoutEmailsInput = {
    update: XOR<ClientCompanyUpdateWithoutEmailsInput, ClientCompanyUncheckedUpdateWithoutEmailsInput>
    create: XOR<ClientCompanyCreateWithoutEmailsInput, ClientCompanyUncheckedCreateWithoutEmailsInput>
    where?: ClientCompanyWhereInput
  }

  export type ClientCompanyUpdateToOneWithWhereWithoutEmailsInput = {
    where?: ClientCompanyWhereInput
    data: XOR<ClientCompanyUpdateWithoutEmailsInput, ClientCompanyUncheckedUpdateWithoutEmailsInput>
  }

  export type ClientCompanyUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutClientCompanyNestedInput
    phones?: ClientCompanyPhoneUpdateManyWithoutCompanyNestedInput
    addresses?: ClientCompanyAddressUpdateManyWithoutCompanyNestedInput
    billings?: BillingUpdateManyWithoutClientCompanyNestedInput
  }

  export type ClientCompanyUncheckedUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: ClientCompanyPhoneUncheckedUpdateManyWithoutCompanyNestedInput
    addresses?: ClientCompanyAddressUncheckedUpdateManyWithoutCompanyNestedInput
    billings?: BillingUncheckedUpdateManyWithoutClientCompanyNestedInput
  }

  export type ClientCompanyCreateWithoutAddressesInput = {
    id?: string
    name: string
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    client: ClientCreateNestedOneWithoutClientCompanyInput
    phones?: ClientCompanyPhoneCreateNestedManyWithoutCompanyInput
    emails?: ClientCompanyEmailCreateNestedManyWithoutCompanyInput
    billings?: BillingCreateNestedManyWithoutClientCompanyInput
  }

  export type ClientCompanyUncheckedCreateWithoutAddressesInput = {
    id?: string
    client_id: string
    name: string
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    phones?: ClientCompanyPhoneUncheckedCreateNestedManyWithoutCompanyInput
    emails?: ClientCompanyEmailUncheckedCreateNestedManyWithoutCompanyInput
    billings?: BillingUncheckedCreateNestedManyWithoutClientCompanyInput
  }

  export type ClientCompanyCreateOrConnectWithoutAddressesInput = {
    where: ClientCompanyWhereUniqueInput
    create: XOR<ClientCompanyCreateWithoutAddressesInput, ClientCompanyUncheckedCreateWithoutAddressesInput>
  }

  export type ClientCompanyUpsertWithoutAddressesInput = {
    update: XOR<ClientCompanyUpdateWithoutAddressesInput, ClientCompanyUncheckedUpdateWithoutAddressesInput>
    create: XOR<ClientCompanyCreateWithoutAddressesInput, ClientCompanyUncheckedCreateWithoutAddressesInput>
    where?: ClientCompanyWhereInput
  }

  export type ClientCompanyUpdateToOneWithWhereWithoutAddressesInput = {
    where?: ClientCompanyWhereInput
    data: XOR<ClientCompanyUpdateWithoutAddressesInput, ClientCompanyUncheckedUpdateWithoutAddressesInput>
  }

  export type ClientCompanyUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutClientCompanyNestedInput
    phones?: ClientCompanyPhoneUpdateManyWithoutCompanyNestedInput
    emails?: ClientCompanyEmailUpdateManyWithoutCompanyNestedInput
    billings?: BillingUpdateManyWithoutClientCompanyNestedInput
  }

  export type ClientCompanyUncheckedUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: ClientCompanyPhoneUncheckedUpdateManyWithoutCompanyNestedInput
    emails?: ClientCompanyEmailUncheckedUpdateManyWithoutCompanyNestedInput
    billings?: BillingUncheckedUpdateManyWithoutClientCompanyNestedInput
  }

  export type ServiceCreateWithoutUnit_of_measureInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    is_discount?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billing_items?: BillingItemCreateNestedManyWithoutServiceInput
    account: AccountCreateNestedOneWithoutServicesInput
  }

  export type ServiceUncheckedCreateWithoutUnit_of_measureInput = {
    id?: string
    account_id: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    is_discount?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billing_items?: BillingItemUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutUnit_of_measureInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutUnit_of_measureInput, ServiceUncheckedCreateWithoutUnit_of_measureInput>
  }

  export type ServiceCreateManyUnit_of_measureInputEnvelope = {
    data: ServiceCreateManyUnit_of_measureInput | ServiceCreateManyUnit_of_measureInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUnits_of_measureInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    general_info?: AccountGeneralInfoCreateNestedOneWithoutAccountInput
    contact_info?: AccountContactInfoCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountCreateNestedManyWithoutAccountInput
    billings?: BillingCreateNestedManyWithoutAccountInput
    clients?: ClientCreateNestedManyWithoutAccountInput
    services?: ServiceCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateCreateNestedManyWithoutAccountInput
    users?: UserAccountCreateNestedManyWithoutAccountInput
    parent_account?: AccountCreateNestedOneWithoutChild_accountsInput
    child_accounts?: AccountCreateNestedManyWithoutParent_accountInput
  }

  export type AccountUncheckedCreateWithoutUnits_of_measureInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    parent_account_id?: string | null
    general_info?: AccountGeneralInfoUncheckedCreateNestedOneWithoutAccountInput
    contact_info?: AccountContactInfoUncheckedCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceUncheckedCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountUncheckedCreateNestedManyWithoutAccountInput
    billings?: BillingUncheckedCreateNestedManyWithoutAccountInput
    clients?: ClientUncheckedCreateNestedManyWithoutAccountInput
    services?: ServiceUncheckedCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateUncheckedCreateNestedManyWithoutAccountInput
    users?: UserAccountUncheckedCreateNestedManyWithoutAccountInput
    child_accounts?: AccountUncheckedCreateNestedManyWithoutParent_accountInput
  }

  export type AccountCreateOrConnectWithoutUnits_of_measureInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUnits_of_measureInput, AccountUncheckedCreateWithoutUnits_of_measureInput>
  }

  export type ServiceUpsertWithWhereUniqueWithoutUnit_of_measureInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutUnit_of_measureInput, ServiceUncheckedUpdateWithoutUnit_of_measureInput>
    create: XOR<ServiceCreateWithoutUnit_of_measureInput, ServiceUncheckedCreateWithoutUnit_of_measureInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutUnit_of_measureInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutUnit_of_measureInput, ServiceUncheckedUpdateWithoutUnit_of_measureInput>
  }

  export type ServiceUpdateManyWithWhereWithoutUnit_of_measureInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutUnit_of_measureInput>
  }

  export type AccountUpsertWithoutUnits_of_measureInput = {
    update: XOR<AccountUpdateWithoutUnits_of_measureInput, AccountUncheckedUpdateWithoutUnits_of_measureInput>
    create: XOR<AccountCreateWithoutUnits_of_measureInput, AccountUncheckedCreateWithoutUnits_of_measureInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutUnits_of_measureInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutUnits_of_measureInput, AccountUncheckedUpdateWithoutUnits_of_measureInput>
  }

  export type AccountUpdateWithoutUnits_of_measureInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUpdateOneWithoutAccountNestedInput
    contact_info?: AccountContactInfoUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUpdateManyWithoutAccountNestedInput
    billings?: BillingUpdateManyWithoutAccountNestedInput
    clients?: ClientUpdateManyWithoutAccountNestedInput
    services?: ServiceUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUpdateManyWithoutAccountNestedInput
    users?: UserAccountUpdateManyWithoutAccountNestedInput
    parent_account?: AccountUpdateOneWithoutChild_accountsNestedInput
    child_accounts?: AccountUpdateManyWithoutParent_accountNestedInput
  }

  export type AccountUncheckedUpdateWithoutUnits_of_measureInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    parent_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUncheckedUpdateOneWithoutAccountNestedInput
    contact_info?: AccountContactInfoUncheckedUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUncheckedUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUncheckedUpdateManyWithoutAccountNestedInput
    billings?: BillingUncheckedUpdateManyWithoutAccountNestedInput
    clients?: ClientUncheckedUpdateManyWithoutAccountNestedInput
    services?: ServiceUncheckedUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUncheckedUpdateManyWithoutAccountNestedInput
    users?: UserAccountUncheckedUpdateManyWithoutAccountNestedInput
    child_accounts?: AccountUncheckedUpdateManyWithoutParent_accountNestedInput
  }

  export type BillingItemCreateWithoutServiceInput = {
    id?: string
    description?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    unit_price: Decimal | DecimalJsLike | number | string
    tax_percent?: Decimal | DecimalJsLike | number | string
    discount_percent?: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string
    discount_amount?: Decimal | DecimalJsLike | number | string
    line_total: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    billing: BillingCreateNestedOneWithoutItemsInput
  }

  export type BillingItemUncheckedCreateWithoutServiceInput = {
    id?: string
    billing_id: string
    description?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    unit_price: Decimal | DecimalJsLike | number | string
    tax_percent?: Decimal | DecimalJsLike | number | string
    discount_percent?: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string
    discount_amount?: Decimal | DecimalJsLike | number | string
    line_total: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type BillingItemCreateOrConnectWithoutServiceInput = {
    where: BillingItemWhereUniqueInput
    create: XOR<BillingItemCreateWithoutServiceInput, BillingItemUncheckedCreateWithoutServiceInput>
  }

  export type BillingItemCreateManyServiceInputEnvelope = {
    data: BillingItemCreateManyServiceInput | BillingItemCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutServicesInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    general_info?: AccountGeneralInfoCreateNestedOneWithoutAccountInput
    contact_info?: AccountContactInfoCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountCreateNestedManyWithoutAccountInput
    billings?: BillingCreateNestedManyWithoutAccountInput
    clients?: ClientCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateCreateNestedManyWithoutAccountInput
    users?: UserAccountCreateNestedManyWithoutAccountInput
    parent_account?: AccountCreateNestedOneWithoutChild_accountsInput
    child_accounts?: AccountCreateNestedManyWithoutParent_accountInput
  }

  export type AccountUncheckedCreateWithoutServicesInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    parent_account_id?: string | null
    general_info?: AccountGeneralInfoUncheckedCreateNestedOneWithoutAccountInput
    contact_info?: AccountContactInfoUncheckedCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceUncheckedCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountUncheckedCreateNestedManyWithoutAccountInput
    billings?: BillingUncheckedCreateNestedManyWithoutAccountInput
    clients?: ClientUncheckedCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureUncheckedCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateUncheckedCreateNestedManyWithoutAccountInput
    users?: UserAccountUncheckedCreateNestedManyWithoutAccountInput
    child_accounts?: AccountUncheckedCreateNestedManyWithoutParent_accountInput
  }

  export type AccountCreateOrConnectWithoutServicesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutServicesInput, AccountUncheckedCreateWithoutServicesInput>
  }

  export type UnitOfMeasureCreateWithoutServicesInput = {
    id?: string
    name: string
    symbol: string
    description?: string | null
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    account: AccountCreateNestedOneWithoutUnits_of_measureInput
  }

  export type UnitOfMeasureUncheckedCreateWithoutServicesInput = {
    id?: string
    account_id: string
    name: string
    symbol: string
    description?: string | null
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitOfMeasureCreateOrConnectWithoutServicesInput = {
    where: UnitOfMeasureWhereUniqueInput
    create: XOR<UnitOfMeasureCreateWithoutServicesInput, UnitOfMeasureUncheckedCreateWithoutServicesInput>
  }

  export type BillingItemUpsertWithWhereUniqueWithoutServiceInput = {
    where: BillingItemWhereUniqueInput
    update: XOR<BillingItemUpdateWithoutServiceInput, BillingItemUncheckedUpdateWithoutServiceInput>
    create: XOR<BillingItemCreateWithoutServiceInput, BillingItemUncheckedCreateWithoutServiceInput>
  }

  export type BillingItemUpdateWithWhereUniqueWithoutServiceInput = {
    where: BillingItemWhereUniqueInput
    data: XOR<BillingItemUpdateWithoutServiceInput, BillingItemUncheckedUpdateWithoutServiceInput>
  }

  export type BillingItemUpdateManyWithWhereWithoutServiceInput = {
    where: BillingItemScalarWhereInput
    data: XOR<BillingItemUpdateManyMutationInput, BillingItemUncheckedUpdateManyWithoutServiceInput>
  }

  export type BillingItemScalarWhereInput = {
    AND?: BillingItemScalarWhereInput | BillingItemScalarWhereInput[]
    OR?: BillingItemScalarWhereInput[]
    NOT?: BillingItemScalarWhereInput | BillingItemScalarWhereInput[]
    id?: StringFilter<"BillingItem"> | string
    billing_id?: StringFilter<"BillingItem"> | string
    service_id?: StringFilter<"BillingItem"> | string
    description?: StringNullableFilter<"BillingItem"> | string | null
    quantity?: DecimalFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    tax_percent?: DecimalFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    discount_percent?: DecimalFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    line_total?: DecimalFilter<"BillingItem"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"BillingItem"> | Date | string
    updated_at?: DateTimeFilter<"BillingItem"> | Date | string
    created_by?: StringNullableFilter<"BillingItem"> | string | null
    updated_by?: StringNullableFilter<"BillingItem"> | string | null
  }

  export type AccountUpsertWithoutServicesInput = {
    update: XOR<AccountUpdateWithoutServicesInput, AccountUncheckedUpdateWithoutServicesInput>
    create: XOR<AccountCreateWithoutServicesInput, AccountUncheckedCreateWithoutServicesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutServicesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutServicesInput, AccountUncheckedUpdateWithoutServicesInput>
  }

  export type AccountUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUpdateOneWithoutAccountNestedInput
    contact_info?: AccountContactInfoUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUpdateManyWithoutAccountNestedInput
    billings?: BillingUpdateManyWithoutAccountNestedInput
    clients?: ClientUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUpdateManyWithoutAccountNestedInput
    users?: UserAccountUpdateManyWithoutAccountNestedInput
    parent_account?: AccountUpdateOneWithoutChild_accountsNestedInput
    child_accounts?: AccountUpdateManyWithoutParent_accountNestedInput
  }

  export type AccountUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    parent_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUncheckedUpdateOneWithoutAccountNestedInput
    contact_info?: AccountContactInfoUncheckedUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUncheckedUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUncheckedUpdateManyWithoutAccountNestedInput
    billings?: BillingUncheckedUpdateManyWithoutAccountNestedInput
    clients?: ClientUncheckedUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUncheckedUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUncheckedUpdateManyWithoutAccountNestedInput
    users?: UserAccountUncheckedUpdateManyWithoutAccountNestedInput
    child_accounts?: AccountUncheckedUpdateManyWithoutParent_accountNestedInput
  }

  export type UnitOfMeasureUpsertWithoutServicesInput = {
    update: XOR<UnitOfMeasureUpdateWithoutServicesInput, UnitOfMeasureUncheckedUpdateWithoutServicesInput>
    create: XOR<UnitOfMeasureCreateWithoutServicesInput, UnitOfMeasureUncheckedCreateWithoutServicesInput>
    where?: UnitOfMeasureWhereInput
  }

  export type UnitOfMeasureUpdateToOneWithWhereWithoutServicesInput = {
    where?: UnitOfMeasureWhereInput
    data: XOR<UnitOfMeasureUpdateWithoutServicesInput, UnitOfMeasureUncheckedUpdateWithoutServicesInput>
  }

  export type UnitOfMeasureUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUnits_of_measureNestedInput
  }

  export type UnitOfMeasureUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateWithoutBillingsInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    general_info?: AccountGeneralInfoCreateNestedOneWithoutAccountInput
    contact_info?: AccountContactInfoCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountCreateNestedManyWithoutAccountInput
    clients?: ClientCreateNestedManyWithoutAccountInput
    services?: ServiceCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateCreateNestedManyWithoutAccountInput
    users?: UserAccountCreateNestedManyWithoutAccountInput
    parent_account?: AccountCreateNestedOneWithoutChild_accountsInput
    child_accounts?: AccountCreateNestedManyWithoutParent_accountInput
  }

  export type AccountUncheckedCreateWithoutBillingsInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    parent_account_id?: string | null
    general_info?: AccountGeneralInfoUncheckedCreateNestedOneWithoutAccountInput
    contact_info?: AccountContactInfoUncheckedCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceUncheckedCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountUncheckedCreateNestedManyWithoutAccountInput
    clients?: ClientUncheckedCreateNestedManyWithoutAccountInput
    services?: ServiceUncheckedCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureUncheckedCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateUncheckedCreateNestedManyWithoutAccountInput
    users?: UserAccountUncheckedCreateNestedManyWithoutAccountInput
    child_accounts?: AccountUncheckedCreateNestedManyWithoutParent_accountInput
  }

  export type AccountCreateOrConnectWithoutBillingsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutBillingsInput, AccountUncheckedCreateWithoutBillingsInput>
  }

  export type ClientCreateWithoutBillingsInput = {
    id?: string
    client_type?: $Enums.ClientType
    name: string
    company_name?: string | null
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    account: AccountCreateNestedOneWithoutClientsInput
    phones?: ClientPhoneCreateNestedManyWithoutClientInput
    emails?: ClientEmailCreateNestedManyWithoutClientInput
    addresses?: ClientAddressCreateNestedManyWithoutClientInput
    ClientCompany?: ClientCompanyCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutBillingsInput = {
    id?: string
    account_id: string
    client_type?: $Enums.ClientType
    name: string
    company_name?: string | null
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    phones?: ClientPhoneUncheckedCreateNestedManyWithoutClientInput
    emails?: ClientEmailUncheckedCreateNestedManyWithoutClientInput
    addresses?: ClientAddressUncheckedCreateNestedManyWithoutClientInput
    ClientCompany?: ClientCompanyUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutBillingsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutBillingsInput, ClientUncheckedCreateWithoutBillingsInput>
  }

  export type ClientCompanyCreateWithoutBillingsInput = {
    id?: string
    name: string
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    client: ClientCreateNestedOneWithoutClientCompanyInput
    phones?: ClientCompanyPhoneCreateNestedManyWithoutCompanyInput
    emails?: ClientCompanyEmailCreateNestedManyWithoutCompanyInput
    addresses?: ClientCompanyAddressCreateNestedManyWithoutCompanyInput
  }

  export type ClientCompanyUncheckedCreateWithoutBillingsInput = {
    id?: string
    client_id: string
    name: string
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    phones?: ClientCompanyPhoneUncheckedCreateNestedManyWithoutCompanyInput
    emails?: ClientCompanyEmailUncheckedCreateNestedManyWithoutCompanyInput
    addresses?: ClientCompanyAddressUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type ClientCompanyCreateOrConnectWithoutBillingsInput = {
    where: ClientCompanyWhereUniqueInput
    create: XOR<ClientCompanyCreateWithoutBillingsInput, ClientCompanyUncheckedCreateWithoutBillingsInput>
  }

  export type BillingItemCreateWithoutBillingInput = {
    id?: string
    description?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    unit_price: Decimal | DecimalJsLike | number | string
    tax_percent?: Decimal | DecimalJsLike | number | string
    discount_percent?: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string
    discount_amount?: Decimal | DecimalJsLike | number | string
    line_total: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    service: ServiceCreateNestedOneWithoutBilling_itemsInput
  }

  export type BillingItemUncheckedCreateWithoutBillingInput = {
    id?: string
    service_id: string
    description?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    unit_price: Decimal | DecimalJsLike | number | string
    tax_percent?: Decimal | DecimalJsLike | number | string
    discount_percent?: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string
    discount_amount?: Decimal | DecimalJsLike | number | string
    line_total: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type BillingItemCreateOrConnectWithoutBillingInput = {
    where: BillingItemWhereUniqueInput
    create: XOR<BillingItemCreateWithoutBillingInput, BillingItemUncheckedCreateWithoutBillingInput>
  }

  export type BillingItemCreateManyBillingInputEnvelope = {
    data: BillingItemCreateManyBillingInput | BillingItemCreateManyBillingInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutBillingsInput = {
    update: XOR<AccountUpdateWithoutBillingsInput, AccountUncheckedUpdateWithoutBillingsInput>
    create: XOR<AccountCreateWithoutBillingsInput, AccountUncheckedCreateWithoutBillingsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutBillingsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutBillingsInput, AccountUncheckedUpdateWithoutBillingsInput>
  }

  export type AccountUpdateWithoutBillingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUpdateOneWithoutAccountNestedInput
    contact_info?: AccountContactInfoUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUpdateManyWithoutAccountNestedInput
    clients?: ClientUpdateManyWithoutAccountNestedInput
    services?: ServiceUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUpdateManyWithoutAccountNestedInput
    users?: UserAccountUpdateManyWithoutAccountNestedInput
    parent_account?: AccountUpdateOneWithoutChild_accountsNestedInput
    child_accounts?: AccountUpdateManyWithoutParent_accountNestedInput
  }

  export type AccountUncheckedUpdateWithoutBillingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    parent_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUncheckedUpdateOneWithoutAccountNestedInput
    contact_info?: AccountContactInfoUncheckedUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUncheckedUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUncheckedUpdateManyWithoutAccountNestedInput
    clients?: ClientUncheckedUpdateManyWithoutAccountNestedInput
    services?: ServiceUncheckedUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUncheckedUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUncheckedUpdateManyWithoutAccountNestedInput
    users?: UserAccountUncheckedUpdateManyWithoutAccountNestedInput
    child_accounts?: AccountUncheckedUpdateManyWithoutParent_accountNestedInput
  }

  export type ClientUpsertWithoutBillingsInput = {
    update: XOR<ClientUpdateWithoutBillingsInput, ClientUncheckedUpdateWithoutBillingsInput>
    create: XOR<ClientCreateWithoutBillingsInput, ClientUncheckedCreateWithoutBillingsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutBillingsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutBillingsInput, ClientUncheckedUpdateWithoutBillingsInput>
  }

  export type ClientUpdateWithoutBillingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutClientsNestedInput
    phones?: ClientPhoneUpdateManyWithoutClientNestedInput
    emails?: ClientEmailUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUpdateManyWithoutClientNestedInput
    ClientCompany?: ClientCompanyUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutBillingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: ClientPhoneUncheckedUpdateManyWithoutClientNestedInput
    emails?: ClientEmailUncheckedUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUncheckedUpdateManyWithoutClientNestedInput
    ClientCompany?: ClientCompanyUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCompanyUpsertWithoutBillingsInput = {
    update: XOR<ClientCompanyUpdateWithoutBillingsInput, ClientCompanyUncheckedUpdateWithoutBillingsInput>
    create: XOR<ClientCompanyCreateWithoutBillingsInput, ClientCompanyUncheckedCreateWithoutBillingsInput>
    where?: ClientCompanyWhereInput
  }

  export type ClientCompanyUpdateToOneWithWhereWithoutBillingsInput = {
    where?: ClientCompanyWhereInput
    data: XOR<ClientCompanyUpdateWithoutBillingsInput, ClientCompanyUncheckedUpdateWithoutBillingsInput>
  }

  export type ClientCompanyUpdateWithoutBillingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutClientCompanyNestedInput
    phones?: ClientCompanyPhoneUpdateManyWithoutCompanyNestedInput
    emails?: ClientCompanyEmailUpdateManyWithoutCompanyNestedInput
    addresses?: ClientCompanyAddressUpdateManyWithoutCompanyNestedInput
  }

  export type ClientCompanyUncheckedUpdateWithoutBillingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: ClientCompanyPhoneUncheckedUpdateManyWithoutCompanyNestedInput
    emails?: ClientCompanyEmailUncheckedUpdateManyWithoutCompanyNestedInput
    addresses?: ClientCompanyAddressUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type BillingItemUpsertWithWhereUniqueWithoutBillingInput = {
    where: BillingItemWhereUniqueInput
    update: XOR<BillingItemUpdateWithoutBillingInput, BillingItemUncheckedUpdateWithoutBillingInput>
    create: XOR<BillingItemCreateWithoutBillingInput, BillingItemUncheckedCreateWithoutBillingInput>
  }

  export type BillingItemUpdateWithWhereUniqueWithoutBillingInput = {
    where: BillingItemWhereUniqueInput
    data: XOR<BillingItemUpdateWithoutBillingInput, BillingItemUncheckedUpdateWithoutBillingInput>
  }

  export type BillingItemUpdateManyWithWhereWithoutBillingInput = {
    where: BillingItemScalarWhereInput
    data: XOR<BillingItemUpdateManyMutationInput, BillingItemUncheckedUpdateManyWithoutBillingInput>
  }

  export type BillingCreateWithoutItemsInput = {
    id?: string
    billing_date?: Date | string
    due_date?: Date | string | null
    invoice_number: string
    invoice_prefix?: string
    invoice_sequence: number
    billing_address: string
    subtotal_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string
    discount_amount?: Decimal | DecimalJsLike | number | string
    total_amount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    status?: $Enums.BillingStatus
    cancellation_date?: Date | string | null
    cancellation_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
    account: AccountCreateNestedOneWithoutBillingsInput
    client: ClientCreateNestedOneWithoutBillingsInput
    clientCompany?: ClientCompanyCreateNestedOneWithoutBillingsInput
  }

  export type BillingUncheckedCreateWithoutItemsInput = {
    id?: string
    account_id: string
    client_id: string
    client_company_id?: string | null
    billing_date?: Date | string
    due_date?: Date | string | null
    invoice_number: string
    invoice_prefix?: string
    invoice_sequence: number
    billing_address: string
    subtotal_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string
    discount_amount?: Decimal | DecimalJsLike | number | string
    total_amount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    status?: $Enums.BillingStatus
    cancellation_date?: Date | string | null
    cancellation_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type BillingCreateOrConnectWithoutItemsInput = {
    where: BillingWhereUniqueInput
    create: XOR<BillingCreateWithoutItemsInput, BillingUncheckedCreateWithoutItemsInput>
  }

  export type ServiceCreateWithoutBilling_itemsInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    is_discount?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    account: AccountCreateNestedOneWithoutServicesInput
    unit_of_measure: UnitOfMeasureCreateNestedOneWithoutServicesInput
  }

  export type ServiceUncheckedCreateWithoutBilling_itemsInput = {
    id?: string
    account_id: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    unit_of_measure_id: string
    is_discount?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ServiceCreateOrConnectWithoutBilling_itemsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutBilling_itemsInput, ServiceUncheckedCreateWithoutBilling_itemsInput>
  }

  export type BillingUpsertWithoutItemsInput = {
    update: XOR<BillingUpdateWithoutItemsInput, BillingUncheckedUpdateWithoutItemsInput>
    create: XOR<BillingCreateWithoutItemsInput, BillingUncheckedCreateWithoutItemsInput>
    where?: BillingWhereInput
  }

  export type BillingUpdateToOneWithWhereWithoutItemsInput = {
    where?: BillingWhereInput
    data: XOR<BillingUpdateWithoutItemsInput, BillingUncheckedUpdateWithoutItemsInput>
  }

  export type BillingUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    billing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_prefix?: StringFieldUpdateOperationsInput | string
    invoice_sequence?: IntFieldUpdateOperationsInput | number
    billing_address?: StringFieldUpdateOperationsInput | string
    subtotal_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    cancellation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneRequiredWithoutBillingsNestedInput
    client?: ClientUpdateOneRequiredWithoutBillingsNestedInput
    clientCompany?: ClientCompanyUpdateOneWithoutBillingsNestedInput
  }

  export type BillingUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    client_company_id?: NullableStringFieldUpdateOperationsInput | string | null
    billing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_prefix?: StringFieldUpdateOperationsInput | string
    invoice_sequence?: IntFieldUpdateOperationsInput | number
    billing_address?: StringFieldUpdateOperationsInput | string
    subtotal_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    cancellation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceUpsertWithoutBilling_itemsInput = {
    update: XOR<ServiceUpdateWithoutBilling_itemsInput, ServiceUncheckedUpdateWithoutBilling_itemsInput>
    create: XOR<ServiceCreateWithoutBilling_itemsInput, ServiceUncheckedCreateWithoutBilling_itemsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutBilling_itemsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutBilling_itemsInput, ServiceUncheckedUpdateWithoutBilling_itemsInput>
  }

  export type ServiceUpdateWithoutBilling_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_discount?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutServicesNestedInput
    unit_of_measure?: UnitOfMeasureUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ServiceUncheckedUpdateWithoutBilling_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_of_measure_id?: StringFieldUpdateOperationsInput | string
    is_discount?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateWithoutBank_accountsInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    general_info?: AccountGeneralInfoCreateNestedOneWithoutAccountInput
    contact_info?: AccountContactInfoCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceCreateNestedOneWithoutAccountInput
    billings?: BillingCreateNestedManyWithoutAccountInput
    clients?: ClientCreateNestedManyWithoutAccountInput
    services?: ServiceCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateCreateNestedManyWithoutAccountInput
    users?: UserAccountCreateNestedManyWithoutAccountInput
    parent_account?: AccountCreateNestedOneWithoutChild_accountsInput
    child_accounts?: AccountCreateNestedManyWithoutParent_accountInput
  }

  export type AccountUncheckedCreateWithoutBank_accountsInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    parent_account_id?: string | null
    general_info?: AccountGeneralInfoUncheckedCreateNestedOneWithoutAccountInput
    contact_info?: AccountContactInfoUncheckedCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceUncheckedCreateNestedOneWithoutAccountInput
    billings?: BillingUncheckedCreateNestedManyWithoutAccountInput
    clients?: ClientUncheckedCreateNestedManyWithoutAccountInput
    services?: ServiceUncheckedCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureUncheckedCreateNestedManyWithoutAccountInput
    pdf_templates?: PDFTemplateUncheckedCreateNestedManyWithoutAccountInput
    users?: UserAccountUncheckedCreateNestedManyWithoutAccountInput
    child_accounts?: AccountUncheckedCreateNestedManyWithoutParent_accountInput
  }

  export type AccountCreateOrConnectWithoutBank_accountsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutBank_accountsInput, AccountUncheckedCreateWithoutBank_accountsInput>
  }

  export type AccountUpsertWithoutBank_accountsInput = {
    update: XOR<AccountUpdateWithoutBank_accountsInput, AccountUncheckedUpdateWithoutBank_accountsInput>
    create: XOR<AccountCreateWithoutBank_accountsInput, AccountUncheckedCreateWithoutBank_accountsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutBank_accountsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutBank_accountsInput, AccountUncheckedUpdateWithoutBank_accountsInput>
  }

  export type AccountUpdateWithoutBank_accountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUpdateOneWithoutAccountNestedInput
    contact_info?: AccountContactInfoUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUpdateOneWithoutAccountNestedInput
    billings?: BillingUpdateManyWithoutAccountNestedInput
    clients?: ClientUpdateManyWithoutAccountNestedInput
    services?: ServiceUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUpdateManyWithoutAccountNestedInput
    users?: UserAccountUpdateManyWithoutAccountNestedInput
    parent_account?: AccountUpdateOneWithoutChild_accountsNestedInput
    child_accounts?: AccountUpdateManyWithoutParent_accountNestedInput
  }

  export type AccountUncheckedUpdateWithoutBank_accountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    parent_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUncheckedUpdateOneWithoutAccountNestedInput
    contact_info?: AccountContactInfoUncheckedUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUncheckedUpdateOneWithoutAccountNestedInput
    billings?: BillingUncheckedUpdateManyWithoutAccountNestedInput
    clients?: ClientUncheckedUpdateManyWithoutAccountNestedInput
    services?: ServiceUncheckedUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUncheckedUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUncheckedUpdateManyWithoutAccountNestedInput
    users?: UserAccountUncheckedUpdateManyWithoutAccountNestedInput
    child_accounts?: AccountUncheckedUpdateManyWithoutParent_accountNestedInput
  }

  export type AccountCreateWithoutPdf_templatesInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    general_info?: AccountGeneralInfoCreateNestedOneWithoutAccountInput
    contact_info?: AccountContactInfoCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountCreateNestedManyWithoutAccountInput
    billings?: BillingCreateNestedManyWithoutAccountInput
    clients?: ClientCreateNestedManyWithoutAccountInput
    services?: ServiceCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureCreateNestedManyWithoutAccountInput
    users?: UserAccountCreateNestedManyWithoutAccountInput
    parent_account?: AccountCreateNestedOneWithoutChild_accountsInput
    child_accounts?: AccountCreateNestedManyWithoutParent_accountInput
  }

  export type AccountUncheckedCreateWithoutPdf_templatesInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
    parent_account_id?: string | null
    general_info?: AccountGeneralInfoUncheckedCreateNestedOneWithoutAccountInput
    contact_info?: AccountContactInfoUncheckedCreateNestedOneWithoutAccountInput
    compliance_info?: AccountComplianceUncheckedCreateNestedOneWithoutAccountInput
    bank_accounts?: BankAccountUncheckedCreateNestedManyWithoutAccountInput
    billings?: BillingUncheckedCreateNestedManyWithoutAccountInput
    clients?: ClientUncheckedCreateNestedManyWithoutAccountInput
    services?: ServiceUncheckedCreateNestedManyWithoutAccountInput
    units_of_measure?: UnitOfMeasureUncheckedCreateNestedManyWithoutAccountInput
    users?: UserAccountUncheckedCreateNestedManyWithoutAccountInput
    child_accounts?: AccountUncheckedCreateNestedManyWithoutParent_accountInput
  }

  export type AccountCreateOrConnectWithoutPdf_templatesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutPdf_templatesInput, AccountUncheckedCreateWithoutPdf_templatesInput>
  }

  export type AccountUpsertWithoutPdf_templatesInput = {
    update: XOR<AccountUpdateWithoutPdf_templatesInput, AccountUncheckedUpdateWithoutPdf_templatesInput>
    create: XOR<AccountCreateWithoutPdf_templatesInput, AccountUncheckedCreateWithoutPdf_templatesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutPdf_templatesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutPdf_templatesInput, AccountUncheckedUpdateWithoutPdf_templatesInput>
  }

  export type AccountUpdateWithoutPdf_templatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUpdateOneWithoutAccountNestedInput
    contact_info?: AccountContactInfoUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUpdateManyWithoutAccountNestedInput
    billings?: BillingUpdateManyWithoutAccountNestedInput
    clients?: ClientUpdateManyWithoutAccountNestedInput
    services?: ServiceUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUpdateManyWithoutAccountNestedInput
    users?: UserAccountUpdateManyWithoutAccountNestedInput
    parent_account?: AccountUpdateOneWithoutChild_accountsNestedInput
    child_accounts?: AccountUpdateManyWithoutParent_accountNestedInput
  }

  export type AccountUncheckedUpdateWithoutPdf_templatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    parent_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUncheckedUpdateOneWithoutAccountNestedInput
    contact_info?: AccountContactInfoUncheckedUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUncheckedUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUncheckedUpdateManyWithoutAccountNestedInput
    billings?: BillingUncheckedUpdateManyWithoutAccountNestedInput
    clients?: ClientUncheckedUpdateManyWithoutAccountNestedInput
    services?: ServiceUncheckedUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUncheckedUpdateManyWithoutAccountNestedInput
    users?: UserAccountUncheckedUpdateManyWithoutAccountNestedInput
    child_accounts?: AccountUncheckedUpdateManyWithoutParent_accountNestedInput
  }

  export type ProfileCreateWithoutUserInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    displayName?: string | null
    bio?: string | null
    jobTitle?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    language?: string | null
    timezone?: string | null
    website?: string | null
    linkedin?: string | null
    twitter?: string | null
    facebook?: string | null
    instagram?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    emails?: ProfileEmailCreateNestedManyWithoutProfileInput
    phones?: ProfilePhoneCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    displayName?: string | null
    bio?: string | null
    jobTitle?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string | null
    language?: string | null
    timezone?: string | null
    website?: string | null
    linkedin?: string | null
    twitter?: string | null
    facebook?: string | null
    instagram?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    emails?: ProfileEmailUncheckedCreateNestedManyWithoutProfileInput
    phones?: ProfilePhoneUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type UserAccountCreateWithoutUserInput = {
    role: string
    created_at?: Date | string
    account: AccountCreateNestedOneWithoutUsersInput
  }

  export type UserAccountUncheckedCreateWithoutUserInput = {
    account_id: string
    role: string
    created_at?: Date | string
  }

  export type UserAccountCreateOrConnectWithoutUserInput = {
    where: UserAccountWhereUniqueInput
    create: XOR<UserAccountCreateWithoutUserInput, UserAccountUncheckedCreateWithoutUserInput>
  }

  export type UserAccountCreateManyUserInputEnvelope = {
    data: UserAccountCreateManyUserInput | UserAccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountAuthCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountAuthUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountAuthCreateOrConnectWithoutUserInput = {
    where: AccountAuthWhereUniqueInput
    create: XOR<AccountAuthCreateWithoutUserInput, AccountAuthUncheckedCreateWithoutUserInput>
  }

  export type AccountAuthCreateManyUserInputEnvelope = {
    data: AccountAuthCreateManyUserInput | AccountAuthCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    emails?: ProfileEmailUpdateManyWithoutProfileNestedInput
    phones?: ProfilePhoneUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    emails?: ProfileEmailUncheckedUpdateManyWithoutProfileNestedInput
    phones?: ProfilePhoneUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type UserAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAccountWhereUniqueInput
    update: XOR<UserAccountUpdateWithoutUserInput, UserAccountUncheckedUpdateWithoutUserInput>
    create: XOR<UserAccountCreateWithoutUserInput, UserAccountUncheckedCreateWithoutUserInput>
  }

  export type UserAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAccountWhereUniqueInput
    data: XOR<UserAccountUpdateWithoutUserInput, UserAccountUncheckedUpdateWithoutUserInput>
  }

  export type UserAccountUpdateManyWithWhereWithoutUserInput = {
    where: UserAccountScalarWhereInput
    data: XOR<UserAccountUpdateManyMutationInput, UserAccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountAuthUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountAuthWhereUniqueInput
    update: XOR<AccountAuthUpdateWithoutUserInput, AccountAuthUncheckedUpdateWithoutUserInput>
    create: XOR<AccountAuthCreateWithoutUserInput, AccountAuthUncheckedCreateWithoutUserInput>
  }

  export type AccountAuthUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountAuthWhereUniqueInput
    data: XOR<AccountAuthUpdateWithoutUserInput, AccountAuthUncheckedUpdateWithoutUserInput>
  }

  export type AccountAuthUpdateManyWithWhereWithoutUserInput = {
    where: AccountAuthScalarWhereInput
    data: XOR<AccountAuthUpdateManyMutationInput, AccountAuthUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountAuthScalarWhereInput = {
    AND?: AccountAuthScalarWhereInput | AccountAuthScalarWhereInput[]
    OR?: AccountAuthScalarWhereInput[]
    NOT?: AccountAuthScalarWhereInput | AccountAuthScalarWhereInput[]
    id?: StringFilter<"AccountAuth"> | string
    userId?: StringFilter<"AccountAuth"> | string
    type?: StringFilter<"AccountAuth"> | string
    provider?: StringFilter<"AccountAuth"> | string
    providerAccountId?: StringFilter<"AccountAuth"> | string
    refresh_token?: StringNullableFilter<"AccountAuth"> | string | null
    access_token?: StringNullableFilter<"AccountAuth"> | string | null
    expires_at?: IntNullableFilter<"AccountAuth"> | number | null
    token_type?: StringNullableFilter<"AccountAuth"> | string | null
    scope?: StringNullableFilter<"AccountAuth"> | string | null
    id_token?: StringNullableFilter<"AccountAuth"> | string | null
    session_state?: StringNullableFilter<"AccountAuth"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type BankAccountCreateManyAccountInput = {
    id?: string
    bank_name: string
    account_number: string
    routing_number?: string | null
    account_type?: string | null
    currency?: string | null
    is_primary?: boolean
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BillingCreateManyAccountInput = {
    id?: string
    client_id: string
    client_company_id?: string | null
    billing_date?: Date | string
    due_date?: Date | string | null
    invoice_number: string
    invoice_prefix?: string
    invoice_sequence: number
    billing_address: string
    subtotal_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string
    discount_amount?: Decimal | DecimalJsLike | number | string
    total_amount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    status?: $Enums.BillingStatus
    cancellation_date?: Date | string | null
    cancellation_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type ClientCreateManyAccountInput = {
    id?: string
    client_type?: $Enums.ClientType
    name: string
    company_name?: string | null
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ServiceCreateManyAccountInput = {
    id?: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    unit_of_measure_id: string
    is_discount?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitOfMeasureCreateManyAccountInput = {
    id?: string
    name: string
    symbol: string
    description?: string | null
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PDFTemplateCreateManyAccountInput = {
    id?: string
    name: string
    description?: string | null
    is_default?: boolean
    primary_color?: string
    secondary_color?: string
    font_family?: string
    show_logo?: boolean
    show_watermark?: boolean
    show_qr_code?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type UserAccountCreateManyAccountInput = {
    user_id: string
    role: string
    created_at?: Date | string
  }

  export type AccountCreateManyParent_accountInput = {
    id?: string
    legal_name: string
    created_at?: Date | string
    created_by?: string | null
    updated_at?: Date | string
    updated_by?: string | null
  }

  export type BankAccountUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    routing_number?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    routing_number?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    routing_number?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    billing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_prefix?: StringFieldUpdateOperationsInput | string
    invoice_sequence?: IntFieldUpdateOperationsInput | number
    billing_address?: StringFieldUpdateOperationsInput | string
    subtotal_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    cancellation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutBillingsNestedInput
    clientCompany?: ClientCompanyUpdateOneWithoutBillingsNestedInput
    items?: BillingItemUpdateManyWithoutBillingNestedInput
  }

  export type BillingUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    client_company_id?: NullableStringFieldUpdateOperationsInput | string | null
    billing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_prefix?: StringFieldUpdateOperationsInput | string
    invoice_sequence?: IntFieldUpdateOperationsInput | number
    billing_address?: StringFieldUpdateOperationsInput | string
    subtotal_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    cancellation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    items?: BillingItemUncheckedUpdateManyWithoutBillingNestedInput
  }

  export type BillingUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    client_company_id?: NullableStringFieldUpdateOperationsInput | string | null
    billing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_prefix?: StringFieldUpdateOperationsInput | string
    invoice_sequence?: IntFieldUpdateOperationsInput | number
    billing_address?: StringFieldUpdateOperationsInput | string
    subtotal_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    cancellation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billings?: BillingUpdateManyWithoutClientNestedInput
    phones?: ClientPhoneUpdateManyWithoutClientNestedInput
    emails?: ClientEmailUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUpdateManyWithoutClientNestedInput
    ClientCompany?: ClientCompanyUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billings?: BillingUncheckedUpdateManyWithoutClientNestedInput
    phones?: ClientPhoneUncheckedUpdateManyWithoutClientNestedInput
    emails?: ClientEmailUncheckedUpdateManyWithoutClientNestedInput
    addresses?: ClientAddressUncheckedUpdateManyWithoutClientNestedInput
    ClientCompany?: ClientCompanyUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    name?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_discount?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_items?: BillingItemUpdateManyWithoutServiceNestedInput
    unit_of_measure?: UnitOfMeasureUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ServiceUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_of_measure_id?: StringFieldUpdateOperationsInput | string
    is_discount?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_items?: BillingItemUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_of_measure_id?: StringFieldUpdateOperationsInput | string
    is_discount?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitOfMeasureUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutUnit_of_measureNestedInput
  }

  export type UnitOfMeasureUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutUnit_of_measureNestedInput
  }

  export type UnitOfMeasureUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PDFTemplateUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    primary_color?: StringFieldUpdateOperationsInput | string
    secondary_color?: StringFieldUpdateOperationsInput | string
    font_family?: StringFieldUpdateOperationsInput | string
    show_logo?: BoolFieldUpdateOperationsInput | boolean
    show_watermark?: BoolFieldUpdateOperationsInput | boolean
    show_qr_code?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PDFTemplateUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    primary_color?: StringFieldUpdateOperationsInput | string
    secondary_color?: StringFieldUpdateOperationsInput | string
    font_family?: StringFieldUpdateOperationsInput | string
    show_logo?: BoolFieldUpdateOperationsInput | boolean
    show_watermark?: BoolFieldUpdateOperationsInput | boolean
    show_qr_code?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PDFTemplateUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    primary_color?: StringFieldUpdateOperationsInput | string
    secondary_color?: StringFieldUpdateOperationsInput | string
    font_family?: StringFieldUpdateOperationsInput | string
    show_logo?: BoolFieldUpdateOperationsInput | boolean
    show_watermark?: BoolFieldUpdateOperationsInput | boolean
    show_qr_code?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAccountUpdateWithoutAccountInput = {
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type UserAccountUncheckedUpdateWithoutAccountInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccountUncheckedUpdateManyWithoutAccountInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutParent_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUpdateOneWithoutAccountNestedInput
    contact_info?: AccountContactInfoUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUpdateManyWithoutAccountNestedInput
    billings?: BillingUpdateManyWithoutAccountNestedInput
    clients?: ClientUpdateManyWithoutAccountNestedInput
    services?: ServiceUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUpdateManyWithoutAccountNestedInput
    users?: UserAccountUpdateManyWithoutAccountNestedInput
    child_accounts?: AccountUpdateManyWithoutParent_accountNestedInput
  }

  export type AccountUncheckedUpdateWithoutParent_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    general_info?: AccountGeneralInfoUncheckedUpdateOneWithoutAccountNestedInput
    contact_info?: AccountContactInfoUncheckedUpdateOneWithoutAccountNestedInput
    compliance_info?: AccountComplianceUncheckedUpdateOneWithoutAccountNestedInput
    bank_accounts?: BankAccountUncheckedUpdateManyWithoutAccountNestedInput
    billings?: BillingUncheckedUpdateManyWithoutAccountNestedInput
    clients?: ClientUncheckedUpdateManyWithoutAccountNestedInput
    services?: ServiceUncheckedUpdateManyWithoutAccountNestedInput
    units_of_measure?: UnitOfMeasureUncheckedUpdateManyWithoutAccountNestedInput
    pdf_templates?: PDFTemplateUncheckedUpdateManyWithoutAccountNestedInput
    users?: UserAccountUncheckedUpdateManyWithoutAccountNestedInput
    child_accounts?: AccountUncheckedUpdateManyWithoutParent_accountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutParent_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfileEmailCreateManyProfileInput = {
    id?: string
    email: string
    type: string
    isPrimary?: boolean
    isVerified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProfilePhoneCreateManyProfileInput = {
    id?: string
    phoneNumber: string
    type: string
    isPrimary?: boolean
    isVerified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProfileEmailUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileEmailUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileEmailUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfilePhoneUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfilePhoneUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfilePhoneUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingCreateManyClientInput = {
    id?: string
    account_id: string
    client_company_id?: string | null
    billing_date?: Date | string
    due_date?: Date | string | null
    invoice_number: string
    invoice_prefix?: string
    invoice_sequence: number
    billing_address: string
    subtotal_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string
    discount_amount?: Decimal | DecimalJsLike | number | string
    total_amount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    status?: $Enums.BillingStatus
    cancellation_date?: Date | string | null
    cancellation_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type ClientPhoneCreateManyClientInput = {
    id?: string
    phone_number: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientEmailCreateManyClientInput = {
    id?: string
    email: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientAddressCreateManyClientInput = {
    id?: string
    type: string
    street: string
    suite?: string | null
    city: string
    state: string
    zip_code: string
    country?: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientCompanyCreateManyClientInput = {
    id?: string
    name: string
    tax_id?: string | null
    website?: string | null
    notes?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BillingUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    billing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_prefix?: StringFieldUpdateOperationsInput | string
    invoice_sequence?: IntFieldUpdateOperationsInput | number
    billing_address?: StringFieldUpdateOperationsInput | string
    subtotal_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    cancellation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneRequiredWithoutBillingsNestedInput
    clientCompany?: ClientCompanyUpdateOneWithoutBillingsNestedInput
    items?: BillingItemUpdateManyWithoutBillingNestedInput
  }

  export type BillingUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    client_company_id?: NullableStringFieldUpdateOperationsInput | string | null
    billing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_prefix?: StringFieldUpdateOperationsInput | string
    invoice_sequence?: IntFieldUpdateOperationsInput | number
    billing_address?: StringFieldUpdateOperationsInput | string
    subtotal_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    cancellation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    items?: BillingItemUncheckedUpdateManyWithoutBillingNestedInput
  }

  export type BillingUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    client_company_id?: NullableStringFieldUpdateOperationsInput | string | null
    billing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_prefix?: StringFieldUpdateOperationsInput | string
    invoice_sequence?: IntFieldUpdateOperationsInput | number
    billing_address?: StringFieldUpdateOperationsInput | string
    subtotal_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    cancellation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientPhoneUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientPhoneUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientPhoneUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientEmailUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientEmailUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientEmailUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAddressUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    suite?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAddressUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    suite?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAddressUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    suite?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: ClientCompanyPhoneUpdateManyWithoutCompanyNestedInput
    emails?: ClientCompanyEmailUpdateManyWithoutCompanyNestedInput
    addresses?: ClientCompanyAddressUpdateManyWithoutCompanyNestedInput
    billings?: BillingUpdateManyWithoutClientCompanyNestedInput
  }

  export type ClientCompanyUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: ClientCompanyPhoneUncheckedUpdateManyWithoutCompanyNestedInput
    emails?: ClientCompanyEmailUncheckedUpdateManyWithoutCompanyNestedInput
    addresses?: ClientCompanyAddressUncheckedUpdateManyWithoutCompanyNestedInput
    billings?: BillingUncheckedUpdateManyWithoutClientCompanyNestedInput
  }

  export type ClientCompanyUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyPhoneCreateManyCompanyInput = {
    id?: string
    phone_number: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientCompanyEmailCreateManyCompanyInput = {
    id?: string
    email: string
    type: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClientCompanyAddressCreateManyCompanyInput = {
    id?: string
    type: string
    street: string
    suite?: string | null
    city: string
    state: string
    zip_code: string
    country: string
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BillingCreateManyClientCompanyInput = {
    id?: string
    account_id: string
    client_id: string
    billing_date?: Date | string
    due_date?: Date | string | null
    invoice_number: string
    invoice_prefix?: string
    invoice_sequence: number
    billing_address: string
    subtotal_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string
    discount_amount?: Decimal | DecimalJsLike | number | string
    total_amount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    status?: $Enums.BillingStatus
    cancellation_date?: Date | string | null
    cancellation_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type ClientCompanyPhoneUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyPhoneUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyPhoneUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyEmailUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyEmailUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyEmailUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyAddressUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    suite?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyAddressUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    suite?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCompanyAddressUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    suite?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingUpdateWithoutClientCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    billing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_prefix?: StringFieldUpdateOperationsInput | string
    invoice_sequence?: IntFieldUpdateOperationsInput | number
    billing_address?: StringFieldUpdateOperationsInput | string
    subtotal_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    cancellation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneRequiredWithoutBillingsNestedInput
    client?: ClientUpdateOneRequiredWithoutBillingsNestedInput
    items?: BillingItemUpdateManyWithoutBillingNestedInput
  }

  export type BillingUncheckedUpdateWithoutClientCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    billing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_prefix?: StringFieldUpdateOperationsInput | string
    invoice_sequence?: IntFieldUpdateOperationsInput | number
    billing_address?: StringFieldUpdateOperationsInput | string
    subtotal_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    cancellation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    items?: BillingItemUncheckedUpdateManyWithoutBillingNestedInput
  }

  export type BillingUncheckedUpdateManyWithoutClientCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    billing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_prefix?: StringFieldUpdateOperationsInput | string
    invoice_sequence?: IntFieldUpdateOperationsInput | number
    billing_address?: StringFieldUpdateOperationsInput | string
    subtotal_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    cancellation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceCreateManyUnit_of_measureInput = {
    id?: string
    account_id: string
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    is_discount?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ServiceUpdateWithoutUnit_of_measureInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_discount?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_items?: BillingItemUpdateManyWithoutServiceNestedInput
    account?: AccountUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ServiceUncheckedUpdateWithoutUnit_of_measureInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_discount?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_items?: BillingItemUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutUnit_of_measureInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_discount?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingItemCreateManyServiceInput = {
    id?: string
    billing_id: string
    description?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    unit_price: Decimal | DecimalJsLike | number | string
    tax_percent?: Decimal | DecimalJsLike | number | string
    discount_percent?: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string
    discount_amount?: Decimal | DecimalJsLike | number | string
    line_total: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type BillingItemUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    line_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    billing?: BillingUpdateOneRequiredWithoutItemsNestedInput
  }

  export type BillingItemUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    billing_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    line_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillingItemUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    billing_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    line_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillingItemCreateManyBillingInput = {
    id?: string
    service_id: string
    description?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    unit_price: Decimal | DecimalJsLike | number | string
    tax_percent?: Decimal | DecimalJsLike | number | string
    discount_percent?: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string
    discount_amount?: Decimal | DecimalJsLike | number | string
    line_total: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    updated_by?: string | null
  }

  export type BillingItemUpdateWithoutBillingInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    line_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceUpdateOneRequiredWithoutBilling_itemsNestedInput
  }

  export type BillingItemUncheckedUpdateWithoutBillingInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    line_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillingItemUncheckedUpdateManyWithoutBillingInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_percent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    line_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAccountCreateManyUserInput = {
    account_id: string
    role: string
    created_at?: Date | string
  }

  export type AccountAuthCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type UserAccountUpdateWithoutUserInput = {
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserAccountUncheckedUpdateWithoutUserInput = {
    account_id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccountUncheckedUpdateManyWithoutUserInput = {
    account_id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountAuthUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountAuthUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountAuthUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}